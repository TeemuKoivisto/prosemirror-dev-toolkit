{"version":3,"sources":["components/NavBar.tsx","components/WrappedRoute.tsx","../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../../../node_modules/@babel/runtime/helpers/typeof.js","../../../node_modules/svelte/internal/index.mjs","../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../../../node_modules/@babel/runtime/helpers/esm/typeof.js","../../src/context.ts","../../../node_modules/style-inject/dist/style-inject.es.js","../../src/components/FloatingBtn.svelte","../../../node_modules/svelte/store/index.mjs","../../src/stores/snapshots.ts","../../src/tabs/TabsMenu.svelte","../../src/history-and-diff/diff.ts","../../src/history-and-diff/transaction.ts","../../src/history-and-diff/createHistoryEntry.ts","../../src/stores/stateHistory.ts","../../src/tabs/state/selection.ts","../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/svelte-tree-view/package/tree-utils.js","../../../node_modules/svelte-tree-view/package/TreeViewNode.svelte","../../../node_modules/svelte-tree-view/package/TreeView.svelte","../../../node_modules/svelte-tree-view/package/stores/props.js","../../../node_modules/svelte-tree-view/package/stores/root-element.js","../../../node_modules/svelte-tree-view/package/stores/tree.js","../../src/tabs/SplitView.svelte","../../src/components/Button.svelte","../../src/tabs/state/StateTab.svelte","../../src/tabs/state/getActiveMarks.ts","../../src/tabs/history/mapDeltas.ts","../../src/tabs/history/HistoryList.svelte","../../src/tabs/history/DiffValue.svelte","../../src/tabs/history/HistoryTab.svelte","../../src/tabs/List.svelte","../../src/tabs/PluginsTab.svelte","../../src/tabs/SchemaTab.svelte","../../src/tabs/structure/DocNode.svelte","../../src/tabs/structure/colors.ts","../../src/tabs/structure/DocView.svelte","../../src/tabs/structure/StructureTab.svelte","../../src/tabs/snapshots/SnapshotsList.svelte","../../src/tabs/snapshots/SnapshotsTab.svelte","../../src/components/FloatingDock.svelte","../../src/components/DevTools.svelte","../../src/history-and-diff/subscribeToTransactions.ts","../../src/applyDevTools.ts","pm/schema.ts","pm/example-plugin/types.ts","pm/example-plugin/index.ts","pm/example-plugin/findChangedNodes.ts","pm/PMEditor.tsx","components/Editor.tsx","pages/FrontPage.tsx","pages/DevToolsPage.tsx","pages/PlainPMPage.tsx","pages/YjsPage.tsx","pages/NoEditorPage.tsx","routes.tsx","index.tsx"],"names":["NavBar","props","className","Container","Nav","Link","to","exact","activeClassName","styled","div","nav","NavLink","WrappedRoute","Component","component","rest","render","MainWrapper","MainContainer","main","_classCallCheck","instance","Constructor","TypeError","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","o","p","Object","_inherits","subClass","superClass","constructor","value","writable","configurable","setPrototypeOf","Symbol","module","_typeof","obj","_possibleConstructorReturn","call","assertThisInitialized","_getPrototypeOf","_arrayLikeToArray","arr","len","i","arr2","Array","_unsupportedIterableToArray","minLen","arrayLikeToArray","n","test","_slicedToArray","arrayWithHoles","_i","_arr","_n","_d","_s","err","_e","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","_toConsumableArray","arrayWithoutHoles","iter","iterableToArray","nonIterableSpread","_defineProperties","target","descriptor","noop","tar","src","run","fn","blank_object","run_all","fns","is_function","thing","safe_not_equal","a","b","subscribe","store","callbacks","unsub","get_store_value","_","component_subscribe","callback","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","assign","get_slot_changes","dirty","lets","merged","Math","update_slot_base","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","get_all_dirty_from_scope","length","exclude_internal_props","result","k","compute_rest_props","keys","Set","null_to_empty","append","node","insert","anchor","detach","destroy_each","iterations","detaching","document","svg_element","name","space","text","empty","listen","event","handler","options","attr","attribute","set_attributes","attributes","descriptors","key","xlink_attr","children","element","set_data","data","toggle_class","toggle","set_current_component","current_component","get_current_component","Error","onMount","createEventDispatcher","type","detail","bubbles","e","custom_event","bubble","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","update_scheduled","add_render_callback","flushing","seen_callbacks","flush","update","$$","outroing","group_outros","outros","r","c","check_outros","transition_in","block","local","transition_out","create_component","mount_component","customElement","fragment","on_mount","on_destroy","after_update","new_on_destroy","destroy_component","make_dirty","parent_component","not_equal","bound","on_disconnect","before_update","context","Map","skip_bound","root","append_styles","ready","ret","create_fragment","nodes","SvelteComponent","protoProps","staticProps","this","index","$$set","setContext","val","setCtx","getContext","getCtx","styleInject","css","ref","insertAt","head","style","buttonPosition","subscriber_queue","start","subscribers","run_queue","subscriber","set","invalidate","stop","derived","stores","initial_value","single","stores_array","auto","inited","values","pending","cleanup","sync","unsubscribers","SNAPSHOTS_KEY","snapshots","selectedSnapshot","previousEditorState","persisted","window","localStorage","getItem","parsed","JSON","parse","console","error","setEditorDoc","view","doc","state","schema","nodeFromJSON","tr","replaceWith","nodeSize","content","dispatch","updateSnapshot","snapshot","map","s","timestamp","exportSnapshot","createElement","file","Blob","stringify","href","URL","createObjectURL","download","click","deleteSnapshot","filter","selected","get","undefined","setItem","active","onClickTab","diffPatcher","arrays","detectMove","includeValueOnMove","textDiff","minLength","diff","inputA","inputB","addedProperties","addPropertiesToTransaction","concat","reduce","acc","buildSelection","selection","from","pad","num","slice","formatTimestamp","date","Date","getHours","getMinutes","getSeconds","getMilliseconds","join","regexp","highlightHtmlString","html","replace","stateHistory","shownHistoryGroups","latestEntry","appendNewHistoryEntry","stateBeforeDispatch","entryMap","prevGroup","newEntry","oldEntry","serializer","fromSchema","domFragment","serializeFragment","selectedElementsAsHtml","child","firstChild","push","outerHTML","nextSibling","prevState","contentDiff","toJSON","selectionDiff","id","random","toString","time","timeStr","selectionHtml","max_char","indent_size","createHistoryEntry","topEntryId","isGroup","newGroup","entryIds","expanded","resetHistory","defaultProperties","resolvedPosProperties","resolvedPosSubProperties","createSelection","createFullSelection","includes","additionalProperties","forEach","subKey","_defineProperty","enumerable","createNode","depth","parent","path","collapsed","getValueType","parentId","circularOfId","recurseObjectProperties","ensureNotCollapsed","treeMap","oldTreeMap","iteratedValues","recomputeExpandNode","opts","_a","oldNode","existingNodeWithValue","shouldRecurseChildren","mappedChildren","getChildren","idx","showLogButton","showCopyButton","treeStore","propsStore","rootElementStore","found","$","hasChildren","valueComponent","$props","navigator","$rootElementStore","theme","recursionOpts","valueFormatter","rootElement","defaultRecursionOpts","maxDepth","omitKeys","stopCircularRecursion","shouldExpandNode","initialProps","setProps","formatValue","customFormat","String","createPropsStore","createRootElementStore","defaultRootNode","tree","init","getNode","toggleCollapse","updatedNode","m","expandNodeChildren","newTreeMap","previouslyIterated","nodeWithUpdatedChildren","expandAllNodesToNode","updated","recurseNodeUpwards","createTreeStore","newRecursionOpts","recomputeTree","rootNode","levels","updates","to_null_out","accounted_for","formatDocNodeValue","childCount","$from","storedMarks","mark","marks","$head","$anchor","activeMarks","add","mapSelectionDeltaChildren","_val","_parent","mapDocDeltaChildren","delta","_t","transformed","charAt","substr","entries","dispatchClick","group","groupIdx","wasTopNode","dispatchDblClick","subEntry","parseTextDiff","getValueString","delete","DiffValue","mapChildren","listItems","onSelect","item","nodeColors","buildColors","safeIndex","total","quotient","round","floor","calculateSafeIndex","class","handleSnapDoubleclick","snap","handleClickView","handleRestoreClick","handleExportClick","handleClickDelete","updateState","toggleViewSnapshot","important","snapshotName","now","json","fileinput","resetDispatch","subscribeToDispatchTransaction","oldDispatchFn","someProp","bind","dispatchTransaction","apply","unsubscribeDispatchTransaction","removeCallback","DEVTOOLS_CSS_CLASS","createOrFindPlace","place","querySelector","body","appendChild","applyDevTools","removeDevTools","comp","DevTools","editorView","oldDestroyFn","destroy","$destroy","Schema","paragraph","parseDOM","tag","toDOM","blockquote","defining","horizontal_rule","heading","attrs","level","default","code_block","code","preserveWhitespace","image","inline","alt","title","draggable","getAttrs","dom","getAttribute","hard_break","selectable","link","inclusive","italic","bold","fontWeight","DummyClass","examplePluginKey","PluginKey","joinStates","s1","s2","changedNodesMap","changedNodesTypesSet","examplePlugin","Plugin","config","decorationSet","DecorationSet","exampleMap","exampleSet","exampleClasses","trackedTrs","joined","oldState","newState","oldDoc","nodesMap","typesSet","steps","step","sliceSize","size","isInsert","isReplace","operation","nodesBetween","pos","has","descendants","findAddedOrRemovedNodes","getMeta","decorations","getState","PMEditor","editorDOMRef","useRef","editorViewRef","transaction","current","editorState","onEdit","useLayoutEffect","EditorState","create","plugins","exampleSetup","editorViewDOM","EditorView","mount","createEditorView","onEditorReady","EditorStore","currentEditorState","localStorageKey","setEditorView","fromJSON","syncCurrentEditorState","existing","stored","Editor","useDevTools","editorStore","useMemo","debouncedSync","debounce","applyDevToolkit","devToolsExpanded","FrontPage","DevToolsPage","PlainPMPage","useEffect","YjsPage","ydoc","Y","permanentUserData","yXmlFragment","getXmlFragment","history","ySyncPlugin","colors","light","dark","yUndoPlugin","keymap","undo","redo","NoEditorPage","Routes","basename","process","getElementById"],"mappings":"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","file":"static/js/main.caf38d22.chunk.js","sourcesContent":["import React from 'react'\nimport { NavLink } from 'react-router-dom'\nimport styled from 'styled-components'\n\nimport { RouteComponentProps } from 'react-router'\n\ninterface IProps extends RouteComponentProps<{}> {\n  className?: string\n}\n\nexport function NavBar(props: IProps) {\n  const { className } = props\n  return (\n    <Container className={className}>\n      <Nav>\n        <Link to=\"/\" exact activeClassName=\"current\">Front page</Link>\n        <Link to=\"/dev-tools\" exact activeClassName=\"current\">Dev tools</Link>\n        <Link to=\"/plain\" exact activeClassName=\"current\">Plain</Link>\n        <Link to=\"/yjs\" exact activeClassName=\"current\">Yjs</Link>\n        <Link to=\"/no-editor\" exact activeClassName=\"current\">No editor</Link>\n      </Nav>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n  background: var(--color-primary);\n  box-shadow: 0 0 2px 2px rgba(0,0,0,0.18);\n  padding: 1rem;\n`\nconst Nav = styled.nav`\n  align-items: center;\n  color: #fff;\n  display: flex;\n`\nconst Link = styled(NavLink)`\n  box-sizing: border-box;\n  color: #fff;\n  cursor: pointer;\n  font-size: 1rem;\n  padding: 0.5rem 1rem;\n  text-decoration: none;\n  transition: 0.2s hover;\n  &:hover {\n    text-decoration: underline;\n  }\n  &.current {\n    font-weight: 600;\n  }\n`\n","import * as React from 'react'\nimport { Route, RouteProps, RouteComponentProps } from 'react-router'\nimport styled from 'styled-components'\n\nimport { NavBar } from './NavBar'\n\ntype ReactComponent = React.ComponentClass<any> | React.StatelessComponent<any>\n\ninterface IWrappedRoute extends RouteProps {\n  component: ReactComponent\n}\n\nconst renderNoMainContainerWrapper = (Component: ReactComponent) => (props: RouteComponentProps<any>) =>\n  <MainWrapper>\n    <NavBar {...props}/>\n    <Component {...props}/>\n  </MainWrapper>\n\nconst renderWrapper = (Component: ReactComponent) => (props: RouteComponentProps<any>) =>\n  <MainWrapper>\n    <NavBar {...props}/>\n    <MainContainer>\n      <Component {...props}/>\n    </MainContainer>\n  </MainWrapper>\n\nexport const NoMainContainerRoute = ({ component, ...rest } : IWrappedRoute) =>\n  <Route {...rest} render={renderNoMainContainerWrapper(component)}/>\n\nexport const WrappedRoute = ({ component, ...rest } : IWrappedRoute) =>\n  <Route {...rest} render={renderWrapper(component)}/>\n\nconst MainWrapper = styled.div`\n  min-height: 100vh;\n`\nconst MainContainer = styled.main`\n  margin: 40px auto 0 auto;\n  max-width: 680px;\n  padding-bottom: 20px;\n  @media only screen and (max-width: 720px) {\n    margin: 40px 20px 0 20px;\n    padding-bottom: 20px;\n  }\n`\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.0' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","import _typeof from \"@babel/runtime/helpers/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import { EditorView } from 'prosemirror-view'\nimport type { EditorState } from 'prosemirror-state'\nimport type { Node as PMNode } from 'prosemirror-model'\nimport { getContext as getCtx, setContext as setCtx } from 'svelte'\n\nimport { buildColors } from './tabs/structure/colors'\n\nexport type Contexts = {\n  'editor-view': {\n    view: EditorView\n    replaceEditorContent: (state: EditorState) => void\n  }\n  'doc-view': {\n    selected: {\n      type: string\n      start: number\n      end: number\n    }\n    colors: ReturnType<typeof buildColors>\n    handleNodeClick: (n: PMNode) => void\n  }\n}\n\nexport const setContext = <K extends keyof Contexts & string>(ctx: K, val: Contexts[K]) =>\n  setCtx<Contexts[K]>(ctx, val)\n\nexport const getContext = <K extends keyof Contexts & string>(ctx: K) => getCtx<Contexts[K]>(ctx)\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","<script lang=\"ts\">\n  import type { ButtonPosition } from '../types'\n\n  export let buttonPosition: ButtonPosition\n</script>\n\n<button class={`floating-btn ${buttonPosition}`} on:click>\n  <svg\n    width=\"530\"\n    height=\"530\"\n    viewBox=\"0 0 530 530\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n  >\n    <title>prosemirror</title>\n    <desc>Created using Figma</desc>\n    <use xlink:href=\"#a\" transform=\"matrix(2 0 0 2 118 116)\" fill=\"#FFF\" />\n    <use xlink:href=\"#b\" transform=\"rotate(16 59.054 420.192) scale(2)\" fill=\"#FFF\" />\n    <use xlink:href=\"#c\" transform=\"matrix(2 0 0 2 154.024 141.58)\" fill=\"#363755\" />\n    <use xlink:href=\"#d\" transform=\"matrix(2 0 0 2 220 334.8)\" fill=\"#FFF\" />\n    <use xlink:href=\"#e\" transform=\"matrix(2 0 0 2 218.826 262.052)\" fill=\"#363755\" />\n    <use xlink:href=\"#f\" transform=\"matrix(2 0 0 2 197.108 184.998)\" fill=\"#FFF\" />\n    <use xlink:href=\"#g\" transform=\"matrix(2 0 0 2 221.8 216)\" fill=\"#363755\" />\n    <defs>\n      <path\n        id=\"a\"\n        d=\"M73.5 0C32.859 0 0 32.859 0 73.5S32.859 147 73.5 147 147 114.141 147 73.5 114.069 0 73.5\n        0z\"\n      />\n      <path\n        id=\"b\"\n        d=\"M193.601 107.116c0-13.376 8.238-23.91\n        20.619-31.153-2.244-7.447-5.19-14.6-8.824-21.32-13.886\n        3.633-25.12-1.799-34.568-11.26-9.449-9.437-12.344-20.672-8.709-34.571A111.362 111.362 0 0 0\n        140.799 0c-7.243 12.37-20.339 20.594-33.689 20.594-13.363\n        0-26.446-8.225-33.701-20.594A110.888 110.888 0 0 0 52.1 8.812c3.634 13.9.753 25.134-8.721\n        34.57-9.436 9.462-20.67 14.894-34.569 11.26A112.178 112.178 0 0 0 0 75.963c12.369 7.243\n        20.593 17.777 20.593 31.153 0 13.352-8.224 26.448-20.593 33.704a113.338 113.338 0 0 0 8.811\n        21.321c13.899-3.634 25.133-.752 34.569 8.697 9.448 9.462 12.355 20.696 8.721 34.57a112.653\n        112.653 0 0 0 21.32 8.837c7.243-12.407 20.338-20.619 33.702-20.619 13.35 0 26.446 8.225\n        33.701 20.619a114.22 114.22 0 0 0 21.32-8.837c-3.634-13.874-.752-25.108 8.709-34.57\n        9.449-9.437 20.683-14.869 34.569-11.26a112.343 112.343 0 0 0\n        8.823-21.321c-12.406-7.256-20.644-17.789-20.644-31.141zm-86.491 46.57c-25.732\n        0-46.58-20.849-46.58-46.57 0-25.733 20.86-46.595 46.58-46.595 25.732 0 46.567 20.875 46.567\n        46.595 0 25.734-20.835 46.57-46.567 46.57z\"\n      />\n      <path\n        id=\"c\"\n        d=\"M98.088 49.91c-6.9 83.9 10.8 103.401 10.8 103.401s-55.1\n        5.499-82.7-13.401c-30.5-20.9-26-67.5-25.9-94.6.1-28.4 25.6-45.8 49.9-45.3 29.1.5 50.2 21.6\n        47.9 49.9z\"\n      />\n      <path\n        id=\"d\"\n        d=\"M.1.1c12.2 33.3 22.5 42.7 40 55.2 25.3 18 36.6 17.5 76.3 41C78.1 60.3 30.8 45.7 0 0l.1.1z\"\n      />\n      <path\n        id=\"e\"\n        d=\"M.687 36.474c3 13.3 17.9 29.9 30.4 41.6 24.8 23.2 42 22.4 86\n        54.7-18.2-51.8-18.8-62-43.5-106.1-24.7-44-67.6-20.3-67.6-20.3s-8.4 16.6-5.3 29.9v.2z\"\n      />\n      <path\n        id=\"f\"\n        d=\"M38.346 11.5s-4-11.6-18-11.5c-30 .2-28.8 52.1 16.9 52 39.6-.1 39.2-49.4\n        16.1-49.6-10.2-.2-15 9.1-15 9.1z\"\n      />\n      <path\n        id=\"g\"\n        d=\"M26.5 15c10.8 0 2 14.9-.6 20.9-1.8-8.4-10.2-20.9.6-20.9zM10.2.1C4.6.1 0 4.6 0 10.3c0 5.6\n        4.5 10.2 10.2 10.2 5.6 0 10.2-4.5 10.2-10.2C20.4 4.7 15.9.1 10.2.1zM40.7 0c-4.8 0-8.8\n        4.5-8.8 10.2 0 5.6 3.9 10.2 8.8 10.2 4.8 0 8.8-4.5 8.8-10.2C49.5 4.6 45.6 0 40.7 0z\"\n      />\n    </defs>\n  </svg>\n</button>\n\n<style lang=\"scss\">\n  .floating-btn {\n    background: $color-blue-bg;\n    border: 0;\n    border-radius: 50%;\n    box-shadow: 0 0 30px rgba($color-black, 0.3);\n    cursor: pointer;\n    position: fixed;\n    padding: 6px;\n    transition: opacity 0.3s;\n    -webkit-transition: opacity 0.3s;\n    z-index: 99999;\n  }\n  .floating-btn.bottom-right {\n    bottom: 16px;\n    right: 16px;\n  }\n  .floating-btn.bottom-left {\n    bottom: 16px;\n    left: 16px;\n  }\n  .floating-btn.top-right {\n    top: 16px;\n    right: 16px;\n  }\n  .floating-btn.top-left {\n    top: 16px;\n    left: 16px;\n  }\n  .floating-btn:hover {\n    opacity: 0.7;\n  }\n  .floating-btn > svg {\n    display: block;\n    width: 34px;\n    height: 34px;\n    position: relative;\n  }\n</style>\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import type { EditorView } from 'prosemirror-view'\nimport type { EditorState } from 'prosemirror-state'\nimport type { Node as PMNode } from 'prosemirror-model'\nimport { get, writable } from 'svelte/store'\n\nimport type { Snapshot } from '$typings/snapshots'\nimport { Schema } from 'prosemirror-model'\n\nconst SNAPSHOTS_KEY = '__prosemirror-dev-toolkit__snapshots'\n\nexport const snapshots = writable<Snapshot[]>([])\nexport const selectedSnapshot = writable<Snapshot | undefined>()\nexport const previousEditorState = writable<EditorState | undefined>()\n\nconst persisted = typeof window !== 'undefined' ? localStorage.getItem(SNAPSHOTS_KEY) : null\nif (persisted && persisted.length > 0) {\n  try {\n    const parsed = JSON.parse(persisted)\n    snapshots.set(parsed)\n  } catch (err) {\n    console.error('Corrupted snapshots values in localStorage', err)\n  }\n}\n\nsnapshots.subscribe(val => {\n  if (typeof window !== 'undefined') {\n    localStorage.setItem(SNAPSHOTS_KEY, JSON.stringify(val))\n  }\n})\n\nfunction setEditorDoc(view: EditorView, doc: { [key: string]: any }) {\n  const node: PMNode = view.state.schema.nodeFromJSON(doc)\n  const tr = view.state.tr\n  tr.replaceWith(0, view.state.doc.nodeSize - 2, node.content)\n  view.dispatch(tr)\n}\n\nexport function saveSnapshot(snapshotName: string, doc: { [key: string]: any }) {\n  const snap: Snapshot = {\n    name: snapshotName,\n    timestamp: Date.now(),\n    doc\n  }\n  snapshots.update(val => [snap, ...val])\n}\n\nexport function importSnapshot(\n  snapshotName: string,\n  json: { [key: string]: unknown },\n  schema: Schema\n) {\n  const doc = schema.nodeFromJSON(json)\n  const snap: Snapshot = {\n    name: snapshotName,\n    timestamp: Date.now(),\n    doc: doc.toJSON()\n  }\n  snapshots.update(val => [snap, ...val])\n}\n\nexport function updateSnapshot(snapshot: Snapshot) {\n  snapshots.update(val =>\n    val.map(s => {\n      if (s.timestamp === snapshot.timestamp) {\n        return snapshot\n      }\n      return s\n    })\n  )\n}\n\nexport function toggleViewSnapshot(view: EditorView, snap?: Snapshot) {\n  if (snap) {\n    const prevState = get(previousEditorState)\n    if (!prevState) previousEditorState.set(view.state)\n    setEditorDoc(view, snap.doc)\n  } else {\n    const prevState = get(previousEditorState)\n    if (!prevState) {\n      console.error('No previous state to restore!')\n    } else {\n      view.updateState(prevState)\n    }\n    previousEditorState.set(undefined)\n  }\n  selectedSnapshot.set(snap)\n}\n\nexport function restoreSnapshot(view: EditorView, snap: Snapshot) {\n  setEditorDoc(view, snap.doc)\n  previousEditorState.set(undefined)\n  selectedSnapshot.set(undefined)\n}\n\nexport function exportSnapshot(snapshot: Snapshot) {\n  const a = document.createElement('a')\n  const file = new Blob([JSON.stringify(snapshot.doc)], { type: 'application/json' })\n  a.href = URL.createObjectURL(file)\n  a.download = `${snapshot.name}.json`\n  a.click()\n}\n\nexport function deleteSnapshot(snapshot: Snapshot) {\n  snapshots.update(val => val.filter(s => s.timestamp !== snapshot.timestamp))\n  const selected = get(selectedSnapshot)\n  if (selected?.timestamp === snapshot.timestamp) {\n    selectedSnapshot.set(undefined)\n  }\n}\n","<script lang=\"ts\">\n  export let active: string, onClickTab: (tab: string) => void\n</script>\n\n<ul class=\"tabs-menu\">\n  <li>\n    <button class:active={active === 'state'} on:click={() => onClickTab('state')}>STATE</button>\n  </li>\n  <li>\n    <button class:active={active === 'history'} on:click={() => onClickTab('history')}\n      >HISTORY</button\n    >\n  </li>\n  <li>\n    <button class:active={active === 'plugins'} on:click={() => onClickTab('plugins')}\n      >PLUGINS</button\n    >\n  </li>\n  <li>\n    <button class:active={active === 'schema'} on:click={() => onClickTab('schema')}>SCHEMA</button>\n  </li>\n  <li>\n    <button class:active={active === 'structure'} on:click={() => onClickTab('structure')}\n      >STRUCTURE</button\n    >\n  </li>\n  <li>\n    <button class:active={active === 'snapshots'} on:click={() => onClickTab('snapshots')}\n      >SNAPSHOTS</button\n    >\n  </li>\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    display: flex;\n    list-style: none;\n    margin: 0;\n    overflow-x: scroll;\n    padding: 0;\n  }\n  button {\n    background: transparent;\n    border: 0;\n    border-bottom: 2px solid transparent;\n    color: $color-white;\n    cursor: pointer;\n    height: 100%;\n    padding: 1em;\n    &:hover {\n      background: rgba($color-white, 0.05);\n    }\n    &.active {\n      border-bottom: 2px solid $color-red-light;\n    }\n  }\n</style>\n","import { DiffPatcher } from 'jsondiffpatch'\n\nconst diffPatcher = new DiffPatcher({\n  arrays: { detectMove: false, includeValueOnMove: false },\n  textDiff: { minLength: 1 }\n})\n\nexport function diff(inputA: any, inputB: any) {\n  return diffPatcher.diff(inputA, inputB)\n}\n","import type { Transaction } from 'prosemirror-state'\n\nconst addedProperties = [\n  'docChanged',\n  'isGeneric',\n  'scrolledIntoView',\n  'selectionSet',\n  'storedMarksSet'\n]\n\nexport function addPropertiesToTransaction(tr: Transaction) {\n  return Object.keys(tr)\n    .concat(addedProperties)\n    .reduce((acc, key) => {\n      // @ts-ignore\n      acc[key] = tr[key]\n      return acc\n    }, {} as Transaction)\n}\n","import type { EditorState, Selection, Transaction } from 'prosemirror-state'\nimport { DOMSerializer } from 'prosemirror-model'\nimport { prettyPrint } from 'html'\n\nimport { diff } from './diff'\nimport { addPropertiesToTransaction } from './transaction'\nimport type { HistoryEntry } from '$typings/history'\n\nfunction buildSelection(selection: Selection) {\n  return {\n    // @ts-ignore\n    type: selection.type,\n    empty: selection.empty,\n    anchor: selection.anchor,\n    head: selection.head,\n    from: selection.from,\n    to: selection.to\n  }\n}\n\nfunction pad(num: number) {\n  return ('00' + num).slice(-2)\n}\n\nfunction pad3(num: number) {\n  return ('000' + num).slice(-3)\n}\n\nconst formatTimestamp = (timestamp: number) => {\n  const date = new Date(timestamp)\n  return [\n    pad(date.getHours()),\n    pad(date.getMinutes()),\n    pad(date.getSeconds()),\n    pad3(date.getMilliseconds())\n  ].join(':')\n}\n\nconst regexp = /(&lt;\\/?[\\w\\d\\s=\"']+&gt;)/gim\nconst highlightHtmlString = (html: string) =>\n  html\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(regexp, \"<span style='color: cadetblue;'>$&</span>\")\n\nexport function createHistoryEntry(\n  tr: Transaction,\n  state: EditorState,\n  stateBeforeDispatch: EditorState,\n  oldEntry?: HistoryEntry\n): HistoryEntry {\n  const serializer = DOMSerializer.fromSchema(state.schema)\n  const selection = state.selection\n  const domFragment = serializer.serializeFragment(selection.content().content)\n\n  const selectedElementsAsHtml = []\n  if (domFragment) {\n    let child = domFragment.firstChild as HTMLElement | null\n    while (child) {\n      selectedElementsAsHtml.push(child.outerHTML)\n      child = child.nextSibling as HTMLElement | null\n    }\n  }\n\n  // As described in stateHistory.ts the first entry is a special exception\n  const prevState = oldEntry ? oldEntry.state : stateBeforeDispatch\n  const contentDiff = diff(prevState.doc.toJSON(), state.doc.toJSON())\n  const selectionDiff = diff(buildSelection(prevState.selection), buildSelection(state.selection))\n\n  return {\n    id: Math.random().toString() + Math.random().toString(),\n    state,\n    tr: addPropertiesToTransaction(tr),\n    timestamp: tr.time,\n    timeStr: formatTimestamp(tr.time),\n    contentDiff,\n    selectionDiff,\n    selectionHtml: highlightHtmlString(\n      prettyPrint(selectedElementsAsHtml.join('\\n'), {\n        max_char: 60,\n        indent_size: 2\n      })\n    )\n  }\n}\n","import { get, writable } from 'svelte/store'\nimport { EditorState, Transaction } from 'prosemirror-state'\n\nimport { createHistoryEntry } from '../history-and-diff/createHistoryEntry'\n\nimport type { HistoryEntry, HistoryGroup } from '$typings/history'\n\nexport const stateHistory = writable<Map<string, HistoryEntry>>(new Map())\nexport const shownHistoryGroups = writable<HistoryGroup[]>([])\nexport const latestEntry = writable<HistoryEntry | undefined>(undefined)\n\nexport function appendNewHistoryEntry(\n  tr: Transaction,\n  state: EditorState,\n  stateBeforeDispatch: EditorState\n) {\n  const entryMap = get(stateHistory)\n  const prevGroup = get(shownHistoryGroups)[0]\n  const oldEntry = entryMap.get(prevGroup?.topEntryId || '')\n  // In the case of first entry there aren't oldEntries to diff against, therefore we have to use the state\n  // before the transaction. We can't use it for the next entries because it will always be one state behind,\n  // as the current state is the one _after_ the dispatch. You can observe this in the old dev-tools.\n  const newEntry = createHistoryEntry(tr, state, stateBeforeDispatch, oldEntry)\n\n  stateHistory.update(val => new Map(val.set(newEntry.id, newEntry)))\n  latestEntry.set(newEntry)\n\n  // Groups are subsequent transactions where the doc hasn't changed (eg selection was set) OR the diff was equal\n  // Haven't seen necessary to differentiate between selection-only vs equal diffs\n  const isGroup = !newEntry.contentDiff\n  if (prevGroup?.isGroup && isGroup) {\n    const newGroup = {\n      isGroup,\n      entryIds: [newEntry.id, ...prevGroup.entryIds],\n      topEntryId: newEntry.id,\n      expanded: prevGroup.expanded\n    }\n    shownHistoryGroups.update(val => [newGroup, ...val.slice(1)])\n  } else {\n    const newGroup = {\n      isGroup,\n      entryIds: [newEntry.id],\n      topEntryId: newEntry.id,\n      expanded: false\n    }\n    shownHistoryGroups.update(val => [newGroup, ...val])\n  }\n}\n\nexport function resetHistory() {\n  stateHistory.set(new Map())\n  shownHistoryGroups.set([])\n  latestEntry.set(undefined)\n}\n","import { Selection } from 'prosemirror-state'\n\nconst defaultProperties = ['jsonID', 'empty', 'anchor', 'from', 'head', 'to']\nconst resolvedPosProperties = ['$anchor', '$head', '$cursor', '$to', '$from']\nconst resolvedPosSubProperties = ['nodeAfter', 'nodeBefore', 'textOffset']\n\nexport function createSelection(selection: Selection) {\n  return defaultProperties.reduce((acc, key) => {\n    // @ts-ignore\n    acc[key] = selection[key]\n    return acc\n  }, {} as { [key: string]: any })\n}\n\nexport function createFullSelection(selection: Selection) {\n  return defaultProperties.concat(resolvedPosProperties).reduce((acc, key) => {\n    // @ts-ignore\n    let val = selection[key]\n    if (val && resolvedPosProperties.includes(key)) {\n      const additionalProperties = {}\n      resolvedPosSubProperties.forEach(subKey => {\n        // @ts-ignore\n        additionalProperties[subKey] = val[subKey]\n      })\n      val = { ...val, ...additionalProperties }\n    }\n    acc[key] = val\n    return acc\n  }, {} as { [key: string]: any })\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export function createNode(index, key, value, depth, parent) {\n    const path = parent ? [...parent.path, index] : [];\n    return {\n        id: `[${path.join(',')}]`,\n        index,\n        key,\n        value,\n        depth,\n        collapsed: true,\n        type: getValueType(value),\n        path,\n        parentId: parent ? parent.id : null,\n        circularOfId: null,\n        children: []\n    };\n}\nexport function getValueType(value) {\n    if (Array.isArray(value)) {\n        return 'array';\n    }\n    else if (value instanceof Map) {\n        return 'map';\n    }\n    else if (value instanceof Set) {\n        return 'set';\n    }\n    else if (value instanceof Date) {\n        return 'date';\n    }\n    else if (value === null) {\n        return 'null';\n    }\n    else {\n        return typeof value;\n    }\n}\n// From redux-dev-tools\n// case 'Object':\n//   case 'Error':\n//   case 'Array':\n//   case 'Iterable':\n//   case 'Map':\n//   case 'Set':\n//   case 'MapEntry':\n//   case 'Number':\n//     return undefined;\n//   case 'String':\n//     return raw => `\"${raw}\"`;\n//   case 'Boolean':\n//     return raw => (raw ? 'true' : 'false');\n//   case 'Date':\n//     return raw => raw.toISOString();\n//   case 'Null':\n//     return () => 'null';\n//   case 'Undefined':\n//     return () => 'undefined';\n//   case 'Function':\n//   case 'Symbol':\n// export function objType(obj: any) {\n//   const type = Object.prototype.toString.call(obj).slice(8, -1)\n//   if (type === 'Object') {\n//     if (typeof obj[Symbol.iterator] === 'function') {\n//       return 'Iterable'\n//     }\n//     return obj.constructor.name\n//   }\n//   return type\n// }\nfunction getChildren(value, type) {\n    switch (type) {\n        case 'array':\n            return value.map((v, i) => [i.toString(), v]);\n        case 'map':\n            // eslint-disable-next-line no-case-declarations\n            const entries = Array.from(value.entries());\n            return entries.map(([key, value], i) => [\n                `[map entry ${i}]`,\n                {\n                    '[key]': key,\n                    '[value]': value\n                }\n            ]);\n        case 'set':\n            return Array.from(value.values()).map((v, i) => [`[set entry ${i}]`, v]);\n        case 'object':\n            return Object.entries(value);\n        default:\n            return [];\n    }\n}\nfunction shouldRecurseChildren(node, parent, iteratedValues, opts) {\n    if (!parent) {\n        // The root node's children should always be recursed\n        return true;\n    }\n    else if (node.collapsed && (parent === null || parent === void 0 ? void 0 : parent.collapsed)) {\n        // If the node's parent is uncollapsed the node's children should still be recursed\n        // in order to compute its value properly eg \"{} 4 keys\" and to place clickable arrow caret.\n        // Only when the node is completely hidden it should not be recursed\n        return false;\n    }\n    else if (!opts.stopCircularRecursion) {\n        return true;\n    }\n    else if (opts.isCircularNode) {\n        return opts.isCircularNode(node, iteratedValues);\n    }\n    else if (node.type === 'object' || node.type === 'array') {\n        const existingNodeWithValue = iteratedValues.get(node.value);\n        if (existingNodeWithValue && node.id !== existingNodeWithValue.id) {\n            node.circularOfId = existingNodeWithValue.id;\n            return false;\n        }\n        iteratedValues.set(node.value, node);\n    }\n    return true;\n}\nexport function recurseObjectProperties(index, key, value, depth, ensureNotCollapsed, parent, treeMap, oldTreeMap, iteratedValues, recomputeExpandNode, opts) {\n    var _a;\n    if (((_a = opts.omitKeys) === null || _a === void 0 ? void 0 : _a.includes(key)) || (opts.maxDepth && depth > opts.maxDepth)) {\n        return null;\n    }\n    const node = createNode(index, key, value, depth, parent);\n    const oldNode = oldTreeMap.get(node.id);\n    if (ensureNotCollapsed) {\n        // Used to ensure that either root node is always uncollapsed or when uncollapsing new nodes\n        // with expandNodeChildren the node children are recursed (if applicable) with mapChildren\n        node.collapsed = false;\n    }\n    else if (oldNode && !recomputeExpandNode) {\n        // Maintain the same expanded/collapsed toggle for a node in this path/id\n        // EXCEPT when the shouldExpandNode prop is changed...\n        node.collapsed = oldNode.collapsed;\n    }\n    else if (opts.shouldExpandNode) {\n        node.collapsed = !opts.shouldExpandNode(node);\n    }\n    treeMap.set(node.id, node);\n    if (shouldRecurseChildren(node, parent, iteratedValues, opts)) {\n        const mappedChildren = opts.mapChildren && opts.mapChildren(value, getValueType(value), node);\n        const children = mappedChildren !== null && mappedChildren !== void 0 ? mappedChildren : getChildren(value, getValueType(value));\n        node.children = children\n            .map(([key, val], idx) => recurseObjectProperties(idx, key, val, depth + 1, false, node, treeMap, oldTreeMap, iteratedValues, recomputeExpandNode, opts))\n            .filter(n => n !== null);\n    }\n    return node;\n}\nexport function recomputeTree(data, oldTreeMap, recursionOpts, recomputeExpandNode) {\n    const treeMap = new Map();\n    const iteratedValues = new Map();\n    const newTree = recurseObjectProperties(-1, 'root', data, 0, true, null, treeMap, oldTreeMap, iteratedValues, recomputeExpandNode, recursionOpts);\n    return { treeMap, tree: newTree, iteratedValues };\n}\n","<script >import { getContext } from 'svelte';\nexport let id;\nconst { treeStore, propsStore, rootElementStore } = getContext('svelte-tree-view');\nlet node;\n$: {\n    let found = treeStore.getNode(id);\n    // Should explode rather than have logic written around undefinedness\n    // as this component should be unmounted if it's undefined.\n    if (!found) {\n        throw Error('[svelte-tree-view] TreeViewNode.svelte received undefined node from treeMapStore whereas it should be already unmounted!');\n    }\n    node = found;\n}\n$: hasChildren = node && node.children.length > 0;\n$: props = propsStore.props;\n$: valueComponent = $props.valueComponent;\ntreeStore.treeMap.subscribe(value => {\n    const n = value.get(id);\n    if (n && node !== n) {\n        node = n;\n    }\n});\nfunction handleLogNode() {\n    // eslint-disable-next-line no-console\n    console.info('%c [svelte-tree-view]: Property added to window._node', 'color: #b8e248');\n    // eslint-disable-next-line no-console\n    console.log(node.value);\n    try {\n        if (typeof window !== 'undefined')\n            window._node = node.value;\n    }\n    catch (err) {\n        console.error('Failed to set _node, window was undefined');\n    }\n}\nfunction handleCopyNodeToClipboard() {\n    try {\n        navigator.clipboard.writeText(JSON.stringify(node.value));\n    }\n    catch (err) {\n        console.error('Copying node to clipboard failed: ', err);\n    }\n}\nfunction handleToggleCollapse() {\n    var _a;\n    if (hasChildren) {\n        treeStore.toggleCollapse(node.id);\n    }\n    else if (node.circularOfId) {\n        treeStore.expandAllNodesToNode(node.circularOfId);\n        (_a = $rootElementStore.querySelector(`li[data-tree-id=\"${node.circularOfId}\"]`)) === null || _a === void 0 ? void 0 : _a.scrollIntoView();\n    }\n}\nfunction valueComponentDefaultFormatter(val) {\n    return propsStore.formatValue(val, node);\n}\n</script>\n\n<li class=\"row\" class:collapsed={node.collapsed && hasChildren} data-tree-id={node.id}>\n  {#if hasChildren}\n    <button\n      class={`arrow-btn ${node.collapsed ? 'collapsed' : ''}`}\n      on:click={handleToggleCollapse}\n    >\n      \n    </button>\n  {/if}\n  <div\n    class=\"node-key\"\n    class:has-children={hasChildren}\n    class:p-left={!hasChildren}\n    on:click={handleToggleCollapse}\n  >\n    {node.key}:\n  </div>\n  <div\n    class=\"node-value\"\n    data-type={node.type}\n    class:expanded={!node.collapsed && hasChildren}\n    class:has-children={hasChildren}\n    on:click={handleToggleCollapse}\n  >\n    {#if valueComponent}\n      <svelte:component\n        this={valueComponent}\n        value={node.value}\n        {node}\n        defaultFormatter={valueComponentDefaultFormatter}\n      />\n    {:else}\n      {propsStore.formatValue(node.value, node)}\n    {/if}\n  </div>\n  <div class=\"buttons\">\n    {#if $props.showLogButton}\n      <button class=\"log-copy-button\" on:click={handleLogNode}>log</button>\n    {/if}\n    {#if $props.showCopyButton}\n      <button class=\"log-copy-button\" on:click={handleCopyNodeToClipboard}>copy</button>\n    {/if}\n  </div>\n</li>\n{#if !node.collapsed && hasChildren}\n  <li class=\"row\">\n    <ul>\n      {#each node.children as child}\n        <svelte:self id={child.id} />\n      {/each}\n    </ul>\n  </li>\n{/if}\n\n<style >ul {\n  display: flex;\n  flex-direction: column;\n  height: max-content;\n  list-style: none;\n  padding: 0;\n  padding-left: var(--tree-view-left-indent);\n  margin: 0;\n  width: 100%;\n}\n\nli {\n  align-items: baseline;\n  display: flex;\n  height: max-content;\n  line-height: var(--tree-view-line-height);\n  list-style: none;\n  width: 100%;\n}\n\nli + li {\n  margin-top: 0.25em;\n}\n\n.empty-block {\n  visibility: hidden;\n}\n\n.node-key {\n  color: var(--tree-view-base0D);\n  margin-right: var(--tree-view-key-margin-right);\n}\n.node-key.has-children {\n  cursor: pointer;\n}\n.node-key.p-left {\n  padding-left: 1.1em;\n}\n\n.node-value {\n  color: var(--tree-view-base0B);\n  margin-right: 0.5em;\n  word-break: break-all;\n}\n.node-value[data-type=number], .node-value[data-type=boolean] {\n  color: var(--tree-view-base09);\n}\n.node-value[data-type=null], .node-value[data-type=undefined] {\n  color: var(--tree-view-base08);\n}\n.node-value.expanded {\n  color: var(--tree-view-base03);\n}\n.node-value.has-children {\n  cursor: pointer;\n}\n\n.arrow-btn {\n  background: transparent;\n  border: 0;\n  color: var(--tree-view-base0D);\n  cursor: pointer;\n  margin-right: 0.7em;\n  padding: 0;\n  transition: all 150ms ease 0s;\n  transform: rotateZ(90deg);\n  transform-origin: 47% 43%;\n  position: relative;\n  line-height: 1.1em;\n  font-size: 0.75em;\n}\n.arrow-btn.collapsed {\n  transform: rotateZ(0deg);\n}\n\n.buttons {\n  display: flex;\n  flex-wrap: wrap;\n}\n\n.log-copy-button {\n  background: transparent;\n  border: 0;\n  color: var(--tree-view-base0D);\n  cursor: pointer;\n  margin: 0;\n  padding: 0 0.5em;\n}\n.log-copy-button:hover {\n  background: rgba(255, 162, 177, 0.4);\n  border-radius: 2px;\n  color: var(--tree-view-base07);\n}</style>\n","<script >var _a;\nimport { setContext, onMount } from 'svelte';\nimport { get } from 'svelte/store';\nimport { recomputeTree } from './tree-utils';\nimport { createPropsStore, createRootElementStore, createTreeStore } from './stores';\nimport TreeViewNode from './TreeViewNode.svelte';\nexport let data, theme = undefined, showLogButton = false, showCopyButton = false, valueComponent = undefined, recursionOpts = {}, valueFormatter = undefined;\nlet rootElement = null;\nconst defaultRecursionOpts = {\n    maxDepth: 16,\n    omitKeys: [],\n    stopCircularRecursion: false,\n    shouldExpandNode: () => false\n};\nlet props = {\n    showLogButton,\n    showCopyButton,\n    valueComponent,\n    recursionOpts: {\n        ...defaultRecursionOpts,\n        ...recursionOpts\n    },\n    valueFormatter\n};\n$: rootNode = treeStore.tree;\n$: {\n    // To keep things less messy all props are joined to one object _except_ the recursionOpts\n    // which is picked from the old props. This is to allow checking between the old and new recursionOpts\n    // in the recomputeTree.\n    props = {\n        showLogButton,\n        showCopyButton,\n        valueComponent,\n        valueFormatter,\n        recursionOpts: props.recursionOpts\n    };\n}\n$: {\n    // Combine the defaultProps with the possible new recursion opts\n    const newRecursionOpts = {\n        ...defaultRecursionOpts,\n        ...recursionOpts\n    };\n    // Compare the old shouldExpandNode option with the possible new shouldExpandNode\n    // to know whether to whole tree should be recomputed.\n    const recomputeExpandNode = ((_a = props === null || props === void 0 ? void 0 : props.recursionOpts) === null || _a === void 0 ? void 0 : _a.shouldExpandNode) !== newRecursionOpts.shouldExpandNode;\n    const oldTreeMap = get(treeStore.treeMap);\n    const { treeMap, tree, iteratedValues } = recomputeTree(data, oldTreeMap, newRecursionOpts, recomputeExpandNode);\n    treeStore.init(tree, treeMap, iteratedValues);\n    props.recursionOpts = newRecursionOpts;\n    propsStore.setProps(props);\n}\n$: {\n    if (theme && rootElement) {\n        let key;\n        for (key in theme) {\n            // This ridiculous thing is for TypeScript type inference. Yey..?\n            const value = theme[key];\n            if (rootElement && key.includes('base') && value) {\n                rootElement.style.setProperty(`--tree-view-${key}`, value);\n            }\n        }\n    }\n}\nconst propsStore = createPropsStore(props);\nconst rootElementStore = createRootElementStore();\nconst treeStore = createTreeStore(propsStore);\nsetContext('svelte-tree-view', {\n    propsStore,\n    rootElementStore,\n    treeStore\n});\nonMount(() => {\n    rootElementStore.set(rootElement);\n});\n</script>\n\n<ul class={`${$$props.class || ''} svelte-tree-view`} bind:this={rootElement}>\n  {#each $rootNode.children as child}\n    <TreeViewNode id={child.id} />\n  {/each}\n</ul>\n\n<style>\n  * {\n    box-sizing: border-box;\n  }\n  .svelte-tree-view {\n    --tree-view-font-family: 'Helvetica Neue', 'Calibri Light', Roboto, sans-serif;\n    --tree-view-font-size: 13px;\n    --tree-view-left-indent: 0.875em;\n    --tree-view-line-height: 1.1;\n    --tree-view-key-margin-right: 0.5em;\n  }\n  ul {\n    background: var(--tree-view-base00);\n    font-family: var(--tree-view-font-family);\n    font-size: var(--tree-view-font-size);\n    height: max-content;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: max-content;\n  }\n</style>\n","import { derived, get, writable } from 'svelte/store';\nexport const createPropsStore = (initialProps) => {\n    const props = writable(initialProps);\n    const recursionOpts = derived(props, p => p.recursionOpts);\n    return {\n        props,\n        recursionOpts,\n        setProps(newProps) {\n            props.set(newProps);\n        },\n        formatValue(val, node) {\n            const { valueFormatter } = get(props);\n            const customFormat = valueFormatter ? valueFormatter(val, node) : undefined;\n            if (customFormat) {\n                return customFormat;\n            }\n            switch (node.type) {\n                case 'array':\n                    return `${node.circularOfId ? 'circular' : ''} [] ${val.length} items`;\n                case 'object':\n                    return `${node.circularOfId ? 'circular' : ''} {} ${Object.keys(val).length} keys`;\n                case 'map':\n                case 'set':\n                    return `${node.circularOfId ? 'circular' : ''} () ${val.size} entries`;\n                case 'date':\n                    return `${val.toISOString()}`;\n                case 'string':\n                    return `\"${val}\"`;\n                case 'boolean':\n                    return val ? 'true' : 'false';\n                case 'symbol':\n                    return String(val);\n                default:\n                    return val;\n            }\n        }\n    };\n};\n","import { writable } from 'svelte/store';\nexport const createRootElementStore = () => {\n    const rootElementStore = writable(null);\n    return {\n        set: rootElementStore.set,\n        subscribe: rootElementStore.subscribe\n    };\n};\n","import { get, writable } from 'svelte/store';\nimport { createNode, recurseObjectProperties } from '../tree-utils';\nexport const createTreeStore = (propsStore) => {\n    const defaultRootNode = createNode(0, 'root', [], 0, null);\n    const tree = writable(defaultRootNode);\n    const treeMap = writable(new Map());\n    const iteratedValues = writable(new Map());\n    return {\n        tree,\n        treeMap,\n        defaultRootNode,\n        init(newTree, newTreeMap, iterated) {\n            if (newTree) {\n                tree.set(newTree);\n            }\n            else {\n                tree.set(defaultRootNode);\n            }\n            treeMap.set(newTreeMap);\n            iteratedValues.set(iterated);\n        },\n        getNode(id) {\n            return get(treeMap).get(id);\n        },\n        toggleCollapse(id) {\n            const node = get(treeMap).get(id);\n            if (!node) {\n                console.warn(`Attempted to collapse non-existent node: ${id}`);\n                return;\n            }\n            const updatedNode = { ...node, collapsed: !node.collapsed };\n            treeMap.update(m => new Map(m.set(node.id, updatedNode)));\n            const recursionOpts = get(propsStore.recursionOpts);\n            if (recursionOpts) {\n                this.expandNodeChildren(updatedNode, recursionOpts);\n            }\n        },\n        expandNodeChildren(node, recursionOpts) {\n            const parent = this.getNode((node === null || node === void 0 ? void 0 : node.parentId) || '') || null;\n            if (!parent) {\n                // Only root node has no parent and it should not be expandable\n                throw Error('No parent in expandNodeChildren for node: ' + node);\n            }\n            const newTreeMap = new Map(get(treeMap));\n            const oldTreeMap = get(treeMap);\n            const previouslyIterated = get(iteratedValues);\n            const nodeWithUpdatedChildren = recurseObjectProperties(node.index, node.key, node.value, node.depth, !node.collapsed, // Ensure that when uncollapsed the node's children are always recursed\n            parent, newTreeMap, oldTreeMap, previouslyIterated, false, // Never recompute shouldExpandNode since it may override the collapsing of this node\n            recursionOpts);\n            if (!nodeWithUpdatedChildren)\n                return;\n            parent.children = parent.children.map(c => c.id === nodeWithUpdatedChildren.id ? nodeWithUpdatedChildren : c);\n            newTreeMap.set(nodeWithUpdatedChildren.id, nodeWithUpdatedChildren);\n            newTreeMap.set(parent.id, parent);\n            treeMap.set(newTreeMap);\n            iteratedValues.set(previouslyIterated);\n        },\n        expandAllNodesToNode(id) {\n            function recurseNodeUpwards(updated, node) {\n                if (!node)\n                    return;\n                updated.set(node.id, { ...node, collapsed: false });\n                if (node.parentId) {\n                    recurseNodeUpwards(updated, updated.get(node.parentId));\n                }\n            }\n            const updated = new Map(get(treeMap));\n            recurseNodeUpwards(updated, updated.get(id));\n            treeMap.set(updated);\n        }\n    };\n};\n","<section class=\"split-view\">\n  <slot class=\"left-panel\" name=\"left\" />\n  <slot class=\"right-panel\" name=\"right\" />\n</section>\n\n<style lang=\"scss\">\n  section {\n    border-top: 1px solid rgba($color-red-light, 0.2);\n    color: $color-white;\n    display: flex;\n    height: calc(100% - var(--height-tabs-menu));\n    width: 100%;\n  }\n  :global(.split-view h2) {\n    color: $color-red-gray;\n    font-family: var(--font-sans);\n    font-size: var(--font-medium);\n    font-weight: 400;\n    letter-spacing: 1px;\n    margin: 0;\n    text-transform: uppercase;\n  }\n  :global(.split-view > .left-panel) {\n    display: flex;\n    flex-direction: column;\n    flex-grow: 1;\n    overflow: scroll;\n    padding: 1em;\n  }\n  :global(.split-view > .right-panel) {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    display: flex;\n    flex-direction: column;\n    flex-grow: 1;\n    overflow: scroll;\n    padding: 1em;\n  }\n  :global(.split-view .hidden) {\n    visibility: hidden;\n  }\n</style>\n","<script lang=\"ts\">\n  export let selected = false\n  let buttonProps = {\n    class: [$$restProps.class]\n  }\n</script>\n\n<button on:click on:mouseover on:mouseenter on:mouseleave on:focus {...buttonProps} class:selected\n  ><slot /></button\n>\n\n<style lang=\"scss\">\n  button {\n    background: transparent;\n    border: 0;\n    border-radius: 2px;\n    color: $color-gray-light;\n    cursor: pointer;\n    font-size: var(--font-small);\n    padding: 6px 10px;\n    text-transform: uppercase;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: $color-white;\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n    }\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n  import { latestEntry } from '$stores/stateHistory'\n  import { getActiveMarks } from './getActiveMarks'\n  import { createSelection, createFullSelection } from './selection'\n\n  import TreeView from 'svelte-tree-view'\n  import type { TreeNode } from 'svelte-tree-view'\n  import SplitView from '../SplitView.svelte'\n  import Button from '$components/Button.svelte'\n\n  const { view } = getContext('editor-view')\n  let doc = view.state.doc.toJSON()\n  let selection = createSelection(view.state.selection)\n  let currentState = view.state\n  let activeMarks: string[] = []\n  let nodeSize = view.state.doc.nodeSize\n  let childCount = view.state.doc.childCount\n  let expandedSelection = false\n\n  latestEntry.subscribe(e => {\n    if (!e) return\n    const { state } = e\n    currentState = state\n    doc = state.doc.toJSON()\n    selection = expandedSelection\n      ? createFullSelection(state.selection)\n      : createSelection(state.selection)\n    activeMarks = getActiveMarks(state)\n    nodeSize = state.doc.nodeSize\n    childCount = state.doc.childCount\n  })\n\n  function handleClickLogDoc() {\n    console.log(doc)\n    window._doc = doc\n  }\n  function handleExpandSelection() {\n    expandedSelection = !expandedSelection\n    if (expandedSelection) {\n      selection = createFullSelection(currentState.selection)\n    } else {\n      selection = createSelection(currentState.selection)\n    }\n  }\n  function formatDocNodeValue(val: any, n: TreeNode) {\n    if (n.type === 'object' && val.type) {\n      return `{} ${val.type}`\n    }\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <div class=\"top-row\">\n      <h2>Current doc</h2>\n      <Button on:click={handleClickLogDoc}>log</Button>\n    </div>\n    <TreeView\n      class=\"tree-view\"\n      data={doc}\n      showLogButton\n      showCopyButton\n      valueFormatter={formatDocNodeValue}\n    />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    <div class=\"top-row\">\n      <h2>Selection</h2>\n      <Button class=\"selection-btn\" on:click={handleExpandSelection}\n        ><span class=\"caret-icon\" class:expanded={expandedSelection} /></Button\n      >\n    </div>\n    <TreeView class=\"tree-view\" data={selection} />\n    <div>\n      <h2>Active marks</h2>\n      {#if activeMarks.length === 0}\n        <div class=\"no-marks\">No active marks</div>\n      {:else}\n        <TreeView class=\"tree-view\" data={activeMarks} />\n      {/if}\n    </div>\n    <div>\n      <h2>Document stats</h2>\n      <TreeView\n        class=\"tree-view\"\n        data={{\n          nodeSize,\n          childCount\n        }}\n      />\n    </div>\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .left-panel {\n    overflow: scroll;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    flex-grow: 0;\n    min-width: 200px;\n    width: 200px;\n  }\n  :global(.split-view .selection-btn) {\n    height: 24px;\n    width: 35px;\n  }\n  .caret-icon::before {\n    content: '';\n  }\n  .caret-icon.expanded::before {\n    content: '';\n  }\n  .no-marks {\n    color: $color-blue-light;\n    margin: 0.5em 0 1em 1em;\n  }\n  :global(.split-view .tree-view) {\n    margin: 0.5em 0 1em 0;\n  }\n</style>\n","import { EditorState } from 'prosemirror-state'\n\n// From https://github.com/PierBover/prosemirror-cookbook\nexport function getActiveMarks(state: EditorState): string[] {\n  if (state.selection.empty) {\n    const $from = state.selection.$from\n    const storedMarks = state.storedMarks\n\n    // Return either the stored marks, or the marks at the cursor position.\n    // Stored marks are the marks that are going to be applied to the next input\n    // if you dispatched a mark toggle with an empty cursor.\n    if (storedMarks) {\n      return storedMarks.map(mark => mark.type.name)\n    } else {\n      return $from.marks().map(mark => mark.type.name)\n    }\n  } else {\n    const $head = state.selection.$head\n    const $anchor = state.selection.$anchor\n\n    // We're using a Set to not get duplicate values\n    const activeMarks = new Set<string>()\n\n    // Here we're getting the marks at the head and anchor of the selection\n    $head.marks().forEach(mark => activeMarks.add(mark.type.name))\n    $anchor.marks().forEach(mark => activeMarks.add(mark.type.name))\n\n    return Array.from(activeMarks)\n  }\n}\n","import type { Delta } from 'jsondiffpatch'\nimport type { TreeNode, ValueType } from 'svelte-tree-view'\n\n// function postprocessValue(value: any) {\n//   if (value && value._t === 'a') {\n//     const res: { [key: string]: string | string[] } = {}\n//     for (const key in value) {\n//       if (key !== '_t') {\n//         if (key[0] === '_' && !value[key.substr(1)]) {\n//           res[key.substr(1)] = value[key]\n//         } else if (value['_' + key]) {\n//           res[key] = [value['_' + key][0], value[key][0]]\n//         } else if (!value['_' + key] && key[0] !== '_') {\n//           res[key] = value[key]\n//         }\n//       }\n//     }\n//     return res\n//   }\n//   return value\n// }\n\nexport function mapSelectionDeltaChildren(\n  _val: any,\n  type: ValueType,\n  _parent: TreeNode\n): [string, any][] | undefined {\n  if (type !== 'array') return\n  return []\n}\n\n/**\n * Magic function to transform jsondiffpatch array deltas\n * https://github.com/benjamine/jsondiffpatch/blob/master/docs/deltas.md\n * https://benjamine.github.io/jsondiffpatch/demo/index.html\n */\nexport function mapDocDeltaChildren(delta: Delta, type: ValueType) {\n  // So due to the way the tree-view works, it will automatically map the children of an array\n  // to their own nodes. For diff deltas, however, we want to omit those children and just show\n  // a value wrapped with <span> to show either deleted or inserted content\n  if (type === 'array' && delta[1] === 0 && delta[2] === 0) {\n    // Remove operation is defined by two 0s in its delta [{ <deleted> }, 0, 0]\n    return []\n    // } else if (type === 'array' && typeof delta[0] === 'string' && typeof delta[1] === 'number' && delta[2] === 3) {\n    // Move operation is almost the same as remove, except its value is empty and the second number\n    // points to the moved index eg [\"\", 6, 3] AND the third value is always '3'\n    // But since these seem to never occur (and they weren't handled in the previous version) we are not doing anything\n    // with them for now.\n  } else if (type === 'array' && typeof delta[0] === 'string' && delta[1] === 0 && delta[2] === 2) {\n    // If a diff between two strings gets too long, a text diff algorithm is used which produces an array\n    // with unidiff as the first value, 0 as the second and 2 as third.\n    // Eg [\"@@ -1,4 +1,9 @@\\n-text\\n+paragraph\\n\", 0, 2]\n    return []\n  } else if (type === 'array' && delta.length === 1 && typeof delta[0] === 'object') {\n    // Insert operations do not have indexes (it's already indexed in the array) and carry\n    // only an object payload eg [{ <inserted> }]\n    return []\n  }\n\n  // The main delta objects are objects denoted by key '_t' with 'a' value which we shall omit.\n  // DiffValue component handles the text diffs otherwise.\n  if (type !== 'object' || delta._t !== 'a') return\n\n  // We shall remap the values to omit '_t' and remove underscores from the keys\n  const transformed: [string, any][] = []\n  for (const key in delta) {\n    if (key === '_t') continue\n    // Remove or move operation is indicated by an underscore before the index eg '_2'\n    if (key.charAt(0) === '_') {\n      transformed.push([key.substr(1), delta[key]])\n    } else {\n      transformed.push([key, delta[key]])\n    }\n  }\n  return transformed\n}\n","<script lang=\"ts\">\n  import { createEventDispatcher } from 'svelte'\n  import type { HistoryEntry } from '$typings/history'\n\n  export let listItems: {\n      isGroup: boolean\n      topEntry: HistoryEntry | undefined\n      entries: (HistoryEntry | undefined)[]\n      expanded: boolean\n    }[] = [],\n    selectedId: string\n\n  const dispatchClick = createEventDispatcher<{\n    'click-item': { id: string | undefined; groupIdx: number; wasTopNode: boolean }\n  }>()\n  const dispatchDblClick = createEventDispatcher<{ 'dblclick-item': { id?: string } }>()\n</script>\n\n<ul>\n  {#each listItems as group, groupIdx}\n    <li class:selected={!group.expanded && selectedId === group?.topEntry?.id}>\n      <button\n        class:is-group={group.isGroup}\n        on:click={() =>\n          dispatchClick('click-item', { id: group?.topEntry?.id, groupIdx, wasTopNode: true })}\n        on:dblclick={() => dispatchDblClick('dblclick-item', { id: group?.topEntry?.id })}\n      >\n        <span>\n          {group?.topEntry?.timeStr}\n          {#if group.isGroup}\n            [{group.entries.length}]\n          {/if}\n        </span>\n        {#if group.isGroup && group.entries.length > 1}\n          <span class=\"caret-icon\" class:expanded={group.expanded} />\n        {/if}\n      </button>\n    </li>\n    {#if group.isGroup && group.expanded}\n      {#each group.entries as subEntry}\n        <li class:selected={selectedId === subEntry?.id}>\n          <button\n            class=\"p-left\"\n            on:click={() =>\n              dispatchClick('click-item', { id: subEntry?.id, groupIdx, wasTopNode: false })}\n          >\n            {subEntry?.timeStr}\n          </button>\n        </li>\n      {/each}\n    {/if}\n  {/each}\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    color: $color-white;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n    width: 100%;\n  }\n  li {\n    transition: background 0.1s;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: $color-white;\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n    }\n  }\n  li + li {\n    border-top: 1px solid $color-purple;\n  }\n  button {\n    background: transparent;\n    border: 0;\n    color: $color-gray-light;\n    cursor: pointer;\n    display: flex;\n    font-family: monospace;\n    font-size: var(--font-small);\n    height: 100%;\n    justify-content: space-between;\n    padding: 6px 18px;\n    text-transform: uppercase;\n    width: 100%;\n\n    &.p-left {\n      margin-left: 1em;\n    }\n  }\n  .caret-icon::before {\n    content: '';\n  }\n  .caret-icon.expanded::before {\n    content: '';\n  }\n</style>\n","<script lang=\"ts\">\n  import type { TreeNode } from 'svelte-tree-view'\n\n  export let value: any, node: TreeNode, defaultFormatter: (val: any) => string\n\n  $: nodeVal = node.value\n\n  function replaceSpacesWithNonBreakingSpace(value: string) {\n    return value.replace(/\\s/gm, '')\n  }\n  function parseTextDiff(textDiff: string) {\n    const diffByLines = textDiff.split(/\\n/gm).slice(1)\n    return diffByLines.map(line => {\n      const type = line.startsWith('-') ? 'delete' : line.startsWith('+') ? 'add' : 'raw'\n\n      return { [type]: replaceSpacesWithNonBreakingSpace(line.substr(1)) }\n    })\n  }\n  function stringifyAndShrink(v: any) {\n    if (v === null) {\n      return 'null'\n    }\n    const str = JSON.stringify(v)\n    if (typeof str === 'undefined') {\n      return 'undefined'\n    }\n    return str.length > 22 ? `${str.substr(0, 15)}${str.substr(-5)}` : str\n  }\n\n  function getValueString(raw: any) {\n    if (typeof raw === 'string') {\n      return raw\n    }\n    return stringifyAndShrink(raw)\n  }\n</script>\n\n{#if Array.isArray(nodeVal)}\n  <!-- The why https://github.com/benjamine/jsondiffpatch/blob/master/docs/deltas.md -->\n  {#if nodeVal.length === 1}\n    <span class=\"added\">{getValueString(nodeVal[0])}</span>\n  {:else if nodeVal.length === 2}\n    <span class=\"updated\">\n      <span class=\"deleted\">{getValueString(nodeVal[0])}</span>\n      <span class=\"arrow\"> =&gt;</span>\n      <span class=\"added\">{getValueString(nodeVal[1])}</span>\n    </span>\n  {:else if nodeVal.length === 3 && nodeVal[1] === 0 && nodeVal[2] === 0}\n    <span class=\"deleted\">{getValueString(nodeVal[0])}</span>\n  {:else if nodeVal.length === 3 && nodeVal[2] === 2}\n    <span class=\"updated\">\n      {#each parseTextDiff(nodeVal[0]) as item}\n        {#if item.delete}\n          <span class=\"deleted\">{item.delete}</span>\n        {:else if item.add}\n          <span class=\"added\">{item.add}</span>\n        {:else}\n          <span>{item.raw}</span>\n        {/if}\n      {/each}\n    </span>\n  {/if}\n{:else}\n  {defaultFormatter(nodeVal)}\n{/if}\n\n<style lang=\"scss\">\n  .added {\n    display: inline-block;\n    background: $color-green-light;\n    border-radius: 1px;\n    color: $color-green;\n    padding: 1px 2px;\n    text-indent: 0;\n    min-height: 1ex;\n  }\n  .deleted {\n    display: inline-block;\n    background: $color-red;\n    border-radius: 1px;\n    color: $color-gray-light;\n    padding: 1px 2px;\n    text-decoration: line-through;\n    text-indent: 0;\n    min-height: 1ex;\n  }\n  .updated {\n    word-break: break-all;\n  }\n  .updated .added {\n    background: $color-yellow;\n  }\n  .arrow {\n    color: $color-green-light;\n  }\n</style>\n","<script lang=\"ts\">\n  import { stateHistory, shownHistoryGroups, latestEntry } from '$stores/stateHistory'\n  import type { HistoryEntry, HistoryGroup } from '$typings/history'\n  import { mapDocDeltaChildren, mapSelectionDeltaChildren } from './mapDeltas'\n  import TreeView from 'svelte-tree-view'\n\n  import SplitView from '../SplitView.svelte'\n  import HistoryList from './HistoryList.svelte'\n  import DiffValue from './DiffValue.svelte'\n  import Button from '$components/Button.svelte'\n\n  import { getContext } from '$context'\n\n  let selectedEntry: HistoryEntry | undefined = undefined,\n    showTr = false\n\n  const { replaceEditorContent } = getContext('editor-view')\n\n  let expandTrTreeView = false\n  let transactionRecursionOpts = {\n    maxDepth: 12,\n    stopCircularRecursion: true,\n    omitKeys: ['schema'],\n    shouldExpandNode: () => expandTrTreeView\n  }\n  $: listItems = $shownHistoryGroups.map((g: HistoryGroup) => ({\n    isGroup: g.isGroup,\n    topEntry: $stateHistory.get(g.topEntryId),\n    entries: g.entryIds.map(id => $stateHistory.get(id)),\n    expanded: g.expanded\n  }))\n\n  latestEntry.subscribe(v => {\n    if (v) selectedEntry = v\n  })\n\n  function toggleShowTr() {\n    showTr = !showTr\n  }\n  function handleLogTr() {\n    console.info('%c [prosemirror-dev-toolkit]: Property added to window._tr', 'color: #b8e248')\n    console.log(selectedEntry?.tr)\n    window._tr = selectedEntry?.tr\n  }\n  /**\n   * Handles the clicks of the history entries.\n   *\n   * Sets the clicked entry as the selectedEntry but in the case of topNode, meaning\n   * in a selection group (shown with [x] number) the entry has a sublist of entries\n   * where the previous is duplicated as the first entry. Therefore on expanding the group\n   * selecting the first sub-entry, otherwise collapsing but still keeping the topNode selected.\n   * Kinda confusing but eh.\n   */\n  function handleEntrySelect(\n    e: CustomEvent<{ id: string | undefined; groupIdx: number; wasTopNode: boolean }>\n  ) {\n    const { id = '', groupIdx, wasTopNode } = e.detail\n    selectedEntry = $stateHistory.get(id)\n    if (!selectedEntry) return\n    const group = listItems[groupIdx]\n    if (group.isGroup && group.entries.length > 1 && wasTopNode) {\n      shownHistoryGroups.update(val =>\n        val.map((g, idx) => (idx !== groupIdx ? g : { ...g, expanded: !g.expanded }))\n      )\n    }\n  }\n  function handleEntryDblClick(e: CustomEvent<{ id?: string }>) {\n    selectedEntry = $stateHistory.get(e.detail.id || '')\n    selectedEntry && replaceEditorContent(selectedEntry.state)\n  }\n  function handleToggleExpandTrTreeView() {\n    expandTrTreeView = !expandTrTreeView\n    transactionRecursionOpts = {\n      ...transactionRecursionOpts,\n      shouldExpandNode: () => expandTrTreeView\n    }\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <HistoryList\n      {listItems}\n      selectedId={selectedEntry?.id || ''}\n      on:click-item={handleEntrySelect}\n      on:dblclick-item={handleEntryDblClick}\n    />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    {#if selectedEntry}\n      <div>\n        {#if selectedEntry.contentDiff}\n          <div class=\"entry-row\">\n            <div class=\"title-container\">\n              <h2>Doc diff</h2>\n              <Button class=\"hidden\">log</Button>\n            </div>\n            <TreeView\n              class=\"tree-view\"\n              data={selectedEntry.contentDiff}\n              showLogButton\n              showCopyButton\n              valueComponent={DiffValue}\n              recursionOpts={{\n                maxDepth: 12,\n                mapChildren: mapDocDeltaChildren,\n                shouldExpandNode: () => true\n              }}\n            />\n          </div>\n        {/if}\n        {#if selectedEntry.selectionDiff}\n          <div class=\"entry-row\">\n            <div class=\"title-container\">\n              <h2>Selection diff</h2>\n              <Button class=\"hidden\">log</Button>\n            </div>\n            <TreeView\n              class=\"tree-view\"\n              data={selectedEntry.selectionDiff}\n              valueComponent={DiffValue}\n              recursionOpts={{\n                mapChildren: mapSelectionDeltaChildren,\n                shouldExpandNode: () => true\n              }}\n            />\n          </div>\n        {/if}\n        {#if selectedEntry.selectionHtml.length > 0}\n          <div class=\"entry-row\">\n            <div class=\"title-container\">\n              <h2>Selection content</h2>\n              <Button class=\"hidden\">log</Button>\n            </div>\n            <pre class=\"selection-html\"><code>{@html selectedEntry.selectionHtml}</code></pre>\n          </div>\n        {/if}\n        <div class=\"entry-row\">\n          <div class=\"title-container\">\n            <h2>Transaction</h2>\n            <div>\n              {#if showTr}\n                <Button on:click={handleToggleExpandTrTreeView}>\n                  {expandTrTreeView ? 'collapse' : 'expand'}\n                </Button>\n                <Button on:click={handleLogTr}>log</Button>\n              {/if}\n              <Button on:click={toggleShowTr}>\n                {showTr ? 'hide' : 'show'}\n              </Button>\n            </div>\n          </div>\n          {#if showTr}\n            <TreeView\n              class=\"tree-view\"\n              data={selectedEntry.tr}\n              showLogButton\n              showCopyButton\n              recursionOpts={transactionRecursionOpts}\n            />\n          {/if}\n        </div>\n      </div>\n    {:else}\n      <div class=\"equal-diff\">Docs are equal.</div>\n    {/if}\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  :global(.hidden) {\n    display: none;\n    visibility: hidden;\n  }\n  .left-panel {\n    flex-grow: 0;\n    padding: 0;\n    min-width: 190px;\n    width: 190px;\n  }\n  .title-container {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .entry-row + .entry-row {\n    margin-top: 1em;\n  }\n  .selection-html {\n    font-weight: 100;\n    margin: 0.5em 0 0 0;\n    padding: 0;\n  }\n  .equal-diff {\n    align-items: center;\n    color: $color-red-light;\n    display: flex;\n    font-size: 14px;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n  }\n</style>\n","<script lang=\"ts\">\n  export let listItems: { key: string; value: string; empty?: boolean }[] = [],\n    selectedKey: string | undefined,\n    onSelect: (item: { key: string; value: string }) => void\n</script>\n\n<ul>\n  {#each listItems as item}\n    <li>\n      <button\n        class:selected={selectedKey === item.key}\n        class:empty={item.empty}\n        on:click={() => onSelect(item)}>{item.value}</button\n      >\n    </li>\n  {/each}\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    color: $color-white;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n    width: 100%;\n  }\n  li + li {\n    border-top: 1px solid $color-purple;\n  }\n  button {\n    background: transparent;\n    border: 0;\n    color: $color-gray-light;\n    cursor: pointer;\n    display: flex;\n    font-family: monospace;\n    font-size: var(--font-small);\n    font-weight: 100;\n    height: 100%;\n    padding: 6px 18px;\n    text-transform: uppercase;\n    width: 100%;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: $color-white;\n      &.empty {\n        background: $color-purple-dark;\n      }\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n      &.empty {\n        background: $color-purple-dark;\n      }\n    }\n    &.empty {\n      color: $color-dim-text;\n    }\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n  import type { EditorState } from 'prosemirror-state'\n  import { latestEntry } from '$stores/stateHistory'\n\n  import SplitView from './SplitView.svelte'\n  import TreeView from 'svelte-tree-view'\n  import List from './List.svelte'\n  import Button from '$components/Button.svelte'\n\n  import type { Plugin } from '$typings/pm'\n\n  const { view } = getContext('editor-view')\n  let expandPluginState = false\n  let recursionOpts = {\n    maxDepth: 10,\n    stopCircularRecursion: true,\n    shouldExpandNode: () => expandPluginState\n  }\n  let editorState: EditorState = view.state\n  let plugins = editorState.plugins as Plugin[]\n  let selectedPlugin = plugins[0] as Plugin | undefined\n  // I don't know how, but I've found in one editor plugin did not have getState method\n  $: pluginState = selectedPlugin?.getState\n    ? selectedPlugin.getState(editorState)\n    : (undefined as any)\n  $: listItems = plugins.map((p: Plugin) => ({\n    key: p.key,\n    value: p.key.toUpperCase(),\n    empty: !(p.getState && p.getState(editorState))\n  }))\n\n  latestEntry.subscribe(e => {\n    if (!e) return\n    editorState = e.state\n    plugins = editorState.plugins as Plugin[]\n    selectedPlugin = plugins.find(p => p.key === selectedPlugin?.key) as Plugin\n  })\n\n  function handlePluginSelect(item: { key: string; value: string }) {\n    selectedPlugin = plugins.find(p => p.key === item.key) as Plugin\n  }\n  function handleToggleExpand() {\n    expandPluginState = !expandPluginState\n    recursionOpts = { ...recursionOpts, shouldExpandNode: () => expandPluginState }\n  }\n  function handleLogState() {\n    window._plugin = [selectedPlugin, pluginState]\n    console.info('%c [prosemirror-dev-toolkit]: Property added to window._plugin', 'color: #b8e248')\n    console.log(selectedPlugin)\n    console.log(pluginState)\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <List {listItems} selectedKey={selectedPlugin?.key} onSelect={handlePluginSelect} />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    {#if pluginState}\n      <div class=\"top-row\">\n        <h2>Plugin state</h2>\n        <div>\n          <Button on:click={handleToggleExpand}>\n            {expandPluginState ? 'collapse' : 'expand'}\n          </Button>\n          <Button on:click={handleLogState}>log</Button>\n        </div>\n      </div>\n    {/if}\n    {#if pluginState}\n      <TreeView data={pluginState} showLogButton showCopyButton {recursionOpts} />\n    {:else}\n      <div class=\"empty-state\">Plugin has no state</div>\n    {/if}\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n    margin-bottom: 0.5em;\n  }\n  .left-panel {\n    flex-grow: 0;\n    overflow: scroll;\n    padding: 0;\n    min-width: 190px;\n    width: 190px;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n  }\n  .empty-state {\n    align-items: center;\n    color: $color-red-light;\n    display: flex;\n    font-size: 14px;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n\n  import TreeView from 'svelte-tree-view'\n  import SplitView from './SplitView.svelte'\n  import Button from '$components/Button.svelte'\n\n  const { view } = getContext('editor-view')\n\n  let nodes = view.state.schema.nodes\n  let marks = view.state.schema.marks\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <div class=\"top-row\">\n      <h2>Nodes</h2>\n      <Button class=\"hidden\">log</Button>\n    </div>\n    <TreeView\n      class=\"tree-view\"\n      data={nodes}\n      showLogButton\n      showCopyButton\n      recursionOpts={{\n        stopCircularRecursion: true\n      }}\n    />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    <div class=\"top-row\">\n      <h2>Marks</h2>\n      <Button class=\"hidden\">log</Button>\n    </div>\n    <TreeView\n      class=\"tree-view\"\n      data={marks}\n      showLogButton\n      showCopyButton\n      recursionOpts={{\n        stopCircularRecursion: true\n      }}\n    />\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  :global(.hidden) {\n    display: none;\n    visibility: hidden;\n  }\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .left-panel {\n    overflow: scroll;\n    padding: 1em;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    overflow: scroll;\n    padding: 1em;\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n  import type { Node as PMNode } from 'prosemirror-model'\n  import type { Fragment } from '$typings/pm'\n\n  const { colors, handleNodeClick } = getContext('doc-view')\n\n  export let node: PMNode,\n    startPos: number,\n    isRoot = false\n\n  $: fragment = node.content as Fragment\n  $: color = colors[node.type.name]\n  $: name =\n    node.isText && node.marks.length > 0\n      ? `${node.type.name} - [${node.marks.map(m => m.type.name).join(', ')}]`\n      : node.type.name\n\n  $: startPositions = Array(node.childCount)\n    .fill(undefined)\n    .reduce((acc, _, idx) => {\n      if (idx === 0) {\n        return [isRoot ? 0 : startPos + 1]\n      }\n      let prev = acc[idx - 1]\n      let cur = node.child(idx - 1)\n      return [...acc, prev + cur.nodeSize]\n    }, [])\n\n  $: endPos = startPos + node.nodeSize\n  $: inlineChildren = fragment.content.every(n => n.isInline)\n\n  function handleNameClick() {\n    handleNodeClick(node)\n  }\n</script>\n\n<li class={`${$$props.class || ''} doc-node`} class:root={isRoot}>\n  <div class=\"doc-node-body\" style={`background: ${color}`}>\n    <div class=\"number-box\">{startPos}</div>\n    <button class:selected={false} aria-label=\"Show node info button\" on:click={handleNameClick}\n      >{name}</button\n    >\n    <div class=\"number-box\">{endPos}</div>\n  </div>\n  <ul class:inline-children={inlineChildren}>\n    {#each fragment.content as child, i}\n      <svelte:self node={child} startPos={startPositions[i]} />\n    {/each}\n  </ul>\n</li>\n\n<style lang=\"scss\">\n  .doc-node {\n    border-left: 1px solid $color-blue-bg;\n    border-right: 1px solid $color-blue-bg;\n    display: flex;\n    flex-direction: column;\n    padding: 0 12px;\n    &.root {\n      border: 0;\n      padding: 0;\n    }\n  }\n  .doc-node-body {\n    background: $color-blue-bg;\n    color: $color-black;\n    display: flex;\n    font-size: 13px;\n    margin-top: 3px;\n  }\n  .number-box {\n    padding: 3px 6px;\n    background: rgba($color-white, 0.3);\n  }\n  button {\n    background: transparent;\n    border: 0;\n    color: $color-black;\n    cursor: pointer;\n    display: flex;\n    height: 100%;\n    padding: 3px 9px;\n    white-space: pre;\n    width: 100%;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: $color-white;\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n    }\n  }\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n  .inline-children {\n    border-left: 1px solid $color-purple;\n    border-right: 1px solid $color-purple;\n    display: flex;\n    flex-wrap: wrap;\n    padding: 0 12px;\n    /* TODO this hurts my soul */\n    & > :global(.doc-node) {\n      flex-grow: 1;\n      padding: 0;\n    }\n  }\n</style>\n","import { Schema } from 'prosemirror-model'\n\nconst nodeColors = <const>[\n  '#EA7C7F', // red\n  '#67B0C6', // cyan 400\n  '#94BB7F', // green\n  '#CA9EDB', // deep purple\n  '#DCDC5D', // lime\n  '#B9CC7C', // light green\n  '#DD97D8', // purple\n  '#FFB761', // orange\n  '#4D8FD1', // light blue\n  '#F36E98', // pink\n  '#E45F44', // deep orange\n  '#A6A4AE', // blue grey\n  '#FCC047', // yellow\n  '#FFC129', // amber\n  '#D3929C', // can can\n  '#4CBCD4', // cyan\n  '#8D7BC0' // indigo\n]\n\nexport function calculateSafeIndex(index: number, total: number) {\n  const quotient = index / total\n  return Math.round(total * (quotient - Math.floor(quotient)))\n}\n\nexport function buildColors(schema: Schema) {\n  return Object.keys(schema.nodes).reduce((acc, node, index) => {\n    const safeIndex =\n      index >= nodeColors.length ? calculateSafeIndex(index, nodeColors.length) : index\n\n    acc[node] = nodeColors[safeIndex]\n    return acc\n  }, {} as { [key: string]: typeof nodeColors[number] })\n}\n","<script lang=\"ts\">\n  import { setContext } from '$context'\n  import type { Node as PMNode, Schema } from 'prosemirror-model'\n\n  import DocNode from './DocNode.svelte'\n  import { buildColors } from './colors'\n\n  export let doc: PMNode,\n    schema: Schema,\n    selected = { type: '', start: 0, end: 0 },\n    handleNodeSelect: (n: PMNode) => void\n\n  setContext('doc-view', {\n    selected,\n    colors: buildColors(schema),\n    handleNodeClick: handleNodeSelect\n  })\n</script>\n\n<ul>\n  <DocNode class={$$props.class} node={doc} startPos={0} depth={0} isRoot />\n</ul>\n\n<style>\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n</style>\n","<script lang=\"ts\">\n  import type { Node as PMNode, Schema } from 'prosemirror-model'\n  import { getContext } from '$context'\n  import { latestEntry } from '$stores/stateHistory'\n\n  import TreeView from 'svelte-tree-view'\n  import SplitView from '../SplitView.svelte'\n  import DocView from './DocView.svelte'\n  import Button from '$components/Button.svelte'\n\n  const { view } = getContext('editor-view')\n  let doc: PMNode = view.state.doc\n  let selectedNode = view.state.doc\n  $: jsonNode = selectedNode.toJSON()\n  let schema: Schema = view.state.schema\n  let timer: ReturnType<typeof setTimeout>\n\n  latestEntry.subscribe(e => {\n    if (!e) return\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      doc = e.state.doc\n      selectedNode = doc\n    }, 100)\n  })\n\n  function handleNodeSelect(n: PMNode) {\n    selectedNode = n\n  }\n  function handleClickLogNode() {\n    console.log(selectedNode)\n    window._node = selectedNode\n    console.info('%c [prosemirror-dev-toolkit]: Property added to window._node', 'color: #b8e248')\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <div class=\"top-row\">\n      <h2>Current doc</h2>\n      <Button class=\"hidden\">log</Button>\n    </div>\n    <DocView class=\"m-top\" {doc} {schema} {handleNodeSelect} />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    <div class=\"top-row\">\n      <h2>Node info</h2>\n      <Button on:click={handleClickLogNode}>log</Button>\n    </div>\n    <TreeView class=\"m-top\" data={jsonNode} />\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  :global(.hidden) {\n    display: none;\n    visibility: hidden;\n  }\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    flex-grow: 0;\n    min-width: 220px;\n    width: 220px;\n  }\n  :global(.split-view .m-top) {\n    margin-top: 0.5em;\n  }\n</style>\n","<script lang=\"ts\">\n  import type { Snapshot } from '$typings/snapshots'\n\n  export let snapshots: Snapshot[] = [],\n    selectedSnapshot: Snapshot | undefined = undefined,\n    onUpdate: (snap: Snapshot) => void,\n    onView: (snap?: Snapshot) => void,\n    onRestore: (snap: Snapshot) => void,\n    onExport: (snap: Snapshot) => void,\n    onDelete: (snap: Snapshot) => void\n\n  let editedSnap: Snapshot | undefined\n  let deleteSnap: Snapshot | undefined\n  let timer: number | undefined\n\n  const debounceUpdate = () => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      onUpdate(editedSnap as Snapshot)\n    }, 150)\n  }\n\n  function handleSnapDoubleclick(snap: Snapshot) {\n    editedSnap = snap\n    deleteSnap = undefined\n  }\n  function handleNameChange(evt: any) {\n    if (editedSnap) {\n      editedSnap.name = evt.target.value\n      debounceUpdate()\n    }\n  }\n  function handleNameKeyPress(evt: any) {\n    if (evt.key === 'Enter' && editedSnap) {\n      onUpdate(editedSnap)\n      clearTimeout(timer)\n      editedSnap = undefined\n      deleteSnap = undefined\n    }\n  }\n  function handleClickView(snap: Snapshot) {\n    if (selectedSnapshot?.timestamp === snap.timestamp) {\n      onView()\n    } else {\n      onView(snap)\n    }\n    deleteSnap = undefined\n  }\n  function handleRestoreClick(snap: Snapshot) {\n    onRestore(snap)\n    deleteSnap = undefined\n  }\n  function handleExportClick(snap: Snapshot) {\n    onExport(snap)\n    deleteSnap = undefined\n  }\n  function handleClickDelete(snap: Snapshot) {\n    if (!deleteSnap || deleteSnap.timestamp !== snap.timestamp) {\n      deleteSnap = snap\n    } else {\n      onDelete(snap)\n      deleteSnap = undefined\n    }\n  }\n</script>\n\n<ul>\n  {#each snapshots as snap}\n    <li>\n      {#if editedSnap && editedSnap.timestamp === snap.timestamp}\n        <input\n          value={editedSnap.name}\n          on:input={handleNameChange}\n          on:keypress={handleNameKeyPress}\n        />\n      {:else}\n        <button\n          class=\"unstyled-btn\"\n          aria-label=\"Edit snapshot name button\"\n          on:dblclick={() => handleSnapDoubleclick(snap)}>{snap.name}</button\n        >\n      {/if}\n      <button class=\"snapshot-btn ml-2\" on:click={() => handleClickView(snap)}>\n        {#if selectedSnapshot?.timestamp === snap.timestamp}\n          Hide\n        {:else}\n          Show\n        {/if}\n      </button>\n      <button class=\"snapshot-btn\" on:click={() => handleRestoreClick(snap)}>Restore</button>\n      <button class=\"snapshot-btn\" on:click={() => handleExportClick(snap)}>Export</button>\n      <button class=\"snapshot-btn\" on:click={() => handleClickDelete(snap)}>\n        {#if deleteSnap?.timestamp === snap.timestamp}\n          Confirm Delete\n        {:else}\n          Delete\n        {/if}\n      </button>\n    </li>\n  {/each}\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    color: $color-white;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n    width: 100%;\n  }\n  li + li {\n    border-top: 1px solid $color-purple;\n  }\n  li {\n    align-items: center;\n    display: flex;\n    font-family: monospace;\n    padding: 6px 18px;\n  }\n  input {\n    background: transparent;\n    border: 0;\n    color: $color-white;\n    height: 100%;\n    margin: 0;\n    padding: 2px;\n    width: 100%;\n  }\n  .unstyled-btn {\n    background: transparent;\n    border: 0;\n    color: $color-white;\n    cursor: pointer;\n    display: block;\n    font-family: monospace;\n    margin: 0;\n    padding: 0;\n    text-align: start;\n    width: 100%;\n  }\n  .snapshot-btn {\n    background: transparent;\n    border: 0;\n    border-radius: 3px;\n    color: $color-gray-light;\n    cursor: pointer;\n    display: flex;\n    font-size: 11px;\n    padding: 6px 18px;\n    text-transform: uppercase;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: $color-white;\n    }\n  }\n  .ml-2 {\n    margin-left: 1rem;\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n\n  import SplitView from '$tabs/SplitView.svelte'\n  import SnapshotsList from './SnapshotsList.svelte'\n  import {\n    snapshots,\n    selectedSnapshot,\n    updateSnapshot,\n    toggleViewSnapshot,\n    restoreSnapshot,\n    exportSnapshot,\n    deleteSnapshot\n  } from '$stores/snapshots'\n  import { resetHistory } from '$stores/stateHistory'\n  import type { Snapshot } from '$typings/snapshots'\n\n  const { view } = getContext('editor-view')\n\n  function handleRestoreSnapshot(snapshot: Snapshot) {\n    restoreSnapshot(view, snapshot)\n    resetHistory()\n  }\n</script>\n\n<SplitView>\n  <div slot=\"right\" class=\"right-panel\">\n    {#if $snapshots.length === 0}\n      <div class=\"no-snapshots\">Save snapshots by clicking \"Save snapshot\" button.</div>\n    {:else}\n      <SnapshotsList\n        snapshots={$snapshots}\n        selectedSnapshot={$selectedSnapshot}\n        onUpdate={updateSnapshot}\n        onView={snap => toggleViewSnapshot(view, snap)}\n        onRestore={handleRestoreSnapshot}\n        onExport={exportSnapshot}\n        onDelete={deleteSnapshot}\n      />\n    {/if}\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .right-panel {\n    padding: 0;\n  }\n  .no-snapshots {\n    align-items: center;\n    color: $color-red-light;\n    display: flex;\n    font-size: 14px;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n  }\n</style>\n","<script lang=\"ts\">\n  import { onDestroy } from 'svelte'\n  import { getContext } from '$context'\n\n  import { saveSnapshot, importSnapshot } from '$stores/snapshots'\n\n  import TabsMenu from '$tabs/TabsMenu.svelte'\n  import StateTab from '$tabs/state/StateTab.svelte'\n  import HistoryTab from '$tabs/history/HistoryTab.svelte'\n  import PluginsTab from '$tabs/PluginsTab.svelte'\n  import SchemaTab from '$tabs/SchemaTab.svelte'\n  import StructureTab from '$tabs/structure/StructureTab.svelte'\n  import SnapshotsTab from '$tabs/snapshots/SnapshotsTab.svelte'\n\n  export let onClose: () => void\n\n  const { view } = getContext('editor-view')\n  let openTab = 'state',\n    dockTop = 50,\n    dockHeight = 50,\n    fileinput: HTMLInputElement\n\n  onDestroy(() => {\n    document.removeEventListener('mousemove', dragMove)\n    document.removeEventListener('mouseup', dragEnd)\n  })\n\n  function handleResizeMouseDown() {\n    document.addEventListener('mousemove', dragMove)\n    document.addEventListener('mouseup', dragEnd)\n  }\n  function dragMove(evt: MouseEvent) {\n    evt.preventDefault()\n    dockTop = (100 * evt.clientY) / window.innerHeight\n    dockHeight = 100 * (1 - evt.clientY / window.innerHeight)\n  }\n  function dragEnd(evt: MouseEvent) {\n    evt.preventDefault()\n    document.removeEventListener('mousemove', dragMove)\n    document.removeEventListener('mouseup', dragEnd)\n  }\n  function handleSaveSnapshot() {\n    const defaultName = new Date().toLocaleString('sv')\n    const snapshotName = prompt('Enter snapshot name', defaultName)\n    if (snapshotName) {\n      saveSnapshot(snapshotName, view.state.doc.toJSON())\n    }\n  }\n  function handleImportSnapshot() {\n    fileinput.click()\n  }\n  function handleFileSelected(\n    e: Event & {\n      currentTarget: EventTarget & HTMLInputElement\n    }\n  ) {\n    const target = <HTMLInputElement>e.target\n    Array.from(target.files || []).forEach(file => {\n      const reader = new FileReader()\n      reader.readAsText(file)\n      reader.onload = e => {\n        const data = typeof e.target?.result === 'string' ? e.target?.result : ''\n        try {\n          const json = JSON.parse(data)\n          if (!json || typeof json !== 'object') {\n            throw Error('Imported snapshot was not a JSON object' + json)\n          }\n          const name = file.name.slice(0, file.name.lastIndexOf('.'))\n          importSnapshot(name, json, view.state.schema)\n        } catch (err) {\n          console.error('Failed to import snapshot: ' + err)\n        }\n      }\n    })\n  }\n  function handleClickTab(tab: string) {\n    openTab = tab\n  }\n</script>\n\n<div class=\"floating-dock-wrapper\">\n  <div class=\"floating-dock\" style={`top: ${dockTop}%; height: ${dockHeight}%;`}>\n    <div class=\"resizing-div\" on:mousedown={handleResizeMouseDown} />\n    <div class=\"container\">\n      <div>\n        <button class=\"snap-save-btn\" on:click={handleSaveSnapshot}>Save snapshot</button>\n        <button class=\"snap-import-btn\" on:click={handleImportSnapshot}>Import snapshot</button>\n        <button class=\"close-btn\" aria-label=\"Close dev-toolkit button\" on:click={onClose}>X</button\n        >\n      </div>\n      <input\n        style=\"display:none\"\n        type=\"file\"\n        accept=\".json\"\n        multiple\n        on:change={handleFileSelected}\n        bind:this={fileinput}\n      />\n      <TabsMenu onClickTab={handleClickTab} active={openTab} />\n      {#if openTab === 'state'}\n        <StateTab />\n      {:else if openTab === 'history'}\n        <HistoryTab />\n      {:else if openTab === 'plugins'}\n        <PluginsTab />\n      {:else if openTab === 'schema'}\n        <SchemaTab />\n      {:else if openTab === 'structure'}\n        <StructureTab />\n      {:else if openTab === 'snapshots'}\n        <SnapshotsTab />\n      {:else}\n        <p>nuting here</p>\n      {/if}\n    </div>\n  </div>\n</div>\n\n<style lang=\"scss\">\n  .floating-dock-wrapper {\n    position: fixed;\n    width: 0px;\n    height: 0px;\n    top: 0px;\n    left: 0px;\n    z-index: 99999999;\n  }\n  .floating-dock {\n    background-color: $color-blue-bg;\n    position: fixed;\n    z-index: 1;\n    box-shadow: rgba($color-black, 0.3) 0px 0px 4px 0px;\n    left: 0px;\n    top: 50%;\n    width: 100%;\n    height: 50%;\n  }\n  .resizing-div {\n    position: absolute;\n    z-index: 2;\n    opacity: 0;\n    top: -5px;\n    height: 10px;\n    left: 0px;\n    width: 100%;\n    cursor: row-resize;\n  }\n  .container {\n    height: 100%;\n  }\n  .snap-save-btn {\n    background: rgba($color-red-light, 0.6);\n    border: 0;\n    border-radius: 3px;\n    color: $color-white;\n    cursor: pointer;\n    font-size: 12px;\n    height: 24px;\n    line-height: 25px;\n    padding: 0 6px;\n    position: absolute;\n    right: 134px;\n    top: -28px;\n    &:hover {\n      background: rgba($color-red-light, 0.8);\n    }\n  }\n  .snap-import-btn {\n    background: rgba($color-red-light, 0.6);\n    border: 0;\n    border-radius: 3px;\n    color: $color-white;\n    cursor: pointer;\n    font-size: 12px;\n    height: 24px;\n    line-height: 25px;\n    padding: 0 6px;\n    position: absolute;\n    right: 32px;\n    top: -28px;\n    &:hover {\n      background: rgba($color-red-light, 0.8);\n    }\n  }\n  .close-btn {\n    background: rgba($color-red-light, 0.6);\n    border: 0;\n    border-radius: 3px;\n    color: $color-white;\n    cursor: pointer;\n    height: 24px;\n    position: absolute;\n    right: 4px;\n    top: -28px;\n    width: 24px;\n    &:hover {\n      background: rgba($color-red-light, 0.8);\n    }\n  }\n</style>\n","<script lang=\"ts\">\n  import { onMount } from 'svelte'\n  import type { EditorView } from 'prosemirror-view'\n  import type { EditorState } from 'prosemirror-state'\n  import { setContext } from '$context'\n\n  import FloatingBtn from './FloatingBtn.svelte'\n  import FloatingDock from './FloatingDock.svelte'\n\n  import type { ButtonPosition } from '../types'\n\n  export let view: EditorView,\n    devToolsExpanded = false,\n    buttonPosition: ButtonPosition = 'bottom-right'\n\n  setContext('editor-view', {\n    view,\n    replaceEditorContent(state: EditorState) {\n      const tr = view.state.tr\n      tr.replaceWith(0, view.state.doc.nodeSize - 2, state.doc.content)\n      view.dispatch(tr)\n    }\n  })\n\n  onMount(() => {\n    const html = document && document.querySelector('html')\n    if (devToolsExpanded && html) {\n      html.style.marginBottom = '341px'\n    }\n  })\n\n  function handleFloatingBtnClick() {\n    devToolsExpanded = true\n    const html = document && document.querySelector('html')\n    if (html) {\n      html.style.marginBottom = '341px'\n    }\n  }\n  function handleFloatingDockClose() {\n    devToolsExpanded = false\n    const html = document && document.querySelector('html')\n    if (html) {\n      html.style.marginBottom = ''\n    }\n  }\n</script>\n\n<section class=\"dev-tools\">\n  {#if devToolsExpanded}\n    <FloatingDock onClose={handleFloatingDockClose} />\n  {:else}\n    <FloatingBtn on:click={handleFloatingBtnClick} {buttonPosition} />\n  {/if}\n</section>\n\n<style lang=\"scss\">\n  * {\n    --font-sans: Helvetica Neue, Calibri Light, Roboto, sans-serif;\n    --font-small: 11px;\n    --font-medium: 13px;\n    --font-large: 16px;\n    --height-tabs-menu: 48px;\n  }\n  .dev-tools {\n    font-family: var(--font-sans);\n    font-size: var(--font-medium);\n\n    --tree-view-base00: #363755;\n    --tree-view-base01: #604d49;\n    --tree-view-base02: #6d5a55;\n    --tree-view-base03: #d1929b;\n    --tree-view-base04: #b79f8d;\n    --tree-view-base05: #f9f8f2;\n    --tree-view-base06: #f7f4f1;\n    --tree-view-base07: #faf8f5;\n    --tree-view-base08: #fa3e7e;\n    --tree-view-base09: #fd993c;\n    --tree-view-base0A: #f6bf81;\n    --tree-view-base0B: #b8e248;\n    --tree-view-base0C: #b4efe4;\n    --tree-view-base0D: #85d9ef;\n    --tree-view-base0E: #be87ff;\n    --tree-view-base0F: #d6724c;\n  }\n</style>\n","import type { EditorView } from 'prosemirror-view'\nimport type { Transaction } from 'prosemirror-state'\n\nimport { appendNewHistoryEntry } from '$stores/stateHistory'\n\nlet active = false,\n  resetDispatch: (() => void) | undefined = undefined\n\nexport function subscribeToDispatchTransaction(view: EditorView) {\n  active = true\n  const oldDispatchFn = view.someProp('dispatchTransaction')?.bind(view)\n  view.setProps({\n    dispatchTransaction(tr: Transaction) {\n      const stateBeforeDispatch = view.state\n      if (oldDispatchFn) {\n        oldDispatchFn(tr)\n      } else {\n        const state = this.state.apply(tr)\n        this.updateState(state)\n      }\n      if (active) {\n        appendNewHistoryEntry(tr, view.state, stateBeforeDispatch)\n      }\n    }\n  })\n  resetDispatch = () => view.setProps({ dispatchTransaction: oldDispatchFn })\n}\n\nexport function unsubscribeDispatchTransaction() {\n  active = false\n  resetDispatch && resetDispatch()\n  resetDispatch = undefined\n}\n","import type { EditorView } from 'prosemirror-view'\nimport DevTools from './components/DevTools.svelte'\nimport {\n  subscribeToDispatchTransaction,\n  unsubscribeDispatchTransaction\n} from './history-and-diff/subscribeToTransactions'\nimport { resetHistory } from './stores/stateHistory'\n\nimport { DevToolsOpts } from './types'\n\nconst DEVTOOLS_CSS_CLASS = '__prosemirror-dev-toolkit__'\n\n// Make the dev tools available globally for testing and other use\nif (typeof window !== 'undefined') window.applyDevTools = applyDevTools\n\nfunction createOrFindPlace() {\n  let place: HTMLElement | null = document.querySelector(`.${DEVTOOLS_CSS_CLASS}`)\n\n  if (!place) {\n    place = document.createElement('div')\n    place.className = DEVTOOLS_CSS_CLASS\n    document.body.appendChild(place)\n  }\n\n  return place\n}\n\nlet removeCallback: (() => void) | undefined\n\nexport function applyDevTools(view: EditorView, opts: DevToolsOpts = {}) {\n  const place = createOrFindPlace()\n\n  removeDevTools()\n\n  const comp = new DevTools({\n    target: place,\n    props: {\n      view,\n      ...opts\n    }\n  })\n  // Also add view to the window for testing and other debugging\n  if (typeof window !== 'undefined') window.editorView = view\n\n  // Bind the component's life-cycle to the editorView to automatically unmount the devTools\n  const oldDestroyFn = view.destroy.bind(view)\n  view.destroy = () => {\n    // DevTools must always be removed before view as the resetDispatch requires view to be still present\n    removeDevTools()\n    oldDestroyFn()\n  }\n\n  subscribeToDispatchTransaction(view)\n\n  removeCallback = () => {\n    resetHistory()\n    unsubscribeDispatchTransaction()\n    // TODO add test to check no \"Component already destroyed\" warnings appear\n    comp.$destroy()\n  }\n}\n\nexport function removeDevTools() {\n  removeCallback && removeCallback()\n  removeCallback = undefined\n}\n","import { Schema } from 'prosemirror-model'\nimport { ExampleSchema, Nodes, Marks } from './schema-types'\n\nexport const schema: ExampleSchema = new Schema<Nodes, Marks>({\n  nodes: {\n    // :: NodeSpec The top level document node.\n    doc: {\n      content: 'block+',\n    },\n\n    // :: NodeSpec A plain paragraph textblock. Represented in the DOM\n    // as a `<p>` element.\n    paragraph: {\n      content: 'inline*',\n      group: 'block',\n      parseDOM: [{ tag: 'p' }],\n      toDOM() {\n        return ['p', 0]\n      },\n    },\n\n    // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.\n    blockquote: {\n      content: 'block+',\n      group: 'block',\n      defining: true,\n      parseDOM: [{ tag: 'blockquote' }],\n      toDOM() {\n        return ['blockquote', 0]\n      },\n    },\n\n    // :: NodeSpec A horizontal rule (`<hr>`).\n    horizontal_rule: {\n      group: 'block',\n      parseDOM: [{ tag: 'hr' }],\n      toDOM() {\n        return ['hr']\n      },\n    },\n\n    // :: NodeSpec A heading textblock, with a `level` attribute that\n    // should hold the number 1 to 6. Parsed and serialized as `<h1>` to\n    // `<h6>` elements.\n    heading: {\n      attrs: { level: { default: 1 } },\n      content: 'inline*',\n      group: 'block',\n      defining: true,\n      parseDOM: [\n        { tag: 'h1', attrs: { level: 1 } },\n        { tag: 'h2', attrs: { level: 2 } },\n        { tag: 'h3', attrs: { level: 3 } },\n        { tag: 'h4', attrs: { level: 4 } },\n        { tag: 'h5', attrs: { level: 5 } },\n        { tag: 'h6', attrs: { level: 6 } },\n      ],\n      toDOM(node) {\n        return ['h' + node.attrs.level, 0]\n      },\n    },\n\n    // :: NodeSpec A code listing. Disallows marks or non-text inline\n    // nodes by default. Represented as a `<pre>` element with a\n    // `<code>` element inside of it.\n    code_block: {\n      content: 'text*',\n      marks: '',\n      group: 'block',\n      code: true,\n      defining: true,\n      parseDOM: [{ tag: 'pre', preserveWhitespace: 'full' }],\n      toDOM() {\n        return ['pre', ['code', 0]]\n      },\n    },\n\n    // :: NodeSpec The text node.\n    text: {\n      group: 'inline',\n    },\n\n    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,\n    // `alt`, and `href` attributes. The latter two default to the empty\n    // string.\n    image: {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: { default: null },\n        title: { default: null },\n      },\n      group: 'inline',\n      draggable: true,\n      parseDOM: [\n        {\n          tag: 'img[src]',\n          getAttrs(p) {\n            const dom = p as HTMLElement\n            return {\n              src: dom.getAttribute('src'),\n              title: dom.getAttribute('title'),\n              alt: dom.getAttribute('alt'),\n            }\n          },\n        },\n      ],\n      toDOM(node) {\n        const { src, alt, title } = node.attrs\n        return ['img', { src, alt, title }]\n      },\n    },\n\n    // :: NodeSpec A hard line break, represented in the DOM as `<br>`.\n    hard_break: {\n      inline: true,\n      group: 'inline',\n      selectable: false,\n      parseDOM: [{ tag: 'br' }],\n      toDOM() {\n        return ['br']\n      },\n    },\n  },\n  marks: {\n    // :: MarkSpec A link. Has `href` and `title` attributes. `title`\n    // defaults to the empty string. Rendered and parsed as an `<a>`\n    // element.\n    link: {\n      attrs: {\n        href: {},\n        title: { default: null },\n      },\n      inclusive: false,\n      parseDOM: [\n        {\n          tag: 'a[href]',\n          getAttrs(p) {\n            const dom = p as HTMLElement\n            return {\n              href: dom.getAttribute('href'),\n              title: dom.getAttribute('title'),\n            }\n          },\n        },\n      ],\n      toDOM(node) {\n        const { href, title } = node.attrs\n        return ['a', { href, title }, 0]\n      },\n    },\n\n    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.\n    // Has parse rules that also match `<i>` and `font-style: italic`.\n    italic: {\n      parseDOM: [{ tag: 'i' }, { tag: 'em' }, { style: 'font-style=italic' }],\n      toDOM() {\n        return ['em', 0]\n      },\n    },\n\n    // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules\n    // also match `<b>` and `font-weight: bold`.\n    bold: {\n      parseDOM: [\n        { tag: 'strong' },\n        // This works around a Google Docs misbehavior where\n        // pasted content will be inexplicably wrapped in `<b>`\n        // tags with a font-weight normal.\n        {\n          tag: 'b',\n          getAttrs: (p) => {\n            const node = p as HTMLElement\n            return node.style.fontWeight !== 'normal' && null\n          },\n        },\n        {\n          style: 'font-weight',\n          getAttrs: (p) => {\n            const value = p as string\n            return /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n          },\n        },\n      ],\n      toDOM() {\n        return ['strong', 0]\n      },\n    },\n\n    // :: MarkSpec Code font mark. Represented as a `<code>` element.\n    code: {\n      parseDOM: [{ tag: 'code' }],\n      toDOM() {\n        return ['code', 0]\n      },\n    },\n  },\n})\n","import { DecorationSet } from 'prosemirror-view'\nimport { Transaction } from 'prosemirror-state'\nimport { Node as PMNode, NodeType } from 'prosemirror-model'\n\nexport type Operation = 'insert' | 'replace' | 'delete'\n\nexport class DummyClass {\n  values: any[] = [{ 1: [1,2,3]}, {a: 'hello'}, 1]\n}\nexport interface TrackedNodes {\n  tr: Transaction\n  changedNodesMap: Map<PMNode, { pos: number; operation: Operation }>\n  changedNodesTypesSet: Set<NodeType>\n}\nexport interface PluginState {\n  decorationSet: DecorationSet\n  exampleMap: Map<any, any>\n  exampleSet: Set<HTMLElement>\n  exampleClasses: DummyClass[]\n  trackedTrs: TrackedNodes[]\n  joined: TrackedNodes\n}\n","import { Plugin, PluginKey } from 'prosemirror-state'\nimport { DecorationSet } from 'prosemirror-view'\n\nimport { ExampleSchema } from '../schema-types'\n\nimport { findAddedOrRemovedNodes } from './findChangedNodes'\n\nimport { DummyClass } from './types'\nimport type { TrackedNodes, PluginState } from './types'\n\nexport const examplePluginKey = new PluginKey<PluginState, ExampleSchema>('example-plugin')\n\nfunction joinStates(s1: TrackedNodes, s2: TrackedNodes) {\n  const changedNodesMap = new Map(s1.changedNodesMap.entries())\n  s2.changedNodesMap.forEach((val, key) => changedNodesMap.set(key, val))\n  const changedNodesTypesSet = new Set(s1.changedNodesTypesSet.values())\n  s2.changedNodesTypesSet.forEach((val) => changedNodesTypesSet.add(val))\n  return {\n    tr: s2.tr,\n    changedNodesMap,\n    changedNodesTypesSet,\n  }\n}\n\nexport const examplePlugin = () =>\n  new Plugin({\n    key: examplePluginKey,\n    state: {\n      init(config, instance): PluginState {\n        return {\n          decorationSet: DecorationSet.empty,\n          // @ts-ignore\n          exampleMap: new Map([['a', 1], ['b', { 'x': [1,2] }]]),\n          exampleSet: new Set([document.createElement('div'), document.createElement('span')]),\n          exampleClasses: [new DummyClass(), new DummyClass()],\n          trackedTrs: [],\n          joined: {\n            tr: instance.tr,\n            changedNodesMap: new Map(),\n            changedNodesTypesSet: new Set(),\n          },\n        }\n      },\n      apply(tr, value, oldState, newState): PluginState {\n        const state = findAddedOrRemovedNodes(tr, oldState.doc)\n        if (tr.getMeta('appendedTransaction')) {\n          return {\n            ...value,\n            trackedTrs: [...value.trackedTrs, state],\n            joined: joinStates(value.joined, state),\n          }\n        }\n        return {\n          ...value,\n          trackedTrs: [state],\n          joined: state,\n        }\n      },\n    },\n    props: {\n      decorations(state) {\n        return this.getState(state).decorationSet\n      },\n    },\n  })\n","import { Transaction } from 'prosemirror-state'\nimport { Node as PMNode, NodeType, Slice } from 'prosemirror-model'\nimport { Step } from 'prosemirror-transform'\n\nimport type { Operation, TrackedNodes } from './types'\n\nexport const findAddedOrRemovedNodes = (\n  tr: Transaction,\n  oldDoc: PMNode\n): TrackedNodes => {\n  const nodesMap: Map<PMNode, { pos: number; operation: Operation }> = new Map()\n  const typesSet: Set<NodeType> = new Set()\n  const steps = (tr.steps || []) as (Step & {\n    from: number\n    to: number\n    slice: Slice\n  })[]\n  steps.forEach((step) => {\n    const { to, from, slice } = step\n    const sliceSize = slice.size || 0\n    const isInsert = from === to\n    const isReplace = !isInsert && sliceSize !== 0\n    const isDelete = !isInsert && sliceSize === 0\n    const operation = isInsert ? 'insert' : isReplace ? 'replace' : 'delete'\n    if (isReplace || isDelete) {\n      // go through the nodes inside from to\n      oldDoc.nodesBetween(from, to, (n, pos) => {\n        if (!nodesMap.has(n)) {\n          nodesMap.set(n, { pos, operation })\n          typesSet.add(n.type)\n          return true\n        }\n      })\n    }\n    if (isInsert || isReplace) {\n      // go through the nodes inside slice\n      slice.content.descendants((n, pos) => {\n        nodesMap.set(n, { pos, operation })\n        typesSet.add(n.type)\n      })\n    }\n  })\n  return {\n    tr,\n    changedNodesMap: nodesMap,\n    changedNodesTypesSet: typesSet,\n  }\n}\n","import React, { useLayoutEffect, useRef } from 'react'\nimport { EditorView } from 'prosemirror-view'\nimport { EditorState, Transaction } from 'prosemirror-state'\nimport { exampleSetup } from 'prosemirror-example-setup'\n\nimport { schema } from './schema'\nimport { examplePlugin } from './example-plugin'\n\nimport './editor.css'\nimport './prosemirror-example-setup.css'\nimport './menu.css'\n\ninterface EditorProps {\n  className?: string\n  onEditorReady?: (view: EditorView) => void\n  onEdit?: (state: EditorState) => void\n}\n\nexport function PMEditor(props: EditorProps) {\n  const { className = '' } = props\n  const editorDOMRef = useRef(null)\n  const editorViewRef = useRef<EditorView | null>(null)\n\n  useLayoutEffect(() => {\n    const state = createEditorState()\n    const editorViewDOM = editorDOMRef.current\n    if (editorViewDOM) {\n      editorViewRef.current = createEditorView(editorViewDOM, state)\n      props.onEditorReady && props?.onEditorReady(editorViewRef.current)\n    }\n    return () => {\n      editorViewRef.current?.destroy()\n    }\n  // eslint-disable-next-line\n  }, [])\n\n  function createEditorState() {\n    return EditorState.create({\n      schema,\n      plugins: exampleSetup({ schema }).concat(examplePlugin()),\n    })\n  }\n\n  function createEditorView(element: HTMLDivElement, state: EditorState) {\n    const view = new EditorView({ mount: element }, {\n      state,\n      dispatchTransaction,\n    })\n    return view\n  }\n\n  function dispatchTransaction(transaction: Transaction) {\n    if (!editorViewRef.current) {\n      return\n    }\n    const editorState = editorViewRef.current.state.apply(transaction)\n    editorViewRef.current.updateState(editorState)\n    if (props.onEdit) {\n      props.onEdit(editorState)\n    }\n  }\n\n  return (\n    <div className={`${className || ''} pm-editor`} ref={editorDOMRef}/>\n  )\n}\n","import React, { useMemo } from 'react'\nimport debounce from 'lodash.debounce'\n\nimport { EditorView } from 'prosemirror-view'\nimport { EditorState } from 'prosemirror-state'\nimport { applyDevTools as applyDevToolkit } from 'prosemirror-dev-toolkit'\nimport { applyDevTools } from 'prosemirror-dev-tools'\n\nimport { PMEditor } from 'pm/PMEditor'\n\nclass EditorStore {\n\n  view?: EditorView\n  currentEditorState?: {[key: string]: any}\n  localStorageKey: string\n\n  constructor(key: string) {\n    this.localStorageKey = key\n    if (typeof window !== 'undefined') {\n      const existing = localStorage.getItem(this.localStorageKey)\n      if (existing && existing !== null && existing.length > 0) {\n        let stored = JSON.parse(existing)\n        this.currentEditorState = stored\n      }\n    }\n  }\n\n  setEditorView = (view: EditorView) => {\n    this.view = view\n    if (this.currentEditorState) {\n      const state = EditorState.fromJSON(\n        {\n          schema: this.view.state.schema,\n          plugins: this.view.state.plugins,\n        },\n        this.currentEditorState\n      )\n      this.view.updateState(state)\n    }\n  }\n\n  syncCurrentEditorState = () => {\n    const newState = this.view!.state.toJSON()\n    localStorage.setItem(this.localStorageKey, JSON.stringify(newState))\n  }\n}\n\ninterface Props {\n  useDevTools?: boolean\n}\n\nexport function Editor(props: Props) {\n  const { useDevTools } = props\n  const editorStore = useMemo(() => new EditorStore(useDevTools ? 'dev-tools' : 'dev-toolkit'), [useDevTools])\n  const debouncedSync = useMemo(() => debounce(editorStore.syncCurrentEditorState, 250), [editorStore.syncCurrentEditorState])\n\n  function handleEdit() {\n    debouncedSync()\n  }\n  function handleEditorReady(view: EditorView) {\n    editorStore.setEditorView(view)\n    if (useDevTools) {\n      applyDevTools(view)\n    } else {\n      applyDevToolkit(view, {\n        devToolsExpanded: true,\n        buttonPosition: 'bottom-left',\n      })\n    }\n  }\n  return (\n    <PMEditor\n      onEdit={handleEdit}\n      onEditorReady={handleEditorReady}\n    />\n  )\n}\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport { Editor } from '../components/Editor'\n\nexport function FrontPage() {\n  return (\n    <Container>\n      <header>\n        <h1><a href=\"https://teemukoivisto.github.io/prosemirror-dev-toolkit\">prosemirror-dev-toolkit</a></h1>\n        <p><a href=\"https://github.com/TeemuKoivisto/prosemirror-dev-toolkit\">Github repo</a></p>\n        <p>An example React app with ProseMirror editor that uses prosemirror-dev-toolkit.</p>\n      </header>\n      <Editor/>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n\n`\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport { Editor } from '../components/Editor'\n\nexport function DevToolsPage() {\n  return (\n    <Container>\n      <header>\n        <h1><a href=\"https://github.com/d4rkr00t/prosemirror-dev-tools\">Original prosemirror-dev-tools</a></h1>\n        <p><a href=\"https://github.com/d4rkr00t/prosemirror-dev-tools\">Github repo</a></p>\n      </header>\n      <Editor useDevTools/>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n\n`\n","import React, { useEffect, useRef } from 'react'\nimport styled from 'styled-components'\nimport { EditorView } from 'prosemirror-view'\nimport { EditorState } from 'prosemirror-state'\nimport { exampleSetup } from 'prosemirror-example-setup'\nimport { applyDevTools as applyDevToolkit } from 'prosemirror-dev-toolkit'\n\nimport { schema } from 'pm/schema'\n\nexport function PlainPMPage() {\n  const editorDOMRef = useRef(null)\n  const editorViewRef = useRef<EditorView | null>(null)\n\n  useEffect(() => {\n    const state = EditorState.create({\n      schema,\n      plugins: exampleSetup({ schema }),\n    })\n    const editorViewDOM = editorDOMRef.current\n    if (editorViewDOM) {\n      editorViewRef.current = new EditorView({ mount: editorViewDOM }, {\n        state,\n      })\n      applyDevToolkit(editorViewRef.current, {\n        devToolsExpanded: true,\n      })\n    }\n    return () => {\n      editorViewRef.current?.destroy()\n    }\n  }, [])\n\n  return (\n    <Container>\n      <header>\n        <h1><a href=\"https://teemukoivisto.github.io/prosemirror-dev-toolkit\">prosemirror-dev-toolkit</a></h1>\n        <p>This page mounts a ProseMirror editor without any extra props and it's used in Cypress tests</p>\n      </header>\n      <div className=\"pm-editor\" ref={editorDOMRef}/>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n\n`\n","import React, { useEffect, useRef } from 'react'\nimport styled from 'styled-components'\nimport { EditorView } from 'prosemirror-view'\nimport { EditorState } from 'prosemirror-state'\nimport { exampleSetup } from 'prosemirror-example-setup'\nimport { keymap } from 'prosemirror-keymap'\nimport * as Y from 'yjs'\nimport { ySyncPlugin, yUndoPlugin, undo, redo } from 'y-prosemirror'\nimport { applyDevTools as applyDevToolkit } from 'prosemirror-dev-toolkit'\n\nimport { schema } from 'pm/schema'\n\nexport function YjsPage() {\n  const editorDOMRef = useRef(null)\n  const editorViewRef = useRef<EditorView | null>(null)\n\n  useEffect(() => {\n    const ydoc = new Y.Doc()\n    const permanentUserData = new Y.PermanentUserData(ydoc)\n    const yXmlFragment = ydoc.getXmlFragment('pm-doc')\n    const state = EditorState.create({\n      schema,\n      plugins: exampleSetup({ schema, history: false }).concat([\n        ySyncPlugin(yXmlFragment, {\n          permanentUserData: permanentUserData,\n          colors: [\n            { light: '#ecd44433', dark: '#ecd444' },\n            { light: '#ee635233', dark: '#ee6352' },\n            { light: '#6eeb8333', dark: '#6eeb83' }\n          ]\n        }),\n        yUndoPlugin(),\n        keymap({\n          'Mod-z': undo,\n          'Mod-y': redo,\n          'Mod-Shift-z': redo\n        }),\n      ]),\n    })\n    const editorViewDOM = editorDOMRef.current\n    if (editorViewDOM) {\n      editorViewRef.current = new EditorView({ mount: editorViewDOM }, {\n        state,\n      })\n      applyDevToolkit(editorViewRef.current, {\n        devToolsExpanded: true,\n      })\n    }\n    return () => {\n      editorViewRef.current?.destroy()\n    }\n  }, [])\n\n  return (\n    <Container>\n      <header>\n        <h1><a href=\"https://teemukoivisto.github.io/prosemirror-dev-toolkit\">prosemirror-dev-toolkit</a></h1>\n        <p>This editor uses Yjs collaboration which handles the updates to the editor state</p>\n      </header>\n      <div className=\"pm-editor\" ref={editorDOMRef}/>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n\n`\n","import React from 'react'\nimport styled from 'styled-components'\n\nexport function NoEditorPage() {\n  return (\n    <Container>\n      <header>\n        <h1><a href=\"https://teemukoivisto.github.io/prosemirror-dev-toolkit\">prosemirror-dev-toolkit</a></h1>\n        <p>This page has no editor to test whether devTools unmounts properly.</p>\n      </header>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n\n`\n","import * as React from 'react'\nimport { BrowserRouter, Redirect, Switch } from 'react-router-dom'\n\nimport { WrappedRoute } from './components/WrappedRoute'\n\nimport { FrontPage } from './pages/FrontPage'\nimport { DevToolsPage } from './pages/DevToolsPage'\nimport { PlainPMPage } from './pages/PlainPMPage'\nimport { YjsPage } from './pages/YjsPage'\nimport { NoEditorPage } from './pages/NoEditorPage'\n\nexport const Routes = () => (\n  <BrowserRouter basename={process.env.PUBLIC_URL}>\n    <Switch>\n      <WrappedRoute exact path=\"/\" component={FrontPage}/>\n      <WrappedRoute exact path=\"/dev-tools\" component={DevToolsPage}/>\n      <WrappedRoute exact path=\"/plain\" component={PlainPMPage}/>\n      <WrappedRoute exact path=\"/yjs\" component={YjsPage}/>\n      <WrappedRoute exact path=\"/no-editor\" component={NoEditorPage}/>\n      <Redirect to=\"/\" />\n    </Switch>\n  </BrowserRouter>\n)\n","import * as React from 'react'\nimport { render } from 'react-dom'\n\nimport { Routes } from './routes'\n\nimport './index.css'\n\nrender(\n  <Routes />,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}