{"version":3,"sources":["components/NavBar.tsx","components/WrappedRoute.tsx","pm/schema.ts","pm/example-plugin/types.ts","pm/example-plugin/index.ts","pm/example-plugin/findChangedNodes.ts","pm/PMEditor.tsx","components/Editor.tsx","pages/FrontPage.tsx","pages/DevToolsPage.tsx","routes.tsx","index.tsx","../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../../../node_modules/@babel/runtime/helpers/typeof.js","../../../node_modules/svelte/internal/index.mjs","../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../../../node_modules/@babel/runtime/helpers/esm/typeof.js","../../src/context.ts","../../../node_modules/style-inject/dist/style-inject.es.js","../../src/components/FloatingBtn.svelte","../../../node_modules/svelte/store/index.mjs","../../src/stores/snapshots.ts","../../src/tabs/TabsMenu.svelte","../../../node_modules/prosemirror-model/dist/index.es.js","../../../node_modules/html/lib/html.js","../../../node_modules/jsondiffpatch/dist/jsondiffpatch.umd.js","../../src/history-and-diff/diff.ts","../../src/history-and-diff/transaction.ts","../../src/history-and-diff/createHistoryEntry.ts","../../src/stores/stateHistory.ts","../../src/tabs/state/selection.ts","../../../node_modules/svelte-tree-view/package/tree-utils.js","../../../node_modules/svelte-tree-view/package/TreeViewNode.svelte","../../../node_modules/svelte-tree-view/package/TreeView.svelte","../../../node_modules/svelte-tree-view/package/stores/props.js","../../../node_modules/svelte-tree-view/package/stores/root-element.js","../../../node_modules/svelte-tree-view/package/stores/tree.js","../../src/tabs/SplitView.svelte","../../src/components/Button.svelte","../../src/tabs/state/StateTab.svelte","../../src/tabs/state/getActiveMarks.ts","../../src/tabs/history/mapDeltas.ts","../../src/tabs/history/HistoryList.svelte","../../src/tabs/history/DiffValue.svelte","../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../src/tabs/history/HistoryTab.svelte","../../src/tabs/List.svelte","../../src/tabs/PluginsTab.svelte","../../src/tabs/SchemaTab.svelte","../../src/tabs/structure/DocNode.svelte","../../src/tabs/structure/colors.ts","../../src/tabs/structure/DocView.svelte","../../src/tabs/structure/StructureTab.svelte","../../src/tabs/snapshots/SnapshotsList.svelte","../../src/tabs/snapshots/SnapshotsTab.svelte","../../src/components/FloatingDock.svelte","../../src/components/DevTools.svelte","../../src/history-and-diff/subscribeToTransactions.ts","../../src/index.ts"],"names":["NavBar","props","className","Container","Nav","Link","to","exact","activeClassName","styled","div","nav","NavLink","WrappedRoute","Component","component","rest","render","MainWrapper","MainContainer","main","schema","Schema","nodes","doc","content","paragraph","group","parseDOM","tag","toDOM","blockquote","defining","horizontal_rule","heading","attrs","level","default","node","code_block","marks","code","preserveWhitespace","text","image","inline","src","alt","title","draggable","getAttrs","p","dom","getAttribute","hard_break","selectable","link","href","inclusive","italic","style","bold","fontWeight","test","DummyClass","values","a","examplePluginKey","PluginKey","joinStates","s1","s2","changedNodesMap","Map","entries","forEach","val","key","set","changedNodesTypesSet","Set","add","tr","examplePlugin","Plugin","state","init","config","instance","decorationSet","DecorationSet","empty","exampleMap","exampleSet","document","createElement","exampleClasses","trackedTrs","joined","apply","value","oldState","newState","oldDoc","nodesMap","typesSet","steps","step","from","slice","sliceSize","size","isInsert","isReplace","operation","nodesBetween","n","pos","has","type","descendants","findAddedOrRemovedNodes","getMeta","decorations","this","getState","PMEditor","editorViewRef","useRef","editorRef","dispatchTransaction","transaction","current","editorState","updateState","onEdit","useLayoutEffect","EditorState","create","plugins","exampleSetup","concat","editorViewDOM","element","EditorView","mount","createEditorView","onEditorReady","destroy","id","ref","EditorStore","view","currentEditorState","localStorageKey","setEditorView","fromJSON","syncCurrentEditorState","toJSON","localStorage","setItem","JSON","stringify","window","existing","getItem","length","stored","parse","Editor","useDevTools","editorStore","useMemo","debouncedSync","debounce","applyDevTools","applyDevToolkit","devToolsExpanded","buttonPosition","FrontPage","DevToolsPage","Routes","basename","process","path","getElementById","_classCallCheck","Constructor","TypeError","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","o","Object","setPrototypeOf","__proto__","_inherits","subClass","superClass","prototype","constructor","writable","configurable","_typeof","obj","Symbol","iterator","module","exports","current_component","_possibleConstructorReturn","call","assertThisInitialized","_getPrototypeOf","getPrototypeOf","_arrayLikeToArray","arr","len","i","arr2","Array","_unsupportedIterableToArray","minLen","arrayLikeToArray","toString","name","_slicedToArray","isArray","_i","_s","_e","_arr","_n","_d","next","done","push","err","unsupportedIterableToArray","nonIterableRest","_toConsumableArray","iter","_defineProperties","target","descriptor","enumerable","defineProperty","noop","assign","tar","k","run","fn","blank_object","run_all","fns","is_function","thing","safe_not_equal","b","subscribe","store","callbacks","unsub","unsubscribe","get_store_value","_","component_subscribe","callback","$$","on_destroy","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","get_slot_changes","dirty","lets","merged","Math","max","update_slot_base","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","get_all_dirty_from_scope","exclude_internal_props","result","compute_rest_props","keys","null_to_empty","append","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","d","svg_element","createElementNS","data","createTextNode","space","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","setAttribute","set_attributes","attributes","descriptors","getOwnPropertyDescriptors","cssText","xlink_attr","setAttributeNS","children","childNodes","set_data","wholeText","toggle_class","toggle","classList","set_current_component","get_current_component","Error","onMount","on_mount","setContext","context","getContext","get","bubble","_this2","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","flush","update","clear","fragment","before_update","after_update","outros","outroing","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","create_component","mount_component","customElement","m","new_on_destroy","map","filter","destroy_component","make_dirty","then","fill","create_fragment","not_equal","append_styles","parent_component","bound","on_disconnect","skip_bound","root","ready","ret","hydrate","l","intro","SvelteComponent","protoProps","staticProps","$destroy","index","indexOf","splice","$$props","$$set","setCtx","getCtx","styleInject","css","insertAt","head","getElementsByTagName","firstChild","styleSheet","subscriber_queue","stop","start","subscribers","new_value","run_queue","subscriber","invalidate","derived","stores","initial_value","single","stores_array","auto","inited","pending","cleanup","sync","unsubscribers","snapshots","selectedSnapshot","previousEditorState","persisted","parsed","console","error","setEditorDoc","nodeFromJSON","updateSnapshot","snapshot","s","timestamp","exportSnapshot","file","Blob","URL","createObjectURL","download","click","deleteSnapshot","selected","active","onClickTab","findDiffStart","childCount","childA","child","childB","sameMarkup","isText","j","inner","nodeSize","findDiffEnd","posA","posB","iA","iB","same","minSize","min","Fragment","prototypeAccessors","lastChild","f","nodeStart","parent","end","textBetween","blockSeparator","leafText","separated","isLeaf","isBlock","other","last","first","withText","cut","cutByIndex","replaceChild","copy","addToStart","addToEnd","eq","found","RangeError","maybeChild","otherPos","findIndex","round","retIndex","curPos","toStringInner","join","fromArray","array","defineProperties","offset","compareDeep","p$1","Mark","ReplaceError","message","addToSet","placed","excludes","rank","removeFromSet","isInSet","json","sameSet","setFrom","none","sort","Slice","openStart","openEnd","prototypeAccessors$1","removeRange","ref$1","indexTo","offsetTo","insertInto","dist","canReplace","replace","$from","$to","depth","replaceOuter","$along","extra","resolveNoCache","close","replaceThreeWay","parentOffset","replaceTwoWay","checkJoin","sub","compatibleContent","joinable","$before","$after","addNode","addRange","$start","$end","startIndex","endIndex","textOffset","nodeAfter","nodeBefore","validContent","removeBetween","maxOpen","openIsolating","spec","isolating","n$1","ResolvedPos","prototypeAccessors$2","resolveDepth","indexAfter","before","after","dOff","posAtIndex","tmp","marksAcross","isInline","sharedDepth","blockRange","pred","inlineContent","NodeRange","sameParent","str","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","prototypeAccessors$1$1","emptyAttrs","Node","prototypeAccessors$3","textContent","isTextblock","isAtom","startPos","hasMarkup","defaultAttrs","mark","includeParents","nodeAt","childAfter","childBefore","rangeHasMark","toDebugString","contentMatchAt","match","contentMatch","matchFragment","replacement","one","two","validEnd","allowsMarks","canReplaceWith","matchType","canAppend","check","markFromJSON","nodeType","ContentMatch","wrapCache","prototypeAccessors$4","defaultType","edgeCount","string","nodeTypes","stream","TokenStream","expr","parseExpr","nfa","labeled","explore","states","out","term","known","nullFrom","states$1","cmp","connect","compile","exprs","reduce","loop","edge","loop$1","cur","i$1","next$1","i$2","next$2","edges","work","dead","hasRequiredAttrs","frag","compatible","fillBefore","toEnd","seen","search","types","finished","tp","createAndFill","findWrapping","computed","computeWrapping","via","shift","reverse","scan","tokens","split","pop","prototypeAccessors$1$2","parseExprSeq","eat","parseExprSubscript","typeName","type$1","groups","parseExprRange","parseNum","Number","tok","SyntaxError","NodeType","Attribute","defaults","attrName","hasDefault","markSet","prototypeAccessors$5","atom","isRequired","computeAttrs","built","given","createChecked","allowsMarkType","markType","allowedMarks","topType","topNode","hasOwnProperty","prototypeAccessors$1$3","blockTags","address","article","aside","canvas","dd","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","output","pre","section","table","tfoot","ul","ignoreTags","object","script","listTags","wsOptionsFor","NodeContext","pendingMarks","solid","activeMarks","stashMarks","wrap","finish","exec","popFromStashMark","applyPending","nextType","markMayApply","inlineContext","nodeName","toLowerCase","ParseContext","parser","open","isOpen","topContext","topOptions","topMatch","topNodeType","find","findPositions","needsBlock","prototypeAccessors$6","top","currentPos","v","returned","addDOM","addTextNode","readStyles","re","trim","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","insertNode","findInText","findInside","matchAfter","ruleID","normalizeLists","prevItem","nextSibling","rule","ruleFromNode","matchTag","ignore","ignoreFallback","skip","closeParent","oldNeedsBlock","leafFallback","addAll","addElementByRule","consuming","ownerDocument","findPlace","styles","matchStyle","continueAfter","this$1","enter","startIn","getContent","contentDOM","contentElement","querySelector","findAround","findAtPoint","route","cx","enterInner","textblockFromContext","closeExtra","preserveWS","ok","topOpen","contains","compareDocumentPosition","textNode","matchesContext","some","parts","option","useRoot","minDepth","part","$context","deflt","upto","lastIndexOf","stashMark","DOMSerializer","gatherToDOM","serializeFragment","createDocumentFragment","keep","rendered","spanning","markDOM","serializeMark","serializeNodeInner","renderSpec","onContent","serializeNode","structure","xmlNS","tagName","space$1","innerContent","fromSchema","domSerializer","nodesFromSchema","marksFromSchema","html","html_source","multi_parser","indent_size","indent_character","max_char","brace_style","unformatted","indent_char","Infinity","token","current_mode","tags","parentcount","parent1","tag_type","token_text","last_token","last_text","token_type","Utils","whitespace","single_token","extra_liners","in_array","what","get_content","input_char","input","charAt","line_char_count","indent_level","indent_string","get_contents_to","reg_match","RegExp","lastIndex","reg_array","end_script","substring","record_tag","retrieve_tag","temp_parent","get_tag","tag_start","tag_end","get_unformatted","print_newline","tag_index","tag_complete","tag_check","comment","unindent","delimiter","orig_tag","get_token","substr","get_full_indent","printer","js_source","print_token","indent","t","tag_name","tag_extracted_from_last_output","_beautifier","js_beautify","css_beautify","indent_scripts","script_indent_level","indentation","_level","reindent","chalk","_typeof2","classCallCheck","createClass","property","receiver","Function","desc","getOwnPropertyDescriptor","getter","inherits","possibleConstructorReturn","slicedToArray","undefined","sliceIterator","toConsumableArray","Processor","selfOptions","pipes","_options","pipeArg","pipe","processor","nextPipe","lastPipe","lastContext","nextAfterChildren","hasResult","Pipe","filters","debug","log","filterName","exiting","resultCheck","msg","_filters","arguments","_filters2","unshift","params","should","noResult","Context","childName","clone","arg","Date","getTime","regexMatch","cloneRegExp","cloned","DiffContext","_Context","left","right","_this","cloneDiffValues","clone$$1","setResult","PatchContext","delta","ReverseContext","isArray$1","diffFilter","leftType","rightType","leftIsArray","rightIsArray","exit","patchFilter","nested","regexArgs","reverseFilter","collectChildrenDiffFilter","_t","objectsDiffFilter","propertyFilter","patchFilter$1","collectChildrenPatchFilter","reverseFilter$1","collectChildrenReverseFilter","defaultMatch","array1","array2","index1","index2","lcs","innerContext","matrix","len1","len2","x","y","lengthMatrix","subsequence","sequence","indices1","indices2","backtrack","isArray$2","arrayIndexOf","item","matchItems","value1","value2","objectHash","matchByPosition","hash1","hash2","hashCache1","hashCache2","diffFilter$1","matchContext","commonHead","commonTail","val1","val2","arraysHaveMatchByRef","trimmed1","trimmed2","seq","removedItems","detectMove","arrays","includeValueOnMove","removedItemsLength","indexOnArray2","isMove","removeItemIndex1","compare","patchFilter$2","toRemove","toInsert","toModify","ARRAY_MOVE","parseInt","indexDiff","removedValue","toInsertLength","insertion","toModifyLength","modification","collectChildrenPatchFilter$1","reverseFilter$2","newName","reverseArrayDeltaIndex","itemDelta","reverseIndex","deltaIndex","deltaItem","moveFromIndex","moveToIndex","collectChildrenReverseFilter$1","diffFilter$2","diffMatchPatch","createCommonjsModule","diff_match_patch","Diff_Timeout","Diff_EditCost","Match_Threshold","Match_Distance","Patch_DeleteThreshold","Patch_Margin","Match_MaxBits","DIFF_DELETE","diff_main","text1","text2","opt_checklines","opt_deadline","MAX_VALUE","deadline","checklines","commonlength","diff_commonPrefix","commonprefix","diff_commonSuffix","commonsuffix","diffs","diff_compute_","diff_cleanupMerge","longtext","shorttext","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","diff_lineMode_","diff_bisect_","diff_linesToChars_","chars1","chars2","linearray","lineArray","diff_charsToLines_","diff_cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","DIFF_EQUAL","text1_length","text2_length","max_d","ceil","v_offset","v_length","v1","v2","front","k1start","k1end","k2start","k2end","k1","k1_offset","y1","x1","k2_offset","x2","diff_bisectSplit_","k2","y2","text1a","text2a","text1b","text2b","diffsb","lineHash","diff_linesToCharsMunge_","chars","lineStart","lineEnd","lineArrayLength","line","String","fromCharCode","charCodeAt","pointermin","pointermax","pointermid","pointerstart","floor","pointerend","diff_commonOverlap_","text_length","best","pattern","dmp","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","hm1","hm2","changes","equalities","equalitiesLength","lastequality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","diff_cleanupSemanticLossless","deletion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","char1","char2","nonAlphaNumeric1","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","diff_cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","diff_xIndex","loc","last_chars1","last_chars2","diff_prettyHtml","pattern_amp","pattern_lt","pattern_gt","pattern_para","op","diff_text1","diff_text2","diff_levenshtein","levenshtein","insertions","deletions","diff_toDelta","encodeURI","diff_fromDelta","diffsLength","param","decodeURI","ex","isNaN","match_main","match_bitap_","match_alphabet_","match_bitapScore_","e","accuracy","proximity","abs","score_threshold","best_loc","bin_min","bin_mid","matchmask","last_rd","bin_max","rd","charMatch","patch_addContext_","patch","start2","length1","padding","prefix","suffix","start1","length2","patch_make","opt_b","opt_c","patches","patch_obj","patchDiffLength","char_count1","char_count2","prepatch_text","postpatch_text","diff_type","diff_text","patch_deepCopy","patchesCopy","patchCopy","patch_apply","nullPadding","patch_addPadding","patch_splitMax","results","start_loc","expected_loc","end_loc","mod","paddingLength","extraLength","patch_size","bigpatch","precontext","postcontext","patch_toText","patch_fromText","textline","textPointer","patchHeader","sign","cachedDiffPatch","getDiffMatchPatch","required","diff_match_patch_not_found","diff","txt1","txt2","_patch","textPatchFailed","diffFilter$3","minLength","textDiff","DEFAULT_MIN_LENGTH","diffMatchPatch$$1","patchFilter$3","TEXT_DIFF","textDeltaReverse","lines","lineTmp","headerRegex","reverseFilter$3","DiffPatcher","shouldHaveResult","_processor","isArray$3","getObjectKeys","names","trimUnderscore","arrayKeyToSortNumber","arrayKeyComparer","key1","key2","BaseFormatter","prepareContext","recurse","finalize","buffer","_buffer","deltaType","_ref","leftKey","movedFrom","isLast","leftValue","getDeltaType","nodeBegin","rootBegin","typeFormattterNotFound","typeFormattterErrorFormatter","stack","nodeEnd","rootEnd","forEachDeltaKey","arrayKeys","moveDestinations","includeMoveDestinations","lineOutput","pieces","location","chr","pieceIndex","piecesLength","piece","pieceOutput","base","freeze","HtmlFormatter","_BaseFormatter","htmlEscape","parseTextDiff","nodeClass","hasArrows","adjustArrows","formatValue","formatDeltaChildren","formatTextDiffString","replacements","nodeArg","el","query","elems","querySelectorAll","_ref3","arrowParent","svg","display","destination","innerText","getElementText","container","destinationElem","_ref2","eachChildren","distance","offsetTop","curve","showUnchanged","show","delay","body","classes","showing","hiding","visible","hidden","list","remove","setTimeout","intervalId","setInterval","clearInterval","defaultInstance","hideUnchanged","format","AnnotatedFormatter","levels","indentLevel","indentPad","row","htmlNote","wrapPropertyName","deltaAnnotations","added","formatLegend","modified","deleted","moved","textdiff","formatAnyChange","annotator","format_added","format_modified","format_deleted","format_moved","format_textdiff","defaultInstance$1","annotated","OPERATIONS","JSONFormatter","pushCurrentOp","currentPath","pushMoveOp","toPath","opsByDescendingOrder","removeOps","sortBy","splitA","splitB","indexA","indexB","lastA","lastB","compareByIndexDesc","partitionOps","initArr","position","acc","isMoveOp","isRemoveOp","_ref4","defaultInstance$2","format$2","_partitionOps","_partitionOps2","moveOps","removedOps","restOps","removeOpsReverse","reorderOps","jsonpatch","chalkColor","_len","args","_key","colors","movedestination","unchanged","textDiffLine","ConsoleFormatter","outLine","_len2","_key2","color","pushColor","popColor","defaultInstance$3","format$3","console$1","defaultInstance$4","formatters","dateReviver","UTC","unpatch","clone$1","factory","require$$0","diffPatcher","inputA","inputB","addedProperties","addPropertiesToTransaction","buildSelection","selection","pad","num","formatTimestamp","date","getHours","getMinutes","getSeconds","getMilliseconds","regexp","highlightHtmlString","stateHistory","shownHistoryGroups","latestEntry","appendNewHistoryEntry","stateBeforeDispatch","entryMap","prevGroup","newEntry","oldEntry","serializer","domFragment","selectedElementsAsHtml","outerHTML","prevState","contentDiff","selectionDiff","random","time","timeStr","selectionHtml","prettyPrint","topEntryId","isGroup","newGroup","entryIds","expanded","resetHistory","defaultProperties","resolvedPosProperties","resolvedPosSubProperties","createSelection","createFullSelection","includes","additionalProperties","subKey","createNode","collapsed","getValueType","parentId","circularOfId","recurseObjectProperties","ensureNotCollapsed","treeMap","oldTreeMap","iteratedValues","recomputeExpandNode","opts","_a","omitKeys","maxDepth","oldNode","shouldExpandNode","stopCircularRecursion","isCircularNode","existingNodeWithValue","mappedChildren","mapChildren","idx","showLogButton","showCopyButton","treeStore","propsStore","rootElementStore","getNode","hasChildren","valueComponent","$props","info","_node","navigator","clipboard","writeText","toggleCollapse","expandAllNodesToNode","$rootElementStore","scrollIntoView","class","theme","recursionOpts","valueFormatter","rootElement","defaultRecursionOpts","initialProps","setProps","newProps","customFormat","toISOString","defaultRootNode","tree","newTree","newTreeMap","iterated","updatedNode","expandNodeChildren","warn","previouslyIterated","nodeWithUpdatedChildren","updated","recurseNodeUpwards","newRecursionOpts","setProperty","rootNode","updates","to_null_out","accounted_for","formatDocNodeValue","storedMarks","$head","$anchor","mapSelectionDeltaChildren","_val","_parent","mapDocDeltaChildren","transformed","topEntry","listItems","onSelect","groupIdx","subEntry","getValueString","raw","DiffValue","nodeColors","buildColors","safeIndex","total","quotient","handleSnapDoubleclick","snap","handleClickView","handleRestoreClick","handleExportClick","handleClickDelete","important","snapshotName","now","fileinput","resetDispatch","removeCallback","place","removeDevTools","comp","DevTools","editorView","oldDestroyFn","bind","oldDispatchFn","someProp","dispatch"],"mappings":"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","file":"static/js/main.f21ed3c8.chunk.js","sourcesContent":["import React from 'react'\nimport { NavLink } from 'react-router-dom'\nimport styled from 'styled-components'\n\nimport { RouteComponentProps } from 'react-router'\n\ninterface IProps extends RouteComponentProps<{}> {\n  className?: string\n}\n\nexport function NavBar(props: IProps) {\n  const { className } = props\n  return (\n    <Container className={className}>\n      <Nav>\n        <Link to=\"/\" exact activeClassName=\"current\">Front page</Link>\n        <Link to=\"/dev-tools\" exact activeClassName=\"current\">Dev tools</Link>\n      </Nav>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n  background: var(--color-primary);\n  box-shadow: 0 0 2px 2px rgba(0,0,0,0.18);\n  padding: 1rem;\n`\nconst Nav = styled.nav`\n  align-items: center;\n  color: #fff;\n  display: flex;\n`\nconst Link = styled(NavLink)`\n  box-sizing: border-box;\n  color: #fff;\n  cursor: pointer;\n  font-size: 1rem;\n  padding: 0.5rem 1rem;\n  text-decoration: none;\n  transition: 0.2s hover;\n  &:hover {\n    text-decoration: underline;\n  }\n  &.current {\n    font-weight: 600;\n  }\n`\n","import * as React from 'react'\nimport { Route, RouteProps, RouteComponentProps } from 'react-router'\nimport styled from 'styled-components'\n\nimport { NavBar } from './NavBar'\n\ntype ReactComponent = React.ComponentClass<any> | React.StatelessComponent<any>\n\ninterface IWrappedRoute extends RouteProps {\n  component: ReactComponent\n}\n\nconst renderNoMainContainerWrapper = (Component: ReactComponent) => (props: RouteComponentProps<any>) =>\n  <MainWrapper>\n    <NavBar {...props}/>\n    <Component {...props}/>\n  </MainWrapper>\n\nconst renderWrapper = (Component: ReactComponent) => (props: RouteComponentProps<any>) =>\n  <MainWrapper>\n    <NavBar {...props}/>\n    <MainContainer>\n      <Component {...props}/>\n    </MainContainer>\n  </MainWrapper>\n\nexport const NoMainContainerRoute = ({ component, ...rest } : IWrappedRoute) =>\n  <Route {...rest} render={renderNoMainContainerWrapper(component)}/>\n\nexport const WrappedRoute = ({ component, ...rest } : IWrappedRoute) =>\n  <Route {...rest} render={renderWrapper(component)}/>\n\nconst MainWrapper = styled.div`\n  min-height: 100vh;\n`\nconst MainContainer = styled.main`\n  margin: 40px auto 0 auto;\n  max-width: 680px;\n  padding-bottom: 20px;\n  @media only screen and (max-width: 720px) {\n    margin: 40px 20px 0 20px;\n    padding-bottom: 20px;\n  }\n`\n","import { Schema } from 'prosemirror-model'\nimport { ExampleSchema, Nodes, Marks } from './schema-types'\n\nexport const schema: ExampleSchema = new Schema<Nodes, Marks>({\n  nodes: {\n    // :: NodeSpec The top level document node.\n    doc: {\n      content: 'block+',\n    },\n\n    // :: NodeSpec A plain paragraph textblock. Represented in the DOM\n    // as a `<p>` element.\n    paragraph: {\n      content: 'inline*',\n      group: 'block',\n      parseDOM: [{ tag: 'p' }],\n      toDOM() {\n        return ['p', 0]\n      },\n    },\n\n    // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.\n    blockquote: {\n      content: 'block+',\n      group: 'block',\n      defining: true,\n      parseDOM: [{ tag: 'blockquote' }],\n      toDOM() {\n        return ['blockquote', 0]\n      },\n    },\n\n    // :: NodeSpec A horizontal rule (`<hr>`).\n    horizontal_rule: {\n      group: 'block',\n      parseDOM: [{ tag: 'hr' }],\n      toDOM() {\n        return ['hr']\n      },\n    },\n\n    // :: NodeSpec A heading textblock, with a `level` attribute that\n    // should hold the number 1 to 6. Parsed and serialized as `<h1>` to\n    // `<h6>` elements.\n    heading: {\n      attrs: { level: { default: 1 } },\n      content: 'inline*',\n      group: 'block',\n      defining: true,\n      parseDOM: [\n        { tag: 'h1', attrs: { level: 1 } },\n        { tag: 'h2', attrs: { level: 2 } },\n        { tag: 'h3', attrs: { level: 3 } },\n        { tag: 'h4', attrs: { level: 4 } },\n        { tag: 'h5', attrs: { level: 5 } },\n        { tag: 'h6', attrs: { level: 6 } },\n      ],\n      toDOM(node) {\n        return ['h' + node.attrs.level, 0]\n      },\n    },\n\n    // :: NodeSpec A code listing. Disallows marks or non-text inline\n    // nodes by default. Represented as a `<pre>` element with a\n    // `<code>` element inside of it.\n    code_block: {\n      content: 'text*',\n      marks: '',\n      group: 'block',\n      code: true,\n      defining: true,\n      parseDOM: [{ tag: 'pre', preserveWhitespace: 'full' }],\n      toDOM() {\n        return ['pre', ['code', 0]]\n      },\n    },\n\n    // :: NodeSpec The text node.\n    text: {\n      group: 'inline',\n    },\n\n    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,\n    // `alt`, and `href` attributes. The latter two default to the empty\n    // string.\n    image: {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: { default: null },\n        title: { default: null },\n      },\n      group: 'inline',\n      draggable: true,\n      parseDOM: [\n        {\n          tag: 'img[src]',\n          getAttrs(p) {\n            const dom = p as HTMLElement\n            return {\n              src: dom.getAttribute('src'),\n              title: dom.getAttribute('title'),\n              alt: dom.getAttribute('alt'),\n            }\n          },\n        },\n      ],\n      toDOM(node) {\n        const { src, alt, title } = node.attrs\n        return ['img', { src, alt, title }]\n      },\n    },\n\n    // :: NodeSpec A hard line break, represented in the DOM as `<br>`.\n    hard_break: {\n      inline: true,\n      group: 'inline',\n      selectable: false,\n      parseDOM: [{ tag: 'br' }],\n      toDOM() {\n        return ['br']\n      },\n    },\n  },\n  marks: {\n    // :: MarkSpec A link. Has `href` and `title` attributes. `title`\n    // defaults to the empty string. Rendered and parsed as an `<a>`\n    // element.\n    link: {\n      attrs: {\n        href: {},\n        title: { default: null },\n      },\n      inclusive: false,\n      parseDOM: [\n        {\n          tag: 'a[href]',\n          getAttrs(p) {\n            const dom = p as HTMLElement\n            return {\n              href: dom.getAttribute('href'),\n              title: dom.getAttribute('title'),\n            }\n          },\n        },\n      ],\n      toDOM(node) {\n        const { href, title } = node.attrs\n        return ['a', { href, title }, 0]\n      },\n    },\n\n    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.\n    // Has parse rules that also match `<i>` and `font-style: italic`.\n    italic: {\n      parseDOM: [{ tag: 'i' }, { tag: 'em' }, { style: 'font-style=italic' }],\n      toDOM() {\n        return ['em', 0]\n      },\n    },\n\n    // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules\n    // also match `<b>` and `font-weight: bold`.\n    bold: {\n      parseDOM: [\n        { tag: 'strong' },\n        // This works around a Google Docs misbehavior where\n        // pasted content will be inexplicably wrapped in `<b>`\n        // tags with a font-weight normal.\n        {\n          tag: 'b',\n          getAttrs: (p) => {\n            const node = p as HTMLElement\n            return node.style.fontWeight !== 'normal' && null\n          },\n        },\n        {\n          style: 'font-weight',\n          getAttrs: (p) => {\n            const value = p as string\n            return /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n          },\n        },\n      ],\n      toDOM() {\n        return ['strong', 0]\n      },\n    },\n\n    // :: MarkSpec Code font mark. Represented as a `<code>` element.\n    code: {\n      parseDOM: [{ tag: 'code' }],\n      toDOM() {\n        return ['code', 0]\n      },\n    },\n  },\n})\n","import { DecorationSet } from 'prosemirror-view'\nimport { Transaction } from 'prosemirror-state'\nimport { Node as PMNode, NodeType } from 'prosemirror-model'\n\nexport type Operation = 'insert' | 'replace' | 'delete'\n\nexport class DummyClass {\n  values: any[] = [{ 1: [1,2,3]}, {a: 'hello'}, 1]\n}\nexport interface TrackedNodes {\n  tr: Transaction\n  changedNodesMap: Map<PMNode, { pos: number; operation: Operation }>\n  changedNodesTypesSet: Set<NodeType>\n}\nexport interface PluginState {\n  decorationSet: DecorationSet\n  exampleMap: Map<any, any>\n  exampleSet: Set<HTMLElement>\n  exampleClasses: DummyClass[]\n  trackedTrs: TrackedNodes[]\n  joined: TrackedNodes\n}\n","import { Plugin, PluginKey } from 'prosemirror-state'\nimport { DecorationSet } from 'prosemirror-view'\n\nimport { ExampleSchema } from '../schema-types'\n\nimport { findAddedOrRemovedNodes } from './findChangedNodes'\n\nimport { DummyClass } from './types'\nimport type { TrackedNodes, PluginState } from './types'\n\nexport const examplePluginKey = new PluginKey<PluginState, ExampleSchema>('example-plugin')\n\nfunction joinStates(s1: TrackedNodes, s2: TrackedNodes) {\n  const changedNodesMap = new Map(s1.changedNodesMap.entries())\n  s2.changedNodesMap.forEach((val, key) => changedNodesMap.set(key, val))\n  const changedNodesTypesSet = new Set(s1.changedNodesTypesSet.values())\n  s2.changedNodesTypesSet.forEach((val) => changedNodesTypesSet.add(val))\n  return {\n    tr: s2.tr,\n    changedNodesMap,\n    changedNodesTypesSet,\n  }\n}\n\nexport const examplePlugin = () =>\n  new Plugin({\n    key: examplePluginKey,\n    state: {\n      init(config, instance): PluginState {\n        return {\n          decorationSet: DecorationSet.empty,\n          // @ts-ignore\n          exampleMap: new Map([['a', 1], ['b', { 'x': [1,2] }]]),\n          exampleSet: new Set([document.createElement('div'), document.createElement('span')]),\n          exampleClasses: [new DummyClass(), new DummyClass()],\n          trackedTrs: [],\n          joined: {\n            tr: instance.tr,\n            changedNodesMap: new Map(),\n            changedNodesTypesSet: new Set(),\n          },\n        }\n      },\n      apply(tr, value, oldState, newState): PluginState {\n        const state = findAddedOrRemovedNodes(tr, oldState.doc)\n        if (tr.getMeta('appendedTransaction')) {\n          return {\n            ...value,\n            trackedTrs: [...value.trackedTrs, state],\n            joined: joinStates(value.joined, state),\n          }\n        }\n        return {\n          ...value,\n          trackedTrs: [state],\n          joined: state,\n        }\n      },\n    },\n    props: {\n      decorations(state) {\n        return this.getState(state).decorationSet\n      },\n    },\n  })\n","import { Transaction } from 'prosemirror-state'\nimport { Node as PMNode, NodeType, Slice } from 'prosemirror-model'\nimport { Step } from 'prosemirror-transform'\n\nimport type { Operation, TrackedNodes } from './types'\n\nexport const findAddedOrRemovedNodes = (\n  tr: Transaction,\n  oldDoc: PMNode\n): TrackedNodes => {\n  const nodesMap: Map<PMNode, { pos: number; operation: Operation }> = new Map()\n  const typesSet: Set<NodeType> = new Set()\n  const steps = (tr.steps || []) as (Step & {\n    from: number\n    to: number\n    slice: Slice\n  })[]\n  steps.forEach((step) => {\n    const { to, from, slice } = step\n    const sliceSize = slice.size || 0\n    const isInsert = from === to\n    const isReplace = !isInsert && sliceSize !== 0\n    const isDelete = !isInsert && sliceSize === 0\n    const operation = isInsert ? 'insert' : isReplace ? 'replace' : 'delete'\n    if (isReplace || isDelete) {\n      // go through the nodes inside from to\n      oldDoc.nodesBetween(from, to, (n, pos) => {\n        if (!nodesMap.has(n)) {\n          nodesMap.set(n, { pos, operation })\n          typesSet.add(n.type)\n          return true\n        }\n      })\n    }\n    if (isInsert || isReplace) {\n      // go through the nodes inside slice\n      slice.content.descendants((n, pos) => {\n        nodesMap.set(n, { pos, operation })\n        typesSet.add(n.type)\n      })\n    }\n  })\n  return {\n    tr,\n    changedNodesMap: nodesMap,\n    changedNodesTypesSet: typesSet,\n  }\n}\n","import React, { useLayoutEffect, useRef } from 'react'\nimport { EditorView } from 'prosemirror-view'\nimport { EditorState, Transaction } from 'prosemirror-state'\nimport { exampleSetup } from 'prosemirror-example-setup'\n\nimport { schema } from './schema'\nimport { examplePlugin } from './example-plugin'\n\nimport './editor.css'\nimport './prosemirror-example-setup.css'\nimport './menu.css'\n\ninterface EditorProps {\n  className?: string\n  onEditorReady?: (view: EditorView) => void\n  onEdit?: (state: EditorState) => void\n}\n\nexport function PMEditor(props: EditorProps) {\n  const { className = '' } = props\n  const editorViewRef = useRef(null)\n  const editorRef = useRef<EditorView | null>(null)\n\n  useLayoutEffect(() => {\n    const state = createEditorState()\n    const editorViewDOM = editorViewRef.current\n    if (editorViewDOM) {\n      editorRef.current = createEditorView(editorViewDOM, state)\n      props.onEditorReady && props?.onEditorReady(editorRef.current)\n    }\n    return () => {\n      editorRef.current?.destroy()\n    }\n  // eslint-disable-next-line\n  }, [])\n\n  function createEditorState() {\n    return EditorState.create({\n      schema,\n      plugins: exampleSetup({ schema }).concat(examplePlugin()),\n    })\n  }\n\n  function createEditorView(element: HTMLDivElement, state: EditorState) {\n    const view = new EditorView({ mount: element }, {\n      state,\n      dispatchTransaction,\n    })\n    return view\n  }\n\n  function dispatchTransaction(transaction: Transaction) {\n    if (!editorRef.current) {\n      return\n    }\n    const editorState = editorRef.current.state.apply(transaction)\n    editorRef.current.updateState(editorState)\n    if (props.onEdit) {\n      props.onEdit(editorState)\n    }\n  }\n\n  return (\n    <div id=\"example-editor\" ref={editorViewRef} className={className}/>\n  )\n}\n","import React, { useMemo } from 'react'\nimport debounce from 'lodash.debounce'\n\nimport { EditorView } from 'prosemirror-view'\nimport { EditorState } from 'prosemirror-state'\nimport { applyDevTools as applyDevToolkit } from 'prosemirror-dev-toolkit'\nimport { applyDevTools } from 'prosemirror-dev-tools'\n\nimport { PMEditor } from 'pm/PMEditor'\n\nclass EditorStore {\n\n  view?: EditorView\n  currentEditorState?: {[key: string]: any}\n  localStorageKey: string\n\n  constructor(key: string) {\n    this.localStorageKey = key\n    if (typeof window !== 'undefined') {\n      const existing = localStorage.getItem(this.localStorageKey)\n      if (existing && existing !== null && existing.length > 0) {\n        let stored = JSON.parse(existing)\n        this.currentEditorState = stored\n      }\n    }\n  }\n\n  setEditorView = (view: EditorView) => {\n    this.view = view\n    if (this.currentEditorState) {\n      const state = EditorState.fromJSON(\n        {\n          schema: this.view.state.schema,\n          plugins: this.view.state.plugins,\n        },\n        this.currentEditorState\n      )\n      this.view.updateState(state)\n    }\n  }\n\n  syncCurrentEditorState = () => {\n    const newState = this.view!.state.toJSON()\n    localStorage.setItem(this.localStorageKey, JSON.stringify(newState))\n  }\n}\n\ninterface Props {\n  useDevTools?: boolean\n}\n\nexport function Editor(props: Props) {\n  const { useDevTools } = props\n  const editorStore = useMemo(() => new EditorStore(useDevTools ? 'dev-tools' : 'dev-toolkit'), [useDevTools])\n  const debouncedSync = useMemo(() => debounce(editorStore.syncCurrentEditorState, 250), [editorStore.syncCurrentEditorState])\n\n  function handleEdit() {\n    debouncedSync()\n  }\n  function handleEditorReady(view: EditorView) {\n    editorStore.setEditorView(view)\n    if (useDevTools) {\n      applyDevTools(view)\n    } else {\n      applyDevToolkit(view, {\n        devToolsExpanded: true,\n        buttonPosition: 'bottom-left',\n      })\n    }\n  }\n  return (\n    <PMEditor\n      onEdit={handleEdit}\n      onEditorReady={handleEditorReady}\n    />\n  )\n}\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport { Editor } from '../components/Editor'\n\nexport function FrontPage() {\n  return (\n    <Container>\n      <header>\n        <h1><a href=\"https://github.com/TeemuKoivisto/prosemirror-dev-toolkit\">prosemirror-dev-toolkit</a></h1>\n        <p>Github repo</p>\n        <p>An example React app with ProseMirror editor that uses dev-toolkit.</p>\n      </header>\n      <Editor/>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n\n`\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport { Editor } from '../components/Editor'\n\nexport function DevToolsPage() {\n  return (\n    <Container>\n      <header>\n        <h1><a href=\"https://github.com/d4rkr00t/prosemirror-dev-tools\">Original prosemirror-dev-tools</a></h1>\n        <p><a href=\"https://github.com/d4rkr00t/prosemirror-dev-tools\">Github repo</a></p>\n      </header>\n      <Editor useDevTools/>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n\n`\n","import * as React from 'react'\nimport { BrowserRouter, Redirect, Switch } from 'react-router-dom'\n\nimport { WrappedRoute } from './components/WrappedRoute'\n\nimport { FrontPage } from './pages/FrontPage'\nimport { DevToolsPage } from './pages/DevToolsPage'\n\nexport const Routes = () => (\n  <BrowserRouter basename={process.env.PUBLIC_URL}>\n    <Switch>\n      <WrappedRoute exact path=\"/\" component={FrontPage}/>\n      <WrappedRoute exact path=\"/dev-tools\" component={DevToolsPage}/>\n      <Redirect to=\"/\" />\n    </Switch>\n  </BrowserRouter>\n)\n","import * as React from 'react'\nimport { render } from 'react-dom'\n\nimport { Routes } from './routes'\n\nimport './index.css'\n\nrender(\n  <Routes />,\n  document.getElementById('root')\n)\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.0' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","import _typeof from \"@babel/runtime/helpers/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import { EditorView } from 'prosemirror-view'\nimport type { Node as PMNode } from 'prosemirror-model'\nimport { getContext as getCtx, setContext as setCtx } from 'svelte'\n\nimport { buildColors } from './tabs/structure/colors'\n\nexport type Contexts = {\n  'editor-view': {\n    view: EditorView\n  }\n  'doc-view': {\n    selected: {\n      type: string\n      start: number\n      end: number\n    }\n    colors: ReturnType<typeof buildColors>\n    handleNodeClick: (n: PMNode) => void\n  }\n}\n\nexport function setContext<K extends keyof Contexts>(ctx: K, val: Contexts[K]) {\n  return setCtx(ctx, val)\n}\n\nexport function getContext<K extends keyof Contexts>(ctx: K) {\n  return getCtx(ctx) as Contexts[K]\n}\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","<script lang=\"ts\">\n  import type { ButtonPosition } from '../types'\n\n  export let buttonPosition: ButtonPosition\n</script>\n\n<button class={`floating-btn ${buttonPosition}`} on:click>\n  <svg\n    width=\"530\"\n    height=\"530\"\n    viewBox=\"0 0 530 530\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n  >\n    <title>prosemirror</title>\n    <desc>Created using Figma</desc>\n    <use xlink:href=\"#a\" transform=\"matrix(2 0 0 2 118 116)\" fill=\"#FFF\" />\n    <use xlink:href=\"#b\" transform=\"rotate(16 59.054 420.192) scale(2)\" fill=\"#FFF\" />\n    <use xlink:href=\"#c\" transform=\"matrix(2 0 0 2 154.024 141.58)\" fill=\"#363755\" />\n    <use xlink:href=\"#d\" transform=\"matrix(2 0 0 2 220 334.8)\" fill=\"#FFF\" />\n    <use xlink:href=\"#e\" transform=\"matrix(2 0 0 2 218.826 262.052)\" fill=\"#363755\" />\n    <use xlink:href=\"#f\" transform=\"matrix(2 0 0 2 197.108 184.998)\" fill=\"#FFF\" />\n    <use xlink:href=\"#g\" transform=\"matrix(2 0 0 2 221.8 216)\" fill=\"#363755\" />\n    <defs>\n      <path\n        id=\"a\"\n        d=\"M73.5 0C32.859 0 0 32.859 0 73.5S32.859 147 73.5 147 147 114.141 147 73.5 114.069 0 73.5\n        0z\"\n      />\n      <path\n        id=\"b\"\n        d=\"M193.601 107.116c0-13.376 8.238-23.91\n        20.619-31.153-2.244-7.447-5.19-14.6-8.824-21.32-13.886\n        3.633-25.12-1.799-34.568-11.26-9.449-9.437-12.344-20.672-8.709-34.571A111.362 111.362 0 0 0\n        140.799 0c-7.243 12.37-20.339 20.594-33.689 20.594-13.363\n        0-26.446-8.225-33.701-20.594A110.888 110.888 0 0 0 52.1 8.812c3.634 13.9.753 25.134-8.721\n        34.57-9.436 9.462-20.67 14.894-34.569 11.26A112.178 112.178 0 0 0 0 75.963c12.369 7.243\n        20.593 17.777 20.593 31.153 0 13.352-8.224 26.448-20.593 33.704a113.338 113.338 0 0 0 8.811\n        21.321c13.899-3.634 25.133-.752 34.569 8.697 9.448 9.462 12.355 20.696 8.721 34.57a112.653\n        112.653 0 0 0 21.32 8.837c7.243-12.407 20.338-20.619 33.702-20.619 13.35 0 26.446 8.225\n        33.701 20.619a114.22 114.22 0 0 0 21.32-8.837c-3.634-13.874-.752-25.108 8.709-34.57\n        9.449-9.437 20.683-14.869 34.569-11.26a112.343 112.343 0 0 0\n        8.823-21.321c-12.406-7.256-20.644-17.789-20.644-31.141zm-86.491 46.57c-25.732\n        0-46.58-20.849-46.58-46.57 0-25.733 20.86-46.595 46.58-46.595 25.732 0 46.567 20.875 46.567\n        46.595 0 25.734-20.835 46.57-46.567 46.57z\"\n      />\n      <path\n        id=\"c\"\n        d=\"M98.088 49.91c-6.9 83.9 10.8 103.401 10.8 103.401s-55.1\n        5.499-82.7-13.401c-30.5-20.9-26-67.5-25.9-94.6.1-28.4 25.6-45.8 49.9-45.3 29.1.5 50.2 21.6\n        47.9 49.9z\"\n      />\n      <path\n        id=\"d\"\n        d=\"M.1.1c12.2 33.3 22.5 42.7 40 55.2 25.3 18 36.6 17.5 76.3 41C78.1 60.3 30.8 45.7 0 0l.1.1z\"\n      />\n      <path\n        id=\"e\"\n        d=\"M.687 36.474c3 13.3 17.9 29.9 30.4 41.6 24.8 23.2 42 22.4 86\n        54.7-18.2-51.8-18.8-62-43.5-106.1-24.7-44-67.6-20.3-67.6-20.3s-8.4 16.6-5.3 29.9v.2z\"\n      />\n      <path\n        id=\"f\"\n        d=\"M38.346 11.5s-4-11.6-18-11.5c-30 .2-28.8 52.1 16.9 52 39.6-.1 39.2-49.4\n        16.1-49.6-10.2-.2-15 9.1-15 9.1z\"\n      />\n      <path\n        id=\"g\"\n        d=\"M26.5 15c10.8 0 2 14.9-.6 20.9-1.8-8.4-10.2-20.9.6-20.9zM10.2.1C4.6.1 0 4.6 0 10.3c0 5.6\n        4.5 10.2 10.2 10.2 5.6 0 10.2-4.5 10.2-10.2C20.4 4.7 15.9.1 10.2.1zM40.7 0c-4.8 0-8.8\n        4.5-8.8 10.2 0 5.6 3.9 10.2 8.8 10.2 4.8 0 8.8-4.5 8.8-10.2C49.5 4.6 45.6 0 40.7 0z\"\n      />\n    </defs>\n  </svg>\n</button>\n\n<style lang=\"scss\">\n  .floating-btn {\n    background: var(--color-blue-bg);\n    border: 0;\n    border-radius: 50%;\n    box-shadow: 0 0 30px rgba($color-black, 0.3);\n    cursor: pointer;\n    position: fixed;\n    padding: 6px;\n    transition: opacity 0.3s;\n    -webkit-transition: opacity 0.3s;\n    z-index: 99999;\n  }\n  .floating-btn.bottom-right {\n    bottom: 16px;\n    right: 16px;\n  }\n  .floating-btn.bottom-left {\n    bottom: 16px;\n    left: 16px;\n  }\n  .floating-btn.top-right {\n    top: 16px;\n    right: 16px;\n  }\n  .floating-btn.top-left {\n    top: 16px;\n    left: 16px;\n  }\n  .floating-btn:hover {\n    opacity: 0.7;\n  }\n  .floating-btn > svg {\n    display: block;\n    width: 34px;\n    height: 34px;\n    position: relative;\n  }\n</style>\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import type { EditorView } from 'prosemirror-view'\nimport type { EditorState } from 'prosemirror-state'\nimport { get, writable } from 'svelte/store'\n\nimport type { Snapshot } from '$typings/snapshots'\nimport { Schema } from 'prosemirror-model'\n\nconst SNAPSHOTS_KEY = '__prosemirror-dev-toolkit__snapshots'\n\nexport const snapshots = writable<Snapshot[]>([])\nexport const selectedSnapshot = writable<Snapshot | undefined>()\nexport const previousEditorState = writable<EditorState | undefined>()\n\nconst persisted = typeof window !== 'undefined' ? localStorage.getItem(SNAPSHOTS_KEY) : null\nif (persisted && persisted.length > 0) {\n  try {\n    const parsed = JSON.parse(persisted)\n    snapshots.set(parsed)\n  } catch (err) {\n    console.error('Corrupted snapshots values in localStorage', err)\n  }\n}\n\nsnapshots.subscribe(val => {\n  if (typeof window !== 'undefined') {\n    localStorage.setItem(SNAPSHOTS_KEY, JSON.stringify(val))\n  }\n})\n\nfunction setEditorDoc(view: EditorView, doc: { [key: string]: any }) {\n  // Hack to use EditorState.create without explicitly calling EditorState, thus\n  // avoiding having to include it as a dependency\n  const newState = Object.getPrototypeOf(view.state).constructor.create({\n    schema: view.state.schema,\n    plugins: view.state.plugins,\n    doc: view.state.schema.nodeFromJSON(doc)\n  })\n  view.updateState(newState)\n}\n\nexport function saveSnapshot(snapshotName: string, doc: { [key: string]: any }) {\n  const snap: Snapshot = {\n    name: snapshotName,\n    timestamp: Date.now(),\n    doc\n  }\n  snapshots.update(val => [snap, ...val])\n}\n\nexport function importSnapshot(\n  snapshotName: string,\n  json: { [key: string]: unknown },\n  schema: Schema\n) {\n  const doc = schema.nodeFromJSON(json)\n  const snap: Snapshot = {\n    name: snapshotName,\n    timestamp: Date.now(),\n    doc: doc.toJSON()\n  }\n  snapshots.update(val => [snap, ...val])\n}\n\nexport function updateSnapshot(snapshot: Snapshot) {\n  snapshots.update(val =>\n    val.map(s => {\n      if (s.timestamp === snapshot.timestamp) {\n        return snapshot\n      }\n      return s\n    })\n  )\n}\n\nexport function toggleViewSnapshot(view: EditorView, snap?: Snapshot) {\n  if (snap) {\n    const prevState = get(previousEditorState)\n    if (!prevState) previousEditorState.set(view.state)\n    setEditorDoc(view, snap.doc)\n  } else {\n    const prevState = get(previousEditorState)\n    if (!prevState) {\n      console.error('No previous state to restore!')\n    } else {\n      view.updateState(prevState)\n    }\n    previousEditorState.set(undefined)\n  }\n  selectedSnapshot.set(snap)\n}\n\nexport function restoreSnapshot(view: EditorView, snap: Snapshot) {\n  setEditorDoc(view, snap.doc)\n  previousEditorState.set(undefined)\n  selectedSnapshot.set(undefined)\n}\n\nexport function exportSnapshot(snapshot: Snapshot) {\n  const a = document.createElement('a')\n  const file = new Blob([JSON.stringify(snapshot.doc)], { type: 'application/json' })\n  a.href = URL.createObjectURL(file)\n  a.download = `${snapshot.name}.json`\n  a.click()\n}\n\nexport function deleteSnapshot(snapshot: Snapshot) {\n  snapshots.update(val => val.filter(s => s.timestamp !== snapshot.timestamp))\n  const selected = get(selectedSnapshot)\n  if (selected?.timestamp === snapshot.timestamp) {\n    selectedSnapshot.set(undefined)\n  }\n}\n","<script lang=\"ts\">\n  export let active: string, onClickTab: (tab: string) => void\n</script>\n\n<ul class=\"tabs-menu\">\n  <li>\n    <button class:active={active === 'state'} on:click={() => onClickTab('state')}>STATE</button>\n  </li>\n  <li>\n    <button class:active={active === 'history'} on:click={() => onClickTab('history')}\n      >HISTORY</button\n    >\n  </li>\n  <li>\n    <button class:active={active === 'plugins'} on:click={() => onClickTab('plugins')}\n      >PLUGINS</button\n    >\n  </li>\n  <li>\n    <button class:active={active === 'schema'} on:click={() => onClickTab('schema')}>SCHEMA</button>\n  </li>\n  <li>\n    <button class:active={active === 'structure'} on:click={() => onClickTab('structure')}\n      >STRUCTURE</button\n    >\n  </li>\n  <li>\n    <button class:active={active === 'snapshots'} on:click={() => onClickTab('snapshots')}\n      >SNAPSHOTS</button\n    >\n  </li>\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    display: flex;\n    list-style: none;\n    margin: 0;\n    overflow-x: scroll;\n    padding: 0;\n  }\n  button {\n    background: transparent;\n    border: 0;\n    border-bottom: 2px solid transparent;\n    color: var(--color-white);\n    cursor: pointer;\n    height: 100%;\n    padding: 1em;\n    &:hover {\n      background: rgba($color-white, 0.05);\n    }\n    &.active {\n      border-bottom: 2px solid var(--color-red-light);\n    }\n  }\n</style>\n","import OrderedMap from 'orderedmap';\n\nfunction findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      { return a.childCount == b.childCount ? null : pos }\n\n    var childA = a.child(i), childB = b.child(i);\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) { return pos }\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++)\n        { pos++; }\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) { return inner }\n    }\n    pos += childA.nodeSize;\n  }\n}\n\nfunction findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      { return iA == iB ? null : {a: posA, b: posB} }\n\n    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size; posB -= size;\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--;\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) { return inner }\n    }\n    posA -= size; posB -= size;\n  }\n}\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nvar Fragment = function Fragment(content, size) {\n  this.content = content;\n  // :: number\n  // The size of the fragment, which is the total of the size of its\n  // content nodes.\n  this.size = size || 0;\n  if (size == null) { for (var i = 0; i < content.length; i++)\n    { this.size += content[i].nodeSize; } }\n};\n\nvar prototypeAccessors = { firstChild: { configurable: true },lastChild: { configurable: true },childCount: { configurable: true } };\n\n// :: (number, number, (node: Node, start: number, parent: Node, index: number)  ?bool, ?number)\n// Invoke a callback for all descendant nodes between the given two\n// positions (relative to start of this fragment). Doesn't descend\n// into a node when the callback returns `false`.\nFragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {\n    if ( nodeStart === void 0 ) nodeStart = 0;\n\n  for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n      var start = pos + 1;\n      child.nodesBetween(Math.max(0, from - start),\n                         Math.min(child.content.size, to - start),\n                         f, nodeStart + start);\n    }\n    pos = end;\n  }\n};\n\n// :: ((node: Node, pos: number, parent: Node)  ?bool)\n// Call the given callback for every descendant node. The callback\n// may return `false` to prevent traversal of a given node's children.\nFragment.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.size, f);\n};\n\n// :: (number, number, ?string, ?string | ?(leafNode: Node) -> string)  string\n// Extract the text between `from` and `to`. See the same method on\n// [`Node`](#model.Node.textBetween).\nFragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  var text = \"\", separated = true;\n  this.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += typeof leafText === 'function' ? leafText(node): leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text\n};\n\n// :: (Fragment)  Fragment\n// Create a new fragment containing the combined content of this\n// fragment and the other.\nFragment.prototype.append = function append (other) {\n  if (!other.size) { return this }\n  if (!this.size) { return other }\n  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n  if (last.isText && last.sameMarkup(first)) {\n    content[content.length - 1] = last.withText(last.text + first.text);\n    i = 1;\n  }\n  for (; i < other.content.length; i++) { content.push(other.content[i]); }\n  return new Fragment(content, this.size + other.size)\n};\n\n// :: (number, ?number)  Fragment\n// Cut out the sub-fragment between the two given positions.\nFragment.prototype.cut = function cut (from, to) {\n  if (to == null) { to = this.size; }\n  if (from == 0 && to == this.size) { return this }\n  var result = [], size = 0;\n  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from) {\n      if (pos < from || end > to) {\n        if (child.isText)\n          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }\n        else\n          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }\n      }\n      result.push(child);\n      size += child.nodeSize;\n    }\n    pos = end;\n  } }\n  return new Fragment(result, size)\n};\n\nFragment.prototype.cutByIndex = function cutByIndex (from, to) {\n  if (from == to) { return Fragment.empty }\n  if (from == 0 && to == this.content.length) { return this }\n  return new Fragment(this.content.slice(from, to))\n};\n\n// :: (number, Node)  Fragment\n// Create a new fragment in which the node at the given index is\n// replaced by the given node.\nFragment.prototype.replaceChild = function replaceChild (index, node) {\n  var current = this.content[index];\n  if (current == node) { return this }\n  var copy = this.content.slice();\n  var size = this.size + node.nodeSize - current.nodeSize;\n  copy[index] = node;\n  return new Fragment(copy, size)\n};\n\n// : (Node)  Fragment\n// Create a new fragment by prepending the given node to this\n// fragment.\nFragment.prototype.addToStart = function addToStart (node) {\n  return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n};\n\n// : (Node)  Fragment\n// Create a new fragment by appending the given node to this\n// fragment.\nFragment.prototype.addToEnd = function addToEnd (node) {\n  return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n};\n\n// :: (Fragment)  bool\n// Compare this fragment to another one.\nFragment.prototype.eq = function eq (other) {\n  if (this.content.length != other.content.length) { return false }\n  for (var i = 0; i < this.content.length; i++)\n    { if (!this.content[i].eq(other.content[i])) { return false } }\n  return true\n};\n\n// :: ?Node\n// The first child of the fragment, or `null` if it is empty.\nprototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };\n\n// :: ?Node\n// The last child of the fragment, or `null` if it is empty.\nprototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };\n\n// :: number\n// The number of child nodes in this fragment.\nprototypeAccessors.childCount.get = function () { return this.content.length };\n\n// :: (number)  Node\n// Get the child node at the given index. Raise an error when the\n// index is out of range.\nFragment.prototype.child = function child (index) {\n  var found = this.content[index];\n  if (!found) { throw new RangeError(\"Index \" + index + \" out of range for \" + this) }\n  return found\n};\n\n// :: (number)  ?Node\n// Get the child node at the given index, if it exists.\nFragment.prototype.maybeChild = function maybeChild (index) {\n  return this.content[index]\n};\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nFragment.prototype.forEach = function forEach (f) {\n  for (var i = 0, p = 0; i < this.content.length; i++) {\n    var child = this.content[i];\n    f(child, p, i);\n    p += child.nodeSize;\n  }\n};\n\n// :: (Fragment)  ?number\n// Find the first position at which this fragment and another\n// fragment differ, or `null` if they are the same.\nFragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {\n    if ( pos === void 0 ) pos = 0;\n\n  return findDiffStart(this, other, pos)\n};\n\n// :: (Fragment)  ?{a: number, b: number}\n// Find the first position, searching from the end, at which this\n// fragment and the given fragment differ, or `null` if they are the\n// same. Since this position will not be the same in both nodes, an\n// object with two separate positions is returned.\nFragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {\n    if ( pos === void 0 ) pos = this.size;\n    if ( otherPos === void 0 ) otherPos = other.size;\n\n  return findDiffEnd(this, other, pos, otherPos)\n};\n\n// : (number, ?number)  {index: number, offset: number}\n// Find the index and inner offset corresponding to a given relative\n// position in this fragment. The result object will be reused\n// (overwritten) the next time the function is called. (Not public.)\nFragment.prototype.findIndex = function findIndex (pos, round) {\n    if ( round === void 0 ) round = -1;\n\n  if (pos == 0) { return retIndex(0, pos) }\n  if (pos == this.size) { return retIndex(this.content.length, pos) }\n  if (pos > this.size || pos < 0) { throw new RangeError((\"Position \" + pos + \" outside of fragment (\" + (this) + \")\")) }\n  for (var i = 0, curPos = 0;; i++) {\n    var cur = this.child(i), end = curPos + cur.nodeSize;\n    if (end >= pos) {\n      if (end == pos || round > 0) { return retIndex(i + 1, end) }\n      return retIndex(i, curPos)\n    }\n    curPos = end;\n  }\n};\n\n// :: ()  string\n// Return a debugging string that describes this fragment.\nFragment.prototype.toString = function toString () { return \"<\" + this.toStringInner() + \">\" };\n\nFragment.prototype.toStringInner = function toStringInner () { return this.content.join(\", \") };\n\n// :: ()  ?Object\n// Create a JSON-serializeable representation of this fragment.\nFragment.prototype.toJSON = function toJSON () {\n  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null\n};\n\n// :: (Schema, ?Object)  Fragment\n// Deserialize a fragment from its JSON representation.\nFragment.fromJSON = function fromJSON (schema, value) {\n  if (!value) { return Fragment.empty }\n  if (!Array.isArray(value)) { throw new RangeError(\"Invalid input for Fragment.fromJSON\") }\n  return new Fragment(value.map(schema.nodeFromJSON))\n};\n\n// :: ([Node])  Fragment\n// Build a fragment from an array of nodes. Ensures that adjacent\n// text nodes with the same marks are joined together.\nFragment.fromArray = function fromArray (array) {\n  if (!array.length) { return Fragment.empty }\n  var joined, size = 0;\n  for (var i = 0; i < array.length; i++) {\n    var node = array[i];\n    size += node.nodeSize;\n    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n      if (!joined) { joined = array.slice(0, i); }\n      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n    } else if (joined) {\n      joined.push(node);\n    }\n  }\n  return new Fragment(joined || array, size)\n};\n\n// :: (?union<Fragment, Node, [Node]>)  Fragment\n// Create a fragment from something that can be interpreted as a set\n// of nodes. For `null`, it returns the empty fragment. For a\n// fragment, the fragment itself. For a node or array of nodes, a\n// fragment containing those nodes.\nFragment.from = function from (nodes) {\n  if (!nodes) { return Fragment.empty }\n  if (nodes instanceof Fragment) { return nodes }\n  if (Array.isArray(nodes)) { return this.fromArray(nodes) }\n  if (nodes.attrs) { return new Fragment([nodes], nodes.nodeSize) }\n  throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                       (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n};\n\nObject.defineProperties( Fragment.prototype, prototypeAccessors );\n\nvar found = {index: 0, offset: 0};\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0);\n\nfunction compareDeep(a, b) {\n  if (a === b) { return true }\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) { return false }\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) { return false }\n  if (array) {\n    if (a.length != b.length) { return false }\n    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }\n  } else {\n    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }\n    for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  }\n  return true\n}\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nvar Mark = function Mark(type, attrs) {\n  // :: MarkType\n  // The type of this mark.\n  this.type = type;\n  // :: Object\n  // The attributes associated with this mark.\n  this.attrs = attrs;\n};\n\n// :: ([Mark])  [Mark]\n// Given a set of marks, create a new set which contains this one as\n// well, in the right position. If this mark is already in the set,\n// the set itself is returned. If any marks that are set to be\n// [exclusive](#model.MarkSpec.excludes) with this mark are present,\n// those are replaced by this one.\nMark.prototype.addToSet = function addToSet (set) {\n  var copy, placed = false;\n  for (var i = 0; i < set.length; i++) {\n    var other = set[i];\n    if (this.eq(other)) { return set }\n    if (this.type.excludes(other.type)) {\n      if (!copy) { copy = set.slice(0, i); }\n    } else if (other.type.excludes(this.type)) {\n      return set\n    } else {\n      if (!placed && other.type.rank > this.type.rank) {\n        if (!copy) { copy = set.slice(0, i); }\n        copy.push(this);\n        placed = true;\n      }\n      if (copy) { copy.push(other); }\n    }\n  }\n  if (!copy) { copy = set.slice(); }\n  if (!placed) { copy.push(this); }\n  return copy\n};\n\n// :: ([Mark])  [Mark]\n// Remove this mark from the given set, returning a new set. If this\n// mark is not in the set, the set itself is returned.\nMark.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i]))\n      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n  return set\n};\n\n// :: ([Mark])  bool\n// Test whether this mark is in the given set of marks.\nMark.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i])) { return true } }\n  return false\n};\n\n// :: (Mark)  bool\n// Test whether this mark has the same type and attributes as\n// another mark.\nMark.prototype.eq = function eq (other) {\n  return this == other ||\n    (this.type == other.type && compareDeep(this.attrs, other.attrs))\n};\n\n// :: ()  Object\n// Convert this mark to a JSON-serializeable representation.\nMark.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  return obj\n};\n\n// :: (Schema, Object)  Mark\nMark.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Mark.fromJSON\") }\n  var type = schema.marks[json.type];\n  if (!type) { throw new RangeError((\"There is no mark type \" + (json.type) + \" in this schema\")) }\n  return type.create(json.attrs)\n};\n\n// :: ([Mark], [Mark])  bool\n// Test whether two sets of marks are identical.\nMark.sameSet = function sameSet (a, b) {\n  if (a == b) { return true }\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++)\n    { if (!a[i].eq(b[i])) { return false } }\n  return true\n};\n\n// :: (?union<Mark, [Mark]>)  [Mark]\n// Create a properly sorted mark set from null, a single mark, or an\n// unsorted array of marks.\nMark.setFrom = function setFrom (marks) {\n  if (!marks || marks.length == 0) { return Mark.none }\n  if (marks instanceof Mark) { return [marks] }\n  var copy = marks.slice();\n  copy.sort(function (a, b) { return a.type.rank - b.type.rank; });\n  return copy\n};\n\n// :: [Mark] The empty set of marks.\nMark.none = [];\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nfunction ReplaceError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = ReplaceError.prototype;\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype);\nReplaceError.prototype.constructor = ReplaceError;\nReplaceError.prototype.name = \"ReplaceError\";\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are open (cut through).\nvar Slice = function Slice(content, openStart, openEnd) {\n  // :: Fragment The slice's content.\n  this.content = content;\n  // :: number The open depth at the start.\n  this.openStart = openStart;\n  // :: number The open depth at the end.\n  this.openEnd = openEnd;\n};\n\nvar prototypeAccessors$1 = { size: { configurable: true } };\n\n// :: number\n// The size this slice would add when inserted into a document.\nprototypeAccessors$1.size.get = function () {\n  return this.content.size - this.openStart - this.openEnd\n};\n\nSlice.prototype.insertAt = function insertAt (pos, fragment) {\n  var content = insertInto(this.content, pos + this.openStart, fragment, null);\n  return content && new Slice(content, this.openStart, this.openEnd)\n};\n\nSlice.prototype.removeBetween = function removeBetween (from, to) {\n  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n};\n\n// :: (Slice)  bool\n// Tests whether this slice is equal to another slice.\nSlice.prototype.eq = function eq (other) {\n  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n};\n\nSlice.prototype.toString = function toString () {\n  return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n};\n\n// :: ()  ?Object\n// Convert a slice to a JSON-serializable representation.\nSlice.prototype.toJSON = function toJSON () {\n  if (!this.content.size) { return null }\n  var json = {content: this.content.toJSON()};\n  if (this.openStart > 0) { json.openStart = this.openStart; }\n  if (this.openEnd > 0) { json.openEnd = this.openEnd; }\n  return json\n};\n\n// :: (Schema, ?Object)  Slice\n// Deserialize a slice from its JSON representation.\nSlice.fromJSON = function fromJSON (schema, json) {\n  if (!json) { return Slice.empty }\n  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n  if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n    { throw new RangeError(\"Invalid input for Slice.fromJSON\") }\n  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n};\n\n// :: (Fragment, ?bool)  Slice\n// Create a slice from a fragment by taking the maximum possible\n// open value on both side of the fragment.\nSlice.maxOpen = function maxOpen (fragment, openIsolating) {\n    if ( openIsolating === void 0 ) openIsolating=true;\n\n  var openStart = 0, openEnd = 0;\n  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }\n  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }\n  return new Slice(fragment, openStart, openEnd)\n};\n\nObject.defineProperties( Slice.prototype, prototypeAccessors$1 );\n\nfunction removeRange(content, from, to) {\n  var ref = content.findIndex(from);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  var ref$1 = content.findIndex(to);\n  var indexTo = ref$1.index;\n  var offsetTo = ref$1.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError(\"Removing non-flat range\") }\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) { throw new RangeError(\"Removing non-flat range\") }\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var ref = content.findIndex(dist);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) { return null }\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0);\n\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    { throw new ReplaceError(\"Inserted content deeper than insertion position\") }\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    { throw new ReplaceError(\"Inconsistent open depths\") }\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth), node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    var parent = $from.parent, content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    var ref = prepareSliceForReplace(slice, $from);\n    var start = ref.start;\n    var end = ref.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    { throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name) }\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    { target[last] = child.withText(target[last].text + child.text); }\n  else\n    { target.push(child); }\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }\n  if ($end && $end.depth == depth && $end.textOffset)\n    { addNode($end.nodeBefore, target); }\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    { throw new ReplaceError(\"Invalid content for node \" + node.type.name) }\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart)\n      { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }\n    addRange($start, $end, depth, content);\n    if (openEnd)\n      { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart, parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--)\n    { node = $along.node(i).copy(Fragment.from(node)); }\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nvar ResolvedPos = function ResolvedPos(pos, path, parentOffset) {\n  // :: number The position that was resolved.\n  this.pos = pos;\n  this.path = path;\n  // :: number\n  // The number of levels the parent node is from the root. If this\n  // position points directly into the root node, it is 0. If it\n  // points into a top-level paragraph, 1, and so on.\n  this.depth = path.length / 3 - 1;\n  // :: number The offset this position has into its parent node.\n  this.parentOffset = parentOffset;\n};\n\nvar prototypeAccessors$2 = { parent: { configurable: true },doc: { configurable: true },textOffset: { configurable: true },nodeAfter: { configurable: true },nodeBefore: { configurable: true } };\n\nResolvedPos.prototype.resolveDepth = function resolveDepth (val) {\n  if (val == null) { return this.depth }\n  if (val < 0) { return this.depth + val }\n  return val\n};\n\n// :: Node\n// The parent node that the position points into. Note that even if\n// a position points into a text node, that node is not considered\n// the parenttext nodes are flat in this model, and have no content.\nprototypeAccessors$2.parent.get = function () { return this.node(this.depth) };\n\n// :: Node\n// The root node in which the position was resolved.\nprototypeAccessors$2.doc.get = function () { return this.node(0) };\n\n// :: (?number)  Node\n// The ancestor node at the given level. `p.node(p.depth)` is the\n// same as `p.parent`.\nResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };\n\n// :: (?number)  number\n// The index into the ancestor at the given level. If this points at\n// the 3rd node in the 2nd paragraph on the top level, for example,\n// `p.index(0)` is 1 and `p.index(1)` is 2.\nResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };\n\n// :: (?number)  number\n// The index pointing after this position into the ancestor at the\n// given level.\nResolvedPos.prototype.indexAfter = function indexAfter (depth) {\n  depth = this.resolveDepth(depth);\n  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n};\n\n// :: (?number)  number\n// The (absolute) position at the start of the node at the given\n// level.\nResolvedPos.prototype.start = function start (depth) {\n  depth = this.resolveDepth(depth);\n  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n};\n\n// :: (?number)  number\n// The (absolute) position at the end of the node at the given\n// level.\nResolvedPos.prototype.end = function end (depth) {\n  depth = this.resolveDepth(depth);\n  return this.start(depth) + this.node(depth).content.size\n};\n\n// :: (?number)  number\n// The (absolute) position directly before the wrapping node at the\n// given level, or, when `depth` is `this.depth + 1`, the original\n// position.\nResolvedPos.prototype.before = function before (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position before the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n};\n\n// :: (?number)  number\n// The (absolute) position directly after the wrapping node at the\n// given level, or the original position when `depth` is `this.depth + 1`.\nResolvedPos.prototype.after = function after (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position after the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n};\n\n// :: number\n// When this position points into a text node, this returns the\n// distance between the position and the start of the text node.\n// Will be zero for positions that point between nodes.\nprototypeAccessors$2.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };\n\n// :: ?Node\n// Get the node directly after the position, if any. If the position\n// points into a text node, only the part of that node after the\n// position is returned.\nprototypeAccessors$2.nodeAfter.get = function () {\n  var parent = this.parent, index = this.index(this.depth);\n  if (index == parent.childCount) { return null }\n  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n  return dOff ? parent.child(index).cut(dOff) : child\n};\n\n// :: ?Node\n// Get the node directly before the position, if any. If the\n// position points into a text node, only the part of that node\n// before the position is returned.\nprototypeAccessors$2.nodeBefore.get = function () {\n  var index = this.index(this.depth);\n  var dOff = this.pos - this.path[this.path.length - 1];\n  if (dOff) { return this.parent.child(index).cut(0, dOff) }\n  return index == 0 ? null : this.parent.child(index - 1)\n};\n\n// :: (number, ?number)  number\n// Get the position at the given index in the parent node at the\n// given depth (which defaults to `this.depth`).\nResolvedPos.prototype.posAtIndex = function posAtIndex (index, depth) {\n  depth = this.resolveDepth(depth);\n  var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n  for (var i = 0; i < index; i++) { pos += node.child(i).nodeSize; }\n  return pos\n};\n\n// :: ()  [Mark]\n// Get the marks at this position, factoring in the surrounding\n// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n// position is at the start of a non-empty node, the marks of the\n// node after it (if any) are returned.\nResolvedPos.prototype.marks = function marks () {\n  var parent = this.parent, index = this.index();\n\n  // In an empty parent, return the empty array\n  if (parent.content.size == 0) { return Mark.none }\n\n  // When inside a text node, just return the text node's marks\n  if (this.textOffset) { return parent.child(index).marks }\n\n  var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n  // If the `after` flag is true of there is no node before, make\n  // the node after this position the main reference.\n  if (!main) { var tmp = main; main = other; other = tmp; }\n\n  // Use all marks in the main node, except those that have\n  // `inclusive` set to false and are not present in the other node.\n  var marks = main.marks;\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n\n  return marks\n};\n\n// :: (ResolvedPos)  ?[Mark]\n// Get the marks after the current position, if any, except those\n// that are non-inclusive and not present at position `$end`. This\n// is mostly useful for getting the set of marks to preserve after a\n// deletion. Will return `null` if this position is at the end of\n// its parent node or its parent node isn't a textblock (in which\n// case no marks should be preserved).\nResolvedPos.prototype.marksAcross = function marksAcross ($end) {\n  var after = this.parent.maybeChild(this.index());\n  if (!after || !after.isInline) { return null }\n\n  var marks = after.marks, next = $end.parent.maybeChild($end.index());\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n  return marks\n};\n\n// :: (number)  number\n// The depth up to which this position and the given (non-resolved)\n// position share the same parent nodes.\nResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {\n  for (var depth = this.depth; depth > 0; depth--)\n    { if (this.start(depth) <= pos && this.end(depth) >= pos) { return depth } }\n  return 0\n};\n\n// :: (?ResolvedPos, ?(Node)  bool)  ?NodeRange\n// Returns a range based on the place where this position and the\n// given position diverge around block content. If both point into\n// the same textblock, for example, a range around that textblock\n// will be returned. If they point into different blocks, the range\n// around those blocks in their shared ancestor is returned. You can\n// pass in an optional predicate that will be called with a parent\n// node to see if a range into that parent is acceptable.\nResolvedPos.prototype.blockRange = function blockRange (other, pred) {\n    if ( other === void 0 ) other = this;\n\n  if (other.pos < this.pos) { return other.blockRange(this) }\n  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n    { if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n      { return new NodeRange(this, other, d) } }\n};\n\n// :: (ResolvedPos)  bool\n// Query whether the given position shares the same parent node.\nResolvedPos.prototype.sameParent = function sameParent (other) {\n  return this.pos - this.parentOffset == other.pos - other.parentOffset\n};\n\n// :: (ResolvedPos)  ResolvedPos\n// Return the greater of this and the given position.\nResolvedPos.prototype.max = function max (other) {\n  return other.pos > this.pos ? other : this\n};\n\n// :: (ResolvedPos)  ResolvedPos\n// Return the smaller of this and the given position.\nResolvedPos.prototype.min = function min (other) {\n  return other.pos < this.pos ? other : this\n};\n\nResolvedPos.prototype.toString = function toString () {\n  var str = \"\";\n  for (var i = 1; i <= this.depth; i++)\n    { str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1); }\n  return str + \":\" + this.parentOffset\n};\n\nResolvedPos.resolve = function resolve (doc, pos) {\n  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError(\"Position \" + pos + \" out of range\") }\n  var path = [];\n  var start = 0, parentOffset = pos;\n  for (var node = doc;;) {\n    var ref = node.content.findIndex(parentOffset);\n      var index = ref.index;\n      var offset = ref.offset;\n    var rem = parentOffset - offset;\n    path.push(node, index, start + offset);\n    if (!rem) { break }\n    node = node.child(index);\n    if (node.isText) { break }\n    parentOffset = rem - 1;\n    start += offset + 1;\n  }\n  return new ResolvedPos(pos, path, parentOffset)\n};\n\nResolvedPos.resolveCached = function resolveCached (doc, pos) {\n  for (var i = 0; i < resolveCache.length; i++) {\n    var cached = resolveCache[i];\n    if (cached.pos == pos && cached.doc == doc) { return cached }\n  }\n  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n  return result\n};\n\nObject.defineProperties( ResolvedPos.prototype, prototypeAccessors$2 );\n\nvar resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nvar NodeRange = function NodeRange($from, $to, depth) {\n  // :: ResolvedPos A resolved position along the start of the\n  // content. May have a `depth` greater than this object's `depth`\n  // property, since these are the positions that were used to\n  // compute the range, not re-resolved positions directly at its\n  // boundaries.\n  this.$from = $from;\n  // :: ResolvedPos A position along the end of the content. See\n  // caveat for [`$from`](#model.NodeRange.$from).\n  this.$to = $to;\n  // :: number The depth of the node that this range points into.\n  this.depth = depth;\n};\n\nvar prototypeAccessors$1$1 = { start: { configurable: true },end: { configurable: true },parent: { configurable: true },startIndex: { configurable: true },endIndex: { configurable: true } };\n\n// :: number The position at the start of the range.\nprototypeAccessors$1$1.start.get = function () { return this.$from.before(this.depth + 1) };\n// :: number The position at the end of the range.\nprototypeAccessors$1$1.end.get = function () { return this.$to.after(this.depth + 1) };\n\n// :: Node The parent node that the range points into.\nprototypeAccessors$1$1.parent.get = function () { return this.$from.node(this.depth) };\n// :: number The start index of the range in the parent node.\nprototypeAccessors$1$1.startIndex.get = function () { return this.$from.index(this.depth) };\n// :: number The end index of the range in the parent node.\nprototypeAccessors$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };\n\nObject.defineProperties( NodeRange.prototype, prototypeAccessors$1$1 );\n\nvar emptyAttrs = Object.create(null);\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nvar Node = function Node(type, attrs, content, marks) {\n  // :: NodeType\n  // The type of node that this is.\n  this.type = type;\n\n  // :: Object\n  // An object mapping attribute names to values. The kind of\n  // attributes allowed and required are\n  // [determined](#model.NodeSpec.attrs) by the node type.\n  this.attrs = attrs;\n\n  // :: Fragment\n  // A container holding the node's children.\n  this.content = content || Fragment.empty;\n\n  // :: [Mark]\n  // The marks (things like whether it is emphasized or part of a\n  // link) applied to this node.\n  this.marks = marks || Mark.none;\n};\n\nvar prototypeAccessors$3 = { nodeSize: { configurable: true },childCount: { configurable: true },textContent: { configurable: true },firstChild: { configurable: true },lastChild: { configurable: true },isBlock: { configurable: true },isTextblock: { configurable: true },inlineContent: { configurable: true },isInline: { configurable: true },isText: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };\n\n// text:: ?string\n// For text nodes, this contains the node's text content.\n\n// :: number\n// The size of this node, as defined by the integer-based [indexing\n// scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n// amount of characters. For other leaf nodes, it is one. For\n// non-leaf nodes, it is the size of the content plus two (the start\n// and end token).\nprototypeAccessors$3.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };\n\n// :: number\n// The number of children that the node has.\nprototypeAccessors$3.childCount.get = function () { return this.content.childCount };\n\n// :: (number)  Node\n// Get the child node at the given index. Raises an error when the\n// index is out of range.\nNode.prototype.child = function child (index) { return this.content.child(index) };\n\n// :: (number)  ?Node\n// Get the child node at the given index, if it exists.\nNode.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nNode.prototype.forEach = function forEach (f) { this.content.forEach(f); };\n\n// :: (number, number, (node: Node, pos: number, parent: Node, index: number)  ?bool, ?number)\n// Invoke a callback for all descendant nodes recursively between\n// the given two positions that are relative to start of this node's\n// content. The callback is invoked with the node, its\n// parent-relative position, its parent node, and its child index.\n// When the callback returns false for a given node, that node's\n// children will not be recursed over. The last parameter can be\n// used to specify a starting position to count from.\nNode.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {\n    if ( startPos === void 0 ) startPos = 0;\n\n  this.content.nodesBetween(from, to, f, startPos, this);\n};\n\n// :: ((node: Node, pos: number, parent: Node)  ?bool)\n// Call the given callback for every descendant node. Doesn't\n// descend into a node when the callback returns `false`.\nNode.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.content.size, f);\n};\n\n// :: string\n// Concatenates all the text nodes found in this fragment and its\n// children.\nprototypeAccessors$3.textContent.get = function () { return this.textBetween(0, this.content.size, \"\") };\n\n// :: (number, number, ?string, ?string | ?(leafNode: Node) -> string)  string\n// Get all text between positions `from` and `to`. When\n// `blockSeparator` is given, it will be inserted whenever a new\n// block node is started. When `leafText` is given, it'll be\n// inserted for every non-text leaf node encountered.\nNode.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  return this.content.textBetween(from, to, blockSeparator, leafText)\n};\n\n// :: ?Node\n// Returns this node's first child, or `null` if there are no\n// children.\nprototypeAccessors$3.firstChild.get = function () { return this.content.firstChild };\n\n// :: ?Node\n// Returns this node's last child, or `null` if there are no\n// children.\nprototypeAccessors$3.lastChild.get = function () { return this.content.lastChild };\n\n// :: (Node)  bool\n// Test whether two nodes represent the same piece of document.\nNode.prototype.eq = function eq (other) {\n  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n};\n\n// :: (Node)  bool\n// Compare the markup (type, attributes, and marks) of this node to\n// those of another. Returns `true` if both have the same markup.\nNode.prototype.sameMarkup = function sameMarkup (other) {\n  return this.hasMarkup(other.type, other.attrs, other.marks)\n};\n\n// :: (NodeType, ?Object, ?[Mark])  bool\n// Check whether this node's markup correspond to the given type,\n// attributes, and marks.\nNode.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {\n  return this.type == type &&\n    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n    Mark.sameSet(this.marks, marks || Mark.none)\n};\n\n// :: (?Fragment)  Node\n// Create a new node with the same markup as this node, containing\n// the given content (or empty, if no content is given).\nNode.prototype.copy = function copy (content) {\n    if ( content === void 0 ) content = null;\n\n  if (content == this.content) { return this }\n  return new this.constructor(this.type, this.attrs, content, this.marks)\n};\n\n// :: ([Mark])  Node\n// Create a copy of this node, with the given set of marks instead\n// of the node's own marks.\nNode.prototype.mark = function mark (marks) {\n  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n};\n\n// :: (number, ?number)  Node\n// Create a copy of this node with only the content between the\n// given positions. If `to` is not given, it defaults to the end of\n// the node.\nNode.prototype.cut = function cut (from, to) {\n  if (from == 0 && to == this.content.size) { return this }\n  return this.copy(this.content.cut(from, to))\n};\n\n// :: (number, ?number)  Slice\n// Cut out the part of the document between the given positions, and\n// return it as a `Slice` object.\nNode.prototype.slice = function slice (from, to, includeParents) {\n    if ( to === void 0 ) to = this.content.size;\n    if ( includeParents === void 0 ) includeParents = false;\n\n  if (from == to) { return Slice.empty }\n\n  var $from = this.resolve(from), $to = this.resolve(to);\n  var depth = includeParents ? 0 : $from.sharedDepth(to);\n  var start = $from.start(depth), node = $from.node(depth);\n  var content = node.content.cut($from.pos - start, $to.pos - start);\n  return new Slice(content, $from.depth - depth, $to.depth - depth)\n};\n\n// :: (number, number, Slice)  Node\n// Replace the part of the document between the given positions with\n// the given slice. The slice must 'fit', meaning its open sides\n// must be able to connect to the surrounding content, and its\n// content nodes must be valid children for the node they are placed\n// into. If any of this is violated, an error of type\n// [`ReplaceError`](#model.ReplaceError) is thrown.\nNode.prototype.replace = function replace$1 (from, to, slice) {\n  return replace(this.resolve(from), this.resolve(to), slice)\n};\n\n// :: (number)  ?Node\n// Find the node directly after the given position.\nNode.prototype.nodeAt = function nodeAt (pos) {\n  for (var node = this;;) {\n    var ref = node.content.findIndex(pos);\n      var index = ref.index;\n      var offset = ref.offset;\n    node = node.maybeChild(index);\n    if (!node) { return null }\n    if (offset == pos || node.isText) { return node }\n    pos -= offset + 1;\n  }\n};\n\n// :: (number)  {node: ?Node, index: number, offset: number}\n// Find the (direct) child node after the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childAfter = function childAfter (pos) {\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  return {node: this.content.maybeChild(index), index: index, offset: offset}\n};\n\n// :: (number)  {node: ?Node, index: number, offset: number}\n// Find the (direct) child node before the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childBefore = function childBefore (pos) {\n  if (pos == 0) { return {node: null, index: 0, offset: 0} }\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }\n  var node = this.content.child(index - 1);\n  return {node: node, index: index - 1, offset: offset - node.nodeSize}\n};\n\n// :: (number)  ResolvedPos\n// Resolve the given position in the document, returning an\n// [object](#model.ResolvedPos) with information about its context.\nNode.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };\n\nNode.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };\n\n// :: (number, number, union<Mark, MarkType>)  bool\n// Test whether a given mark or mark type occurs in this document\n// between the two given positions.\nNode.prototype.rangeHasMark = function rangeHasMark (from, to, type) {\n  var found = false;\n  if (to > from) { this.nodesBetween(from, to, function (node) {\n    if (type.isInSet(node.marks)) { found = true; }\n    return !found\n  }); }\n  return found\n};\n\n// :: bool\n// True when this is a block (non-inline node)\nprototypeAccessors$3.isBlock.get = function () { return this.type.isBlock };\n\n// :: bool\n// True when this is a textblock node, a block node with inline\n// content.\nprototypeAccessors$3.isTextblock.get = function () { return this.type.isTextblock };\n\n// :: bool\n// True when this node allows inline content.\nprototypeAccessors$3.inlineContent.get = function () { return this.type.inlineContent };\n\n// :: bool\n// True when this is an inline node (a text node or a node that can\n// appear among text).\nprototypeAccessors$3.isInline.get = function () { return this.type.isInline };\n\n// :: bool\n// True when this is a text node.\nprototypeAccessors$3.isText.get = function () { return this.type.isText };\n\n// :: bool\n// True when this is a leaf node.\nprototypeAccessors$3.isLeaf.get = function () { return this.type.isLeaf };\n\n// :: bool\n// True when this is an atom, i.e. when it does not have directly\n// editable content. This is usually the same as `isLeaf`, but can\n// be configured with the [`atom` property](#model.NodeSpec.atom) on\n// a node's spec (typically used when the node is displayed as an\n// uneditable [node view](#view.NodeView)).\nprototypeAccessors$3.isAtom.get = function () { return this.type.isAtom };\n\n// :: ()  string\n// Return a string representation of this node for debugging\n// purposes.\nNode.prototype.toString = function toString () {\n  if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n  var name = this.type.name;\n  if (this.content.size)\n    { name += \"(\" + this.content.toStringInner() + \")\"; }\n  return wrapMarks(this.marks, name)\n};\n\n// :: (number)  ContentMatch\n// Get the content match in this node at the given index.\nNode.prototype.contentMatchAt = function contentMatchAt (index) {\n  var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n  if (!match) { throw new Error(\"Called contentMatchAt on a node with invalid content\") }\n  return match\n};\n\n// :: (number, number, ?Fragment, ?number, ?number)  bool\n// Test whether replacing the range between `from` and `to` (by\n// child index) with the given replacement fragment (which defaults\n// to the empty fragment) would leave the node's content valid. You\n// can optionally pass `start` and `end` indices into the\n// replacement fragment.\nNode.prototype.canReplace = function canReplace (from, to, replacement, start, end) {\n    if ( replacement === void 0 ) replacement = Fragment.empty;\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = replacement.childCount;\n\n  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n  var two = one && one.matchFragment(this.content, to);\n  if (!two || !two.validEnd) { return false }\n  for (var i = start; i < end; i++) { if (!this.type.allowsMarks(replacement.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (number, number, NodeType, ?[Mark])  bool\n// Test whether replacing the range `from` to `to` (by index) with a\n// node of the given type would leave the node's content valid.\nNode.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {\n  if (marks && !this.type.allowsMarks(marks)) { return false }\n  var start = this.contentMatchAt(from).matchType(type);\n  var end = start && start.matchFragment(this.content, to);\n  return end ? end.validEnd : false\n};\n\n// :: (Node)  bool\n// Test whether the given node's content could be appended to this\n// node. If that node is empty, this will only return true if there\n// is at least one node type that can appear in both nodes (to avoid\n// merging completely incompatible nodes).\nNode.prototype.canAppend = function canAppend (other) {\n  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }\n  else { return this.type.compatibleContent(other.type) }\n};\n\n// :: ()\n// Check whether this node and its descendants conform to the\n// schema, and raise error when they do not.\nNode.prototype.check = function check () {\n  if (!this.type.validContent(this.content))\n    { throw new RangeError((\"Invalid content for node \" + (this.type.name) + \": \" + (this.content.toString().slice(0, 50)))) }\n  var copy = Mark.none;\n  for (var i = 0; i < this.marks.length; i++) { copy = this.marks[i].addToSet(copy); }\n  if (!Mark.sameSet(copy, this.marks))\n    { throw new RangeError((\"Invalid collection of marks for node \" + (this.type.name) + \": \" + (this.marks.map(function (m) { return m.type.name; })))) }\n  this.content.forEach(function (node) { return node.check(); });\n};\n\n// :: ()  Object\n// Return a JSON-serializeable representation of this node.\nNode.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  if (this.content.size)\n    { obj.content = this.content.toJSON(); }\n  if (this.marks.length)\n    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }\n  return obj\n};\n\n// :: (Schema, Object)  Node\n// Deserialize a node from its JSON representation.\nNode.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Node.fromJSON\") }\n  var marks = null;\n  if (json.marks) {\n    if (!Array.isArray(json.marks)) { throw new RangeError(\"Invalid mark data for Node.fromJSON\") }\n    marks = json.marks.map(schema.markFromJSON);\n  }\n  if (json.type == \"text\") {\n    if (typeof json.text != \"string\") { throw new RangeError(\"Invalid text node in JSON\") }\n    return schema.text(json.text, marks)\n  }\n  var content = Fragment.fromJSON(schema, json.content);\n  return schema.nodeType(json.type).create(json.attrs, content, marks)\n};\n\nObject.defineProperties( Node.prototype, prototypeAccessors$3 );\n\nvar TextNode = /*@__PURE__*/(function (Node) {\n  function TextNode(type, attrs, content, marks) {\n    Node.call(this, type, attrs, null, marks);\n\n    if (!content) { throw new RangeError(\"Empty text nodes are not allowed\") }\n\n    this.text = content;\n  }\n\n  if ( Node ) TextNode.__proto__ = Node;\n  TextNode.prototype = Object.create( Node && Node.prototype );\n  TextNode.prototype.constructor = TextNode;\n\n  var prototypeAccessors$1 = { textContent: { configurable: true },nodeSize: { configurable: true } };\n\n  TextNode.prototype.toString = function toString () {\n    if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  };\n\n  prototypeAccessors$1.textContent.get = function () { return this.text };\n\n  TextNode.prototype.textBetween = function textBetween (from, to) { return this.text.slice(from, to) };\n\n  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };\n\n  TextNode.prototype.mark = function mark (marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  };\n\n  TextNode.prototype.withText = function withText (text) {\n    if (text == this.text) { return this }\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  };\n\n  TextNode.prototype.cut = function cut (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.text.length;\n\n    if (from == 0 && to == this.text.length) { return this }\n    return this.withText(this.text.slice(from, to))\n  };\n\n  TextNode.prototype.eq = function eq (other) {\n    return this.sameMarkup(other) && this.text == other.text\n  };\n\n  TextNode.prototype.toJSON = function toJSON () {\n    var base = Node.prototype.toJSON.call(this);\n    base.text = this.text;\n    return base\n  };\n\n  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );\n\n  return TextNode;\n}(Node));\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--)\n    { str = marks[i].type.name + \"(\" + str + \")\"; }\n  return str\n}\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nvar ContentMatch = function ContentMatch(validEnd) {\n  // :: bool\n  // True when this match state represents a valid end of the node.\n  this.validEnd = validEnd;\n  this.next = [];\n  this.wrapCache = [];\n};\n\nvar prototypeAccessors$4 = { inlineContent: { configurable: true },defaultType: { configurable: true },edgeCount: { configurable: true } };\n\nContentMatch.parse = function parse (string, nodeTypes) {\n  var stream = new TokenStream(string, nodeTypes);\n  if (stream.next == null) { return ContentMatch.empty }\n  var expr = parseExpr(stream);\n  if (stream.next) { stream.err(\"Unexpected trailing text\"); }\n  var match = dfa(nfa(expr));\n  checkForDeadEnds(match, stream);\n  return match\n};\n\n// :: (NodeType)  ?ContentMatch\n// Match a node type, returning a match after that node if\n// successful.\nContentMatch.prototype.matchType = function matchType (type) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { if (this.next[i] == type) { return this.next[i + 1] } }\n  return null\n};\n\n// :: (Fragment, ?number, ?number)  ?ContentMatch\n// Try to match a fragment. Returns the resulting match when\n// successful.\nContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = frag.childCount;\n\n  var cur = this;\n  for (var i = start; cur && i < end; i++)\n    { cur = cur.matchType(frag.child(i).type); }\n  return cur\n};\n\nprototypeAccessors$4.inlineContent.get = function () {\n  var first = this.next[0];\n  return first ? first.isInline : false\n};\n\n// :: ?NodeType\n// Get the first matching node type at this match position that can\n// be generated.\nprototypeAccessors$4.defaultType.get = function () {\n  for (var i = 0; i < this.next.length; i += 2) {\n    var type = this.next[i];\n    if (!(type.isText || type.hasRequiredAttrs())) { return type }\n  }\n};\n\nContentMatch.prototype.compatible = function compatible (other) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { for (var j = 0; j < other.next.length; j += 2)\n      { if (this.next[i] == other.next[j]) { return true } } }\n  return false\n};\n\n// :: (Fragment, bool, ?number)  ?Fragment\n// Try to match the given fragment, and if that fails, see if it can\n// be made to match by inserting nodes in front of it. When\n// successful, return a fragment of inserted nodes (which may be\n// empty if nothing had to be inserted). When `toEnd` is true, only\n// return a fragment if the resulting match goes to the end of the\n// content expression.\nContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {\n    if ( toEnd === void 0 ) toEnd = false;\n    if ( startIndex === void 0 ) startIndex = 0;\n\n  var seen = [this];\n  function search(match, types) {\n    var finished = match.matchFragment(after, startIndex);\n    if (finished && (!toEnd || finished.validEnd))\n      { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i], next = match.next[i + 1];\n      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n        seen.push(next);\n        var found = search(next, types.concat(type));\n        if (found) { return found }\n      }\n    }\n  }\n\n  return search(this, [])\n};\n\n// :: (NodeType)  ?[NodeType]\n// Find a set of wrapping node types that would allow a node of the\n// given type to appear at this position. The result may be empty\n// (when it fits directly) and will be null when no such wrapping\n// exists.\nContentMatch.prototype.findWrapping = function findWrapping (target) {\n  for (var i = 0; i < this.wrapCache.length; i += 2)\n    { if (this.wrapCache[i] == target) { return this.wrapCache[i + 1] } }\n  var computed = this.computeWrapping(target);\n  this.wrapCache.push(target, computed);\n  return computed\n};\n\nContentMatch.prototype.computeWrapping = function computeWrapping (target) {\n  var seen = Object.create(null), active = [{match: this, type: null, via: null}];\n  while (active.length) {\n    var current = active.shift(), match = current.match;\n    if (match.matchType(target)) {\n      var result = [];\n      for (var obj = current; obj.type; obj = obj.via)\n        { result.push(obj.type); }\n      return result.reverse()\n    }\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i];\n      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n        active.push({match: type.contentMatch, type: type, via: current});\n        seen[type.name] = true;\n      }\n    }\n  }\n};\n\n// :: number\n// The number of outgoing edges this node has in the finite\n// automaton that describes the content expression.\nprototypeAccessors$4.edgeCount.get = function () {\n  return this.next.length >> 1\n};\n\n// :: (number)  {type: NodeType, next: ContentMatch}\n// Get the _n_th outgoing edge from this node in the finite\n// automaton that describes the content expression.\nContentMatch.prototype.edge = function edge (n) {\n  var i = n << 1;\n  if (i >= this.next.length) { throw new RangeError((\"There's no \" + n + \"th edge in this content match\")) }\n  return {type: this.next[i], next: this.next[i + 1]}\n};\n\nContentMatch.prototype.toString = function toString () {\n  var seen = [];\n  function scan(m) {\n    seen.push(m);\n    for (var i = 1; i < m.next.length; i += 2)\n      { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }\n  }\n  scan(this);\n  return seen.map(function (m, i) {\n    var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)\n      { out += (i$1 ? \", \" : \"\") + m.next[i$1].name + \"->\" + seen.indexOf(m.next[i$1 + 1]); }\n    return out\n  }).join(\"\\n\")\n};\n\nObject.defineProperties( ContentMatch.prototype, prototypeAccessors$4 );\n\nContentMatch.empty = new ContentMatch(true);\n\nvar TokenStream = function TokenStream(string, nodeTypes) {\n  this.string = string;\n  this.nodeTypes = nodeTypes;\n  this.inline = null;\n  this.pos = 0;\n  this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n  if (this.tokens[this.tokens.length - 1] == \"\") { this.tokens.pop(); }\n  if (this.tokens[0] == \"\") { this.tokens.shift(); }\n};\n\nvar prototypeAccessors$1$2 = { next: { configurable: true } };\n\nprototypeAccessors$1$2.next.get = function () { return this.tokens[this.pos] };\n\nTokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };\n\nTokenStream.prototype.err = function err (str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") };\n\nObject.defineProperties( TokenStream.prototype, prototypeAccessors$1$2 );\n\nfunction parseExpr(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSeq(stream)); }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n}\n\nfunction parseExprSeq(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSubscript(stream)); }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs: exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n  for (;;) {\n    if (stream.eat(\"+\"))\n      { expr = {type: \"plus\", expr: expr}; }\n    else if (stream.eat(\"*\"))\n      { expr = {type: \"star\", expr: expr}; }\n    else if (stream.eat(\"?\"))\n      { expr = {type: \"opt\", expr: expr}; }\n    else if (stream.eat(\"{\"))\n      { expr = parseExprRange(stream, expr); }\n    else { break }\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) { stream.err(\"Expected number, got '\" + stream.next + \"'\"); }\n  var result = Number(stream.next);\n  stream.pos++;\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream), max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") { max = parseNum(stream); }\n    else { max = -1; }\n  }\n  if (!stream.eat(\"}\")) { stream.err(\"Unclosed braced range\"); }\n  return {type: \"range\", min: min, max: max, expr: expr}\n}\n\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes, type = types[name];\n  if (type) { return [type] }\n  var result = [];\n  for (var typeName in types) {\n    var type$1 = types[typeName];\n    if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }\n  }\n  if (result.length == 0) { stream.err(\"No node type or group '\" + name + \"' found\"); }\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) { stream.err(\"Missing closing paren\"); }\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) { stream.inline = type.isInline; }\n      else if (stream.inline != type.isInline) { stream.err(\"Mixing inline and block content\"); }\n      return {type: \"name\", value: type}\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object)  [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    var edge = {term: term, to: to};\n    nfa[from].push(edge);\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) { return next }\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      var loop$1 = node();\n      connect(compile(expr.expr, from), loop$1);\n      connect(compile(expr.expr, loop$1), loop$1);\n      return [edge(loop$1)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      var cur = from;\n      for (var i$1 = 0; i$1 < expr.min; i$1++) {\n        var next$1 = node();\n        connect(compile(expr.expr, cur), next$1);\n        cur = next$1;\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {\n          var next$2 = node();\n          edge(cur, next$2);\n          connect(compile(expr.expr, cur), next$2);\n          cur = next$2;\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp)\n\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }\n    result.push(node);\n    for (var i = 0; i < edges.length; i++) {\n      var ref = edges[i];\n      var term = ref.term;\n      var to = ref.to;\n      if (!term && result.indexOf(to) == -1) { scan(to); }\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]])  ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (ref) {\n        var term = ref.term;\n        var to = ref.to;\n\n        if (!term) { return }\n        var known = out.indexOf(term), set = known > -1 && out[known + 1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) { out.push(term, set = []); }\n          if (set.indexOf(node) == -1) { set.push(node); }\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n    for (var i = 0; i < out.length; i += 2) {\n      var states$1 = out[i + 1].sort(cmp);\n      state.next.push(out[i], labeled[states$1.join(\",\")] || explore(states$1));\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i], dead = !state.validEnd, nodes = [];\n    for (var j = 0; j < state.next.length; j += 2) {\n      var node = state.next[j], next = state.next[j + 1];\n      nodes.push(node.name);\n      if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }\n      if (work.indexOf(next) == -1) { work.push(next); }\n    }\n    if (dead) { stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\"); }\n  }\n}\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) { return null }\n    defaults[attrName] = attr.default;\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  var built = Object.create(null);\n  for (var name in attrs) {\n    var given = value && value[name];\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) { given = attr.default; }\n      else { throw new RangeError(\"No value supplied for attribute \" + name) }\n    }\n    built[name] = given;\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null);\n  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nvar NodeType = function NodeType(name, schema, spec) {\n  // :: string\n  // The name the node type has in this schema.\n  this.name = name;\n\n  // :: Schema\n  // A link back to the `Schema` the node type belongs to.\n  this.schema = schema;\n\n  // :: NodeSpec\n  // The spec that this type is based on\n  this.spec = spec;\n\n  this.groups = spec.group ? spec.group.split(\" \") : [];\n  this.attrs = initAttrs(spec.attrs);\n\n  this.defaultAttrs = defaultAttrs(this.attrs);\n\n  // :: ContentMatch\n  // The starting match of the node type's content expression.\n  this.contentMatch = null;\n\n  // : ?[MarkType]\n  // The set of marks allowed in this node. `null` means all marks\n  // are allowed.\n  this.markSet = null;\n\n  // :: bool\n  // True if this node type has inline content.\n  this.inlineContent = null;\n\n  // :: bool\n  // True if this is a block type\n  this.isBlock = !(spec.inline || name == \"text\");\n\n  // :: bool\n  // True if this is the text node type.\n  this.isText = name == \"text\";\n};\n\nvar prototypeAccessors$5 = { isInline: { configurable: true },isTextblock: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };\n\n// :: bool\n// True if this is an inline type.\nprototypeAccessors$5.isInline.get = function () { return !this.isBlock };\n\n// :: bool\n// True if this is a textblock type, a block that contains inline\n// content.\nprototypeAccessors$5.isTextblock.get = function () { return this.isBlock && this.inlineContent };\n\n// :: bool\n// True for node types that allow no content.\nprototypeAccessors$5.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };\n\n// :: bool\n// True when this node is an atom, i.e. when it does not have\n// directly editable content.\nprototypeAccessors$5.isAtom.get = function () { return this.isLeaf || this.spec.atom };\n\n// :: ()  bool\n// Tells you whether this node type has any required attributes.\nNodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs () {\n  for (var n in this.attrs) { if (this.attrs[n].isRequired) { return true } }\n  return false\n};\n\nNodeType.prototype.compatibleContent = function compatibleContent (other) {\n  return this == other || this.contentMatch.compatible(other.contentMatch)\n};\n\nNodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {\n  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }\n  else { return computeAttrs(this.attrs, attrs) }\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node\n// Create a `Node` of this type. The given attributes are\n// checked and defaulted (you can pass `null` to use the type's\n// defaults entirely, if no required attributes exist). `content`\n// may be a `Fragment`, a node, an array of nodes, or\n// `null`. Similarly `marks` may be `null` to default to the empty\n// set of marks.\nNodeType.prototype.create = function create (attrs, content, marks) {\n  if (this.isText) { throw new Error(\"NodeType.create can't construct text nodes\") }\n  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node\n// Like [`create`](#model.NodeType.create), but check the given content\n// against the node type's content restrictions, and throw an error\n// if it doesn't match.\nNodeType.prototype.createChecked = function createChecked (attrs, content, marks) {\n  content = Fragment.from(content);\n  if (!this.validContent(content))\n    { throw new RangeError(\"Invalid content for node \" + this.name) }\n  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  ?Node\n// Like [`create`](#model.NodeType.create), but see if it is necessary to\n// add nodes to the start or end of the given fragment to make it\n// fit the node. If no fitting wrapping can be found, return null.\n// Note that, due to the fact that required nodes can always be\n// created, this will always succeed if you pass null or\n// `Fragment.empty` as content.\nNodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {\n  attrs = this.computeAttrs(attrs);\n  content = Fragment.from(content);\n  if (content.size) {\n    var before = this.contentMatch.fillBefore(content);\n    if (!before) { return null }\n    content = before.append(content);\n  }\n  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);\n  if (!after) { return null }\n  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n};\n\n// :: (Fragment)  bool\n// Returns true if the given fragment is valid content for this node\n// type with the given attributes.\nNodeType.prototype.validContent = function validContent (content) {\n  var result = this.contentMatch.matchFragment(content);\n  if (!result || !result.validEnd) { return false }\n  for (var i = 0; i < content.childCount; i++)\n    { if (!this.allowsMarks(content.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (MarkType)  bool\n// Check whether the given mark type is allowed in this node.\nNodeType.prototype.allowsMarkType = function allowsMarkType (markType) {\n  return this.markSet == null || this.markSet.indexOf(markType) > -1\n};\n\n// :: ([Mark])  bool\n// Test whether the given set of marks are allowed in this node.\nNodeType.prototype.allowsMarks = function allowsMarks (marks) {\n  if (this.markSet == null) { return true }\n  for (var i = 0; i < marks.length; i++) { if (!this.allowsMarkType(marks[i].type)) { return false } }\n  return true\n};\n\n// :: ([Mark])  [Mark]\n// Removes the marks that are not allowed in this node from the given set.\nNodeType.prototype.allowedMarks = function allowedMarks (marks) {\n  if (this.markSet == null) { return marks }\n  var copy;\n  for (var i = 0; i < marks.length; i++) {\n    if (!this.allowsMarkType(marks[i].type)) {\n      if (!copy) { copy = marks.slice(0, i); }\n    } else if (copy) {\n      copy.push(marks[i]);\n    }\n  }\n  return !copy ? marks : copy.length ? copy : Mark.empty\n};\n\nNodeType.compile = function compile (nodes, schema) {\n  var result = Object.create(null);\n  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });\n\n  var topType = schema.spec.topNode || \"doc\";\n  if (!result[topType]) { throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\") }\n  if (!result.text) { throw new RangeError(\"Every schema needs a 'text' type\") }\n  for (var _ in result.text.attrs) { throw new RangeError(\"The text node type should not have attributes\") }\n\n  return result\n};\n\nObject.defineProperties( NodeType.prototype, prototypeAccessors$5 );\n\n// Attribute descriptors\n\nvar Attribute = function Attribute(options) {\n  this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n  this.default = options.default;\n};\n\nvar prototypeAccessors$1$3 = { isRequired: { configurable: true } };\n\nprototypeAccessors$1$3.isRequired.get = function () {\n  return !this.hasDefault\n};\n\nObject.defineProperties( Attribute.prototype, prototypeAccessors$1$3 );\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nvar MarkType = function MarkType(name, rank, schema, spec) {\n  // :: string\n  // The name of the mark type.\n  this.name = name;\n\n  // :: Schema\n  // The schema that this mark type instance is part of.\n  this.schema = schema;\n\n  // :: MarkSpec\n  // The spec on which the type is based.\n  this.spec = spec;\n\n  this.attrs = initAttrs(spec.attrs);\n\n  this.rank = rank;\n  this.excluded = null;\n  var defaults = defaultAttrs(this.attrs);\n  this.instance = defaults && new Mark(this, defaults);\n};\n\n// :: (?Object)  Mark\n// Create a mark of this type. `attrs` may be `null` or an object\n// containing only some of the mark's attributes. The others, if\n// they have defaults, will be added.\nMarkType.prototype.create = function create (attrs) {\n  if (!attrs && this.instance) { return this.instance }\n  return new Mark(this, computeAttrs(this.attrs, attrs))\n};\n\nMarkType.compile = function compile (marks, schema) {\n  var result = Object.create(null), rank = 0;\n  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });\n  return result\n};\n\n// :: ([Mark])  [Mark]\n// When there is a mark of this type in the given set, a new set\n// without it is returned. Otherwise, the input set is returned.\nMarkType.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++) { if (set[i].type == this) {\n    set = set.slice(0, i).concat(set.slice(i + 1));\n    i--;\n  } }\n  return set\n};\n\n// :: ([Mark])  ?Mark\n// Tests whether there is a mark of this type in the given set.\nMarkType.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (set[i].type == this) { return set[i] } }\n};\n\n// :: (MarkType)  bool\n// Queries whether a given mark type is\n// [excluded](#model.MarkSpec.excludes) by this one.\nMarkType.prototype.excludes = function excludes (other) {\n  return this.excluded.indexOf(other) > -1\n};\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significantit\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node)  DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (hole) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool)  DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nvar Schema = function Schema(spec) {\n  // :: SchemaSpec\n  // The [spec](#model.SchemaSpec) on which the schema is based,\n  // with the added guarantee that its `nodes` and `marks`\n  // properties are\n  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n  // (not raw objects).\n  this.spec = {};\n  for (var prop in spec) { this.spec[prop] = spec[prop]; }\n  this.spec.nodes = OrderedMap.from(spec.nodes);\n  this.spec.marks = OrderedMap.from(spec.marks);\n\n  // :: Object<NodeType>\n  // An object mapping the schema's node names to node type objects.\n  this.nodes = NodeType.compile(this.spec.nodes, this);\n\n  // :: Object<MarkType>\n  // A map from mark names to mark type objects.\n  this.marks = MarkType.compile(this.spec.marks, this);\n\n  var contentExprCache = Object.create(null);\n  for (var prop$1 in this.nodes) {\n    if (prop$1 in this.marks)\n      { throw new RangeError(prop$1 + \" can not be both a node and a mark\") }\n    var type = this.nodes[prop$1], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n    type.contentMatch = contentExprCache[contentExpr] ||\n      (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n    type.inlineContent = type.contentMatch.inlineContent;\n    type.markSet = markExpr == \"_\" ? null :\n      markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n      markExpr == \"\" || !type.inlineContent ? [] : null;\n  }\n  for (var prop$2 in this.marks) {\n    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;\n    type$1.excluded = excl == null ? [type$1] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n  }\n\n  this.nodeFromJSON = this.nodeFromJSON.bind(this);\n  this.markFromJSON = this.markFromJSON.bind(this);\n\n  // :: NodeType\n  // The type of the [default top node](#model.SchemaSpec.topNode)\n  // for this schema.\n  this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n\n  // :: Object\n  // An object for storing whatever values modules may want to\n  // compute and cache per schema. (If you want to store something\n  // in it, try to use property names unlikely to clash.)\n  this.cached = Object.create(null);\n  this.cached.wrappings = Object.create(null);\n};\n\n// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node\n// Create a node in this schema. The `type` may be a string or a\n// `NodeType` instance. Attributes will be extended\n// with defaults, `content` may be a `Fragment`,\n// `null`, a `Node`, or an array of nodes.\nSchema.prototype.node = function node (type, attrs, content, marks) {\n  if (typeof type == \"string\")\n    { type = this.nodeType(type); }\n  else if (!(type instanceof NodeType))\n    { throw new RangeError(\"Invalid node type: \" + type) }\n  else if (type.schema != this)\n    { throw new RangeError(\"Node type from different schema used (\" + type.name + \")\") }\n\n  return type.createChecked(attrs, content, marks)\n};\n\n// :: (string, ?[Mark])  Node\n// Create a text node in the schema. Empty text nodes are not\n// allowed.\nSchema.prototype.text = function text (text$1, marks) {\n  var type = this.nodes.text;\n  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))\n};\n\n// :: (union<string, MarkType>, ?Object)  Mark\n// Create a mark with the given type and attributes.\nSchema.prototype.mark = function mark (type, attrs) {\n  if (typeof type == \"string\") { type = this.marks[type]; }\n  return type.create(attrs)\n};\n\n// :: (Object)  Node\n// Deserialize a node from its JSON representation. This method is\n// bound.\nSchema.prototype.nodeFromJSON = function nodeFromJSON (json) {\n  return Node.fromJSON(this, json)\n};\n\n// :: (Object)  Mark\n// Deserialize a mark from its JSON representation. This method is\n// bound.\nSchema.prototype.markFromJSON = function markFromJSON (json) {\n  return Mark.fromJSON(this, json)\n};\n\nSchema.prototype.nodeType = function nodeType (name) {\n  var found = this.nodes[name];\n  if (!found) { throw new RangeError(\"Unknown node type: \" + name) }\n  return found\n};\n\nfunction gatherMarks(schema, marks) {\n  var found = [];\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i], mark = schema.marks[name], ok = mark;\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var mark$1 = schema.marks[prop];\n        if (name == \"_\" || (mark$1.spec.group && mark$1.spec.group.split(\" \").indexOf(name) > -1))\n          { found.push(ok = mark$1); }\n      }\n    }\n    if (!ok) { throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\") }\n  }\n  return found\n}\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schemawhen directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   contextthe parent nodes into which the content is being\n//   parsedmatches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a sectiona double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>)  ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node)  dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema)  Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nvar DOMParser = function DOMParser(schema, rules) {\n  var this$1 = this;\n\n  // :: Schema\n  // The schema into which the parser parses.\n  this.schema = schema;\n  // :: [ParseRule]\n  // The set of [parse rules](#model.ParseRule) that the parser\n  // uses, in order of precedence.\n  this.rules = rules;\n  this.tags = [];\n  this.styles = [];\n\n  rules.forEach(function (rule) {\n    if (rule.tag) { this$1.tags.push(rule); }\n    else if (rule.style) { this$1.styles.push(rule); }\n  });\n\n  // Only normalize list elements when lists in the schema can't directly contain themselves\n  this.normalizeLists = !this.tags.some(function (r) {\n    if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) { return false }\n    var node = schema.nodes[r.node];\n    return node.contentMatch.matchType(node)\n  });\n};\n\n// :: (dom.Node, ?ParseOptions)  Node\n// Parse a document from the content of a DOM node.\nDOMParser.prototype.parse = function parse (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, false);\n  context.addAll(dom, null, options.from, options.to);\n  return context.finish()\n};\n\n// :: (dom.Node, ?ParseOptions)  Slice\n// Parses the content of the given DOM node, like\n// [`parse`](#model.DOMParser.parse), and takes the same set of\n// options. But unlike that method, which produces a whole node,\n// this one returns a slice that is open at the sides, meaning that\n// the schema constraints aren't applied to the start of nodes to\n// the left of the input and the end of nodes at the end.\nDOMParser.prototype.parseSlice = function parseSlice (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, true);\n  context.addAll(dom, null, options.from, options.to);\n  return Slice.maxOpen(context.finish())\n};\n\nDOMParser.prototype.matchTag = function matchTag (dom, context, after) {\n  for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n    var rule = this.tags[i];\n    if (matches(dom, rule.tag) &&\n        (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n        (!rule.context || context.matchesContext(rule.context))) {\n      if (rule.getAttrs) {\n        var result = rule.getAttrs(dom);\n        if (result === false) { continue }\n        rule.attrs = result;\n      }\n      return rule\n    }\n  }\n};\n\nDOMParser.prototype.matchStyle = function matchStyle (prop, value, context, after) {\n  for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n    var rule = this.styles[i];\n    if (rule.style.indexOf(prop) != 0 ||\n        rule.context && !context.matchesContext(rule.context) ||\n        // Test that the style string either precisely matches the prop,\n        // or has an '=' sign after the prop, followed by the given\n        // value.\n        rule.style.length > prop.length &&\n        (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n      { continue }\n    if (rule.getAttrs) {\n      var result = rule.getAttrs(value);\n      if (result === false) { continue }\n      rule.attrs = result;\n    }\n    return rule\n  }\n};\n\n// : (Schema)  [ParseRule]\nDOMParser.schemaRules = function schemaRules (schema) {\n  var result = [];\n  function insert(rule) {\n    var priority = rule.priority == null ? 50 : rule.priority, i = 0;\n    for (; i < result.length; i++) {\n      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n      if (nextPriority < priority) { break }\n    }\n    result.splice(i, 0, rule);\n  }\n\n  var loop = function ( name ) {\n    var rules = schema.marks[name].spec.parseDOM;\n    if (rules) { rules.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.mark = name;\n    }); }\n  };\n\n    for (var name in schema.marks) loop( name );\n  var loop$1 = function ( name ) {\n    var rules$1 = schema.nodes[name$1].spec.parseDOM;\n    if (rules$1) { rules$1.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.node = name$1;\n    }); }\n  };\n\n    for (var name$1 in schema.nodes) loop$1();\n  return result\n};\n\n// :: (Schema)  DOMParser\n// Construct a DOM parser using the parsing rules listed in a\n// schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n// [priority](#model.ParseRule.priority).\nDOMParser.fromSchema = function fromSchema (schema) {\n  return schema.cached.domParser ||\n    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n};\n\n// : Object<bool> The block-level tags in HTML5\nvar blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\n\n// : Object<bool> The tags that we normally ignore.\nvar ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n};\n\n// : Object<bool> List tags.\nvar listTags = {ol: true, ul: true};\n\n// Using a bitfield for node context options\nvar OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n}\n\nvar NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {\n  this.type = type;\n  this.attrs = attrs;\n  this.solid = solid;\n  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  this.options = options;\n  this.content = [];\n  // Marks applied to this node itself\n  this.marks = marks;\n  // Marks applied to its children\n  this.activeMarks = Mark.none;\n  // Marks that can't apply here, but will be used in children if possible\n  this.pendingMarks = pendingMarks;\n  // Nested Marks with same type\n  this.stashMarks = [];\n};\n\nNodeContext.prototype.findWrapping = function findWrapping (node) {\n  if (!this.match) {\n    if (!this.type) { return [] }\n    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n    if (fill) {\n      this.match = this.type.contentMatch.matchFragment(fill);\n    } else {\n      var start = this.type.contentMatch, wrap;\n      if (wrap = start.findWrapping(node.type)) {\n        this.match = start;\n        return wrap\n      } else {\n        return null\n      }\n    }\n  }\n  return this.match.findWrapping(node.type)\n};\n\nNodeContext.prototype.finish = function finish (openEnd) {\n  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n    var last = this.content[this.content.length - 1], m;\n    if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n      if (last.text.length == m[0].length) { this.content.pop(); }\n      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }\n    }\n  }\n  var content = Fragment.from(this.content);\n  if (!openEnd && this.match)\n    { content = content.append(this.match.fillBefore(Fragment.empty, true)); }\n  return this.type ? this.type.create(this.attrs, content, this.marks) : content\n};\n\nNodeContext.prototype.popFromStashMark = function popFromStashMark (mark) {\n  for (var i = this.stashMarks.length - 1; i >= 0; i--)\n    { if (mark.eq(this.stashMarks[i])) { return this.stashMarks.splice(i, 1)[0] } }\n};\n\nNodeContext.prototype.applyPending = function applyPending (nextType) {\n  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n    var mark = pending[i];\n    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n        !mark.isInSet(this.activeMarks)) {\n      this.activeMarks = mark.addToSet(this.activeMarks);\n      this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n    }\n  }\n};\n\nNodeContext.prototype.inlineContext = function inlineContext (node) {\n  if (this.type) { return this.type.inlineContent }\n  if (this.content.length) { return this.content[0].isInline }\n  return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())\n};\n\nvar ParseContext = function ParseContext(parser, options, open) {\n  // : DOMParser The parser we are using.\n  this.parser = parser;\n  // : Object The options passed to this parse.\n  this.options = options;\n  this.isOpen = open;\n  var topNode = options.topNode, topContext;\n  var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);\n  if (topNode)\n    { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                 options.topMatch || topNode.type.contentMatch, topOptions); }\n  else if (open)\n    { topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions); }\n  else\n    { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions); }\n  this.nodes = [topContext];\n  // : [Mark] The current set of marks\n  this.open = 0;\n  this.find = options.findPositions;\n  this.needsBlock = false;\n};\n\nvar prototypeAccessors$6 = { top: { configurable: true },currentPos: { configurable: true } };\n\nprototypeAccessors$6.top.get = function () {\n  return this.nodes[this.open]\n};\n\n// : (dom.Node)\n// Add a DOM node to the content. Text is inserted as text node,\n// otherwise, the node is passed to `addElement` or, if it has a\n// `style` attribute, `addElementWithStyles`.\nParseContext.prototype.addDOM = function addDOM (dom) {\n  if (dom.nodeType == 3) {\n    this.addTextNode(dom);\n  } else if (dom.nodeType == 1) {\n    var style = dom.getAttribute(\"style\");\n    var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;\n    if (marks != null) { for (var i = 0; i < marks.length; i++) { this.addPendingMark(marks[i]); } }\n    this.addElement(dom);\n    if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this.removePendingMark(marks[i$1], top); } }\n  }\n};\n\nParseContext.prototype.addTextNode = function addTextNode (dom) {\n  var value = dom.nodeValue;\n  var top = this.top;\n  if (top.options & OPT_PRESERVE_WS_FULL ||\n      top.inlineContext(dom) ||\n      /[^ \\t\\r\\n\\u000c]/.test(value)) {\n    if (!(top.options & OPT_PRESERVE_WS)) {\n      value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n      // If this starts with whitespace, and there is no node before it, or\n      // a hard break, or a text node that ends with whitespace, strip the\n      // leading space.\n      if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n        var nodeBefore = top.content[top.content.length - 1];\n        var domNodeBefore = dom.previousSibling;\n        if (!nodeBefore ||\n            (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n            (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n          { value = value.slice(1); }\n      }\n    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n      value = value.replace(/\\r?\\n|\\r/g, \" \");\n    } else {\n      value = value.replace(/\\r\\n?/g, \"\\n\");\n    }\n    if (value) { this.insertNode(this.parser.schema.text(value)); }\n    this.findInText(dom);\n  } else {\n    this.findInside(dom);\n  }\n};\n\n// : (dom.Element, ?ParseRule)\n// Try to find a handler for the given tag and use that to parse. If\n// none is found, the element's content nodes are added directly.\nParseContext.prototype.addElement = function addElement (dom, matchAfter) {\n  var name = dom.nodeName.toLowerCase(), ruleID;\n  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) { normalizeList(dom); }\n  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n      (ruleID = this.parser.matchTag(dom, this, matchAfter));\n  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n    this.findInside(dom);\n    this.ignoreFallback(dom);\n  } else if (!rule || rule.skip || rule.closeParent) {\n    if (rule && rule.closeParent) { this.open = Math.max(0, this.open - 1); }\n    else if (rule && rule.skip.nodeType) { dom = rule.skip; }\n    var sync, top = this.top, oldNeedsBlock = this.needsBlock;\n    if (blockTags.hasOwnProperty(name)) {\n      sync = true;\n      if (!top.type) { this.needsBlock = true; }\n    } else if (!dom.firstChild) {\n      this.leafFallback(dom);\n      return\n    }\n    this.addAll(dom);\n    if (sync) { this.sync(top); }\n    this.needsBlock = oldNeedsBlock;\n  } else {\n    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);\n  }\n};\n\n// Called for leaf DOM nodes that would otherwise be ignored\nParseContext.prototype.leafFallback = function leafFallback (dom) {\n  if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n    { this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\")); }\n};\n\n// Called for ignored nodes\nParseContext.prototype.ignoreFallback = function ignoreFallback (dom) {\n  // Ignored BR nodes should at least create an inline context\n  if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n    { this.findPlace(this.parser.schema.text(\"-\")); }\n};\n\n// Run any style parser associated with the node's styles. Either\n// return an array of marks, or null to indicate some of the styles\n// had a rule with `ignore` set.\nParseContext.prototype.readStyles = function readStyles (styles) {\n  var marks = Mark.none;\n  style: for (var i = 0; i < styles.length; i += 2) {\n    for (var after = null;;) {\n      var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n      if (!rule) { continue style }\n      if (rule.ignore) { return null }\n      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n      if (rule.consuming === false) { after = rule; }\n      else { break }\n    }\n  }\n  return marks\n};\n\n// : (dom.Element, ParseRule)  bool\n// Look up a handler for the given node. If none are found, return\n// false. Otherwise, apply it, use its return value to drive the way\n// the node's content is wrapped, and return true.\nParseContext.prototype.addElementByRule = function addElementByRule (dom, rule, continueAfter) {\n    var this$1 = this;\n\n  var sync, nodeType, markType, mark;\n  if (rule.node) {\n    nodeType = this.parser.schema.nodes[rule.node];\n    if (!nodeType.isLeaf) {\n      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);\n    } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n      this.leafFallback(dom);\n    }\n  } else {\n    markType = this.parser.schema.marks[rule.mark];\n    mark = markType.create(rule.attrs);\n    this.addPendingMark(mark);\n  }\n  var startIn = this.top;\n\n  if (nodeType && nodeType.isLeaf) {\n    this.findInside(dom);\n  } else if (continueAfter) {\n    this.addElement(dom, continueAfter);\n  } else if (rule.getContent) {\n    this.findInside(dom);\n    rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1.insertNode(node); });\n  } else {\n    var contentDOM = rule.contentElement;\n    if (typeof contentDOM == \"string\") { contentDOM = dom.querySelector(contentDOM); }\n    else if (typeof contentDOM == \"function\") { contentDOM = contentDOM(dom); }\n    if (!contentDOM) { contentDOM = dom; }\n    this.findAround(dom, contentDOM, true);\n    this.addAll(contentDOM, sync);\n  }\n  if (sync) { this.sync(startIn); this.open--; }\n  if (mark) { this.removePendingMark(mark, startIn); }\n};\n\n// : (dom.Node, ?NodeBuilder, ?number, ?number)\n// Add all child nodes between `startIndex` and `endIndex` (or the\n// whole node, if not given). If `sync` is passed, use it to\n// synchronize after every block element.\nParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {\n  var index = startIndex || 0;\n  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n           end = endIndex == null ? null : parent.childNodes[endIndex];\n       dom != end; dom = dom.nextSibling, ++index) {\n    this.findAtPoint(parent, index);\n    this.addDOM(dom);\n    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n      { this.sync(sync); }\n  }\n  this.findAtPoint(parent, index);\n};\n\n// Try to find a way to fit the given node type into the current\n// context. May add intermediate wrappers and/or leave non-solid\n// nodes that we're in.\nParseContext.prototype.findPlace = function findPlace (node) {\n  var route, sync;\n  for (var depth = this.open; depth >= 0; depth--) {\n    var cx = this.nodes[depth];\n    var found = cx.findWrapping(node);\n    if (found && (!route || route.length > found.length)) {\n      route = found;\n      sync = cx;\n      if (!found.length) { break }\n    }\n    if (cx.solid) { break }\n  }\n  if (!route) { return false }\n  this.sync(sync);\n  for (var i = 0; i < route.length; i++)\n    { this.enterInner(route[i], null, false); }\n  return true\n};\n\n// : (Node)  ?Node\n// Try to insert the given node, adjusting the context when needed.\nParseContext.prototype.insertNode = function insertNode (node) {\n  if (node.isInline && this.needsBlock && !this.top.type) {\n    var block = this.textblockFromContext();\n    if (block) { this.enterInner(block); }\n  }\n  if (this.findPlace(node)) {\n    this.closeExtra();\n    var top = this.top;\n    top.applyPending(node.type);\n    if (top.match) { top.match = top.match.matchType(node.type); }\n    var marks = top.activeMarks;\n    for (var i = 0; i < node.marks.length; i++)\n      { if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n        { marks = node.marks[i].addToSet(marks); } }\n    top.content.push(node.mark(marks));\n    return true\n  }\n  return false\n};\n\n// : (NodeType, ?Object)  bool\n// Try to start a node of the given type, adjusting the context when\n// necessary.\nParseContext.prototype.enter = function enter (type, attrs, preserveWS) {\n  var ok = this.findPlace(type.create(attrs));\n  if (ok) { this.enterInner(type, attrs, true, preserveWS); }\n  return ok\n};\n\n// Open a node of the given type\nParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {\n  this.closeExtra();\n  var top = this.top;\n  top.applyPending(type);\n  top.match = top.match && top.match.matchType(type, attrs);\n  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);\n  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }\n  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n  this.open++;\n};\n\n// Make sure all nodes above this.open are finished and added to\n// their parents\nParseContext.prototype.closeExtra = function closeExtra (openEnd) {\n  var i = this.nodes.length - 1;\n  if (i > this.open) {\n    for (; i > this.open; i--) { this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd)); }\n    this.nodes.length = this.open + 1;\n  }\n};\n\nParseContext.prototype.finish = function finish () {\n  this.open = 0;\n  this.closeExtra(this.isOpen);\n  return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n};\n\nParseContext.prototype.sync = function sync (to) {\n  for (var i = this.open; i >= 0; i--) { if (this.nodes[i] == to) {\n    this.open = i;\n    return\n  } }\n};\n\nprototypeAccessors$6.currentPos.get = function () {\n  this.closeExtra();\n  var pos = 0;\n  for (var i = this.open; i >= 0; i--) {\n    var content = this.nodes[i].content;\n    for (var j = content.length - 1; j >= 0; j--)\n      { pos += content[j].nodeSize; }\n    if (i) { pos++; }\n  }\n  return pos\n};\n\nParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == parent && this.find[i].offset == offset)\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findInside = function findInside (parent) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findAround = function findAround (parent, content, before) {\n  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n      var pos = content.compareDocumentPosition(this.find[i].node);\n      if (pos & (before ? 2 : 4))\n        { this.find[i].pos = this.currentPos; }\n    }\n  } }\n};\n\nParseContext.prototype.findInText = function findInText (textNode) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == textNode)\n      { this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset); }\n  } }\n};\n\n// : (string)  bool\n// Determines whether the given [context\n// string](#ParseRule.context) matches this context.\nParseContext.prototype.matchesContext = function matchesContext (context) {\n    var this$1 = this;\n\n  if (context.indexOf(\"|\") > -1)\n    { return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this) }\n\n  var parts = context.split(\"/\");\n  var option = this.options.context;\n  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n  var match = function (i, depth) {\n    for (; i >= 0; i--) {\n      var part = parts[i];\n      if (part == \"\") {\n        if (i == parts.length - 1 || i == 0) { continue }\n        for (; depth >= minDepth; depth--)\n          { if (match(i - 1, depth)) { return true } }\n        return false\n      } else {\n        var next = depth > 0 || (depth == 0 && useRoot) ? this$1.nodes[depth].type\n            : option && depth >= minDepth ? option.node(depth - minDepth).type\n            : null;\n        if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n          { return false }\n        depth--;\n      }\n    }\n    return true\n  };\n  return match(parts.length - 1, this.open)\n};\n\nParseContext.prototype.textblockFromContext = function textblockFromContext () {\n  var $context = this.options.context;\n  if ($context) { for (var d = $context.depth; d >= 0; d--) {\n    var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n    if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }\n  } }\n  for (var name in this.parser.schema.nodes) {\n    var type = this.parser.schema.nodes[name];\n    if (type.isTextblock && type.defaultAttrs) { return type }\n  }\n};\n\nParseContext.prototype.addPendingMark = function addPendingMark (mark) {\n  var found = findSameMarkInSet(mark, this.top.pendingMarks);\n  if (found) { this.top.stashMarks.push(found); }\n  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n};\n\nParseContext.prototype.removePendingMark = function removePendingMark (mark, upto) {\n  for (var depth = this.open; depth >= 0; depth--) {\n    var level = this.nodes[depth];\n    var found = level.pendingMarks.lastIndexOf(mark);\n    if (found > -1) {\n      level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n    } else {\n      level.activeMarks = mark.removeFromSet(level.activeMarks);\n      var stashMark = level.popFromStashMark(mark);\n      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n        { level.activeMarks = stashMark.addToSet(level.activeMarks); }\n    }\n    if (level == upto) { break }\n  }\n};\n\nObject.defineProperties( ParseContext.prototype, prototypeAccessors$6 );\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string)  [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = [];\n  while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }\n  return result\n}\n\nfunction copy(obj) {\n  var copy = {};\n  for (var prop in obj) { copy[prop] = obj[prop]; }\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n  var loop = function ( name ) {\n    var parent = nodes[name];\n    if (!parent.allowsMarkType(markType)) { return }\n    var seen = [], scan = function (match) {\n      seen.push(match);\n      for (var i = 0; i < match.edgeCount; i++) {\n        var ref = match.edge(i);\n        var type = ref.type;\n        var next = ref.next;\n        if (type == nodeType) { return true }\n        if (seen.indexOf(next) < 0 && scan(next)) { return true }\n      }\n    };\n    if (scan(parent.contentMatch)) { return { v: true } }\n  };\n\n  for (var name in nodes) {\n    var returned = loop( name );\n\n    if ( returned ) return returned.v;\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (var i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) { return set[i] }\n  }\n}\n\n// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a stringthe name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced hole) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nvar DOMSerializer = function DOMSerializer(nodes, marks) {\n  // :: Object<(node: Node)  DOMOutputSpec>\n  // The node serialization functions.\n  this.nodes = nodes || {};\n  // :: Object<?(mark: Mark, inline: bool)  DOMOutputSpec>\n  // The mark serialization functions.\n  this.marks = marks || {};\n};\n\n// :: (Fragment, ?Object)  dom.DocumentFragment\n// Serialize the content of this fragment to a DOM fragment. When\n// not in the browser, the `document` option, containing a DOM\n// document, should be passed so that the serializer can create\n// nodes.\nDOMSerializer.prototype.serializeFragment = function serializeFragment (fragment, options, target) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n  if (!target) { target = doc(options).createDocumentFragment(); }\n\n  var top = target, active = null;\n  fragment.forEach(function (node) {\n    if (active || node.marks.length) {\n      if (!active) { active = []; }\n      var keep = 0, rendered = 0;\n      while (keep < active.length && rendered < node.marks.length) {\n        var next = node.marks[rendered];\n        if (!this$1.marks[next.type.name]) { rendered++; continue }\n        if (!next.eq(active[keep]) || next.type.spec.spanning === false) { break }\n        keep += 2; rendered++;\n      }\n      while (keep < active.length) {\n        top = active.pop();\n        active.pop();\n      }\n      while (rendered < node.marks.length) {\n        var add = node.marks[rendered++];\n        var markDOM = this$1.serializeMark(add, node.isInline, options);\n        if (markDOM) {\n          active.push(add, top);\n          top.appendChild(markDOM.dom);\n          top = markDOM.contentDOM || markDOM.dom;\n        }\n      }\n    }\n    top.appendChild(this$1.serializeNodeInner(node, options));\n  });\n\n  return target\n};\n\nDOMSerializer.prototype.serializeNodeInner = function serializeNodeInner (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var ref =\n      DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n    var dom = ref.dom;\n    var contentDOM = ref.contentDOM;\n  if (contentDOM) {\n    if (node.isLeaf)\n      { throw new RangeError(\"Content hole not allowed in a leaf node spec\") }\n    if (options.onContent)\n      { options.onContent(node, contentDOM, options); }\n    else\n      { this.serializeFragment(node.content, options, contentDOM); }\n  }\n  return dom\n};\n\n// :: (Node, ?Object)  dom.Node\n// Serialize this node to a DOM node. This can be useful when you\n// need to serialize a part of a document, as opposed to the whole\n// document. To serialize a whole document, use\n// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n// its [content](#model.Node.content).\nDOMSerializer.prototype.serializeNode = function serializeNode (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var dom = this.serializeNodeInner(node, options);\n  for (var i = node.marks.length - 1; i >= 0; i--) {\n    var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n    if (wrap) {\n(wrap.contentDOM || wrap.dom).appendChild(dom);\n      dom = wrap.dom;\n    }\n  }\n  return dom\n};\n\nDOMSerializer.prototype.serializeMark = function serializeMark (mark, inline, options) {\n    if ( options === void 0 ) options = {};\n\n  var toDOM = this.marks[mark.type.name];\n  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n};\n\n// :: (dom.Document, DOMOutputSpec)  {dom: dom.Node, contentDOM: ?dom.Node}\n// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n// the spec has a hole (zero) in it, `contentDOM` will point at the\n// node with the hole.\nDOMSerializer.renderSpec = function renderSpec (doc, structure, xmlNS) {\n    if ( xmlNS === void 0 ) xmlNS = null;\n\n  if (typeof structure == \"string\")\n    { return {dom: doc.createTextNode(structure)} }\n  if (structure.nodeType != null)\n    { return {dom: structure} }\n  if (structure.dom && structure.dom.nodeType != null)\n    { return structure }\n  var tagName = structure[0], space = tagName.indexOf(\" \");\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n  var contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n  var attrs = structure[1], start = 1;\n  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n    for (var name in attrs) { if (attrs[name] != null) {\n      var space$1 = name.indexOf(\" \");\n      if (space$1 > 0) { dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]); }\n      else { dom.setAttribute(name, attrs[name]); }\n    } }\n  }\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start)\n        { throw new RangeError(\"Content hole must be the only child of its parent node\") }\n      return {dom: dom, contentDOM: dom}\n    } else {\n      var ref = DOMSerializer.renderSpec(doc, child, xmlNS);\n        var inner = ref.dom;\n        var innerContent = ref.contentDOM;\n      dom.appendChild(inner);\n      if (innerContent) {\n        if (contentDOM) { throw new RangeError(\"Multiple content holes\") }\n        contentDOM = innerContent;\n      }\n    }\n  }\n  return {dom: dom, contentDOM: contentDOM}\n};\n\n// :: (Schema)  DOMSerializer\n// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n// properties in a schema's node and mark specs.\nDOMSerializer.fromSchema = function fromSchema (schema) {\n  return schema.cached.domSerializer ||\n    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n};\n\n// : (Schema)  Object<(node: Node)  DOMOutputSpec>\n// Gather the serializers in a schema's node specs into an object.\n// This can be useful as a base to build a custom serializer from.\nDOMSerializer.nodesFromSchema = function nodesFromSchema (schema) {\n  var result = gatherToDOM(schema.nodes);\n  if (!result.text) { result.text = function (node) { return node.text; }; }\n  return result\n};\n\n// : (Schema)  Object<(mark: Mark)  DOMOutputSpec>\n// Gather the serializers in a schema's mark specs into an object.\nDOMSerializer.marksFromSchema = function marksFromSchema (schema) {\n  return gatherToDOM(schema.marks)\n};\n\nfunction gatherToDOM(obj) {\n  var result = {};\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n    if (toDOM) { result[name] = toDOM; }\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n\nexport { ContentMatch, DOMParser, DOMSerializer, Fragment, Mark, MarkType, Node, NodeRange, NodeType, ReplaceError, ResolvedPos, Schema, Slice };\n//# sourceMappingURL=index.es.js.map\n","/*\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <elfz@laacz.lv>\n    http://jsbeautifier.org/\n\n\n  You are free to use this in any way you want, in case you find this useful or working for you.\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_size (default 4)           indentation size,\n    indent_char (default space)       character to indent with,\n    max_char (default 70)            -  maximum amount of characters per line,\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_size': 2,\n      'indent_char': ' ',\n      'max_char': 78,\n      'brace_style': 'expand',\n      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u']\n    });\n*/\n\nfunction style_html(html_source, options) {\n//Wrapper function to invoke all the necessary constructors and deal with the output.\n\n  var multi_parser,\n      indent_size,\n      indent_character,\n      max_char,\n      brace_style,\n      unformatted;\n\n  options = options || {};\n  indent_size = options.indent_size || 4;\n  indent_character = options.indent_char || ' ';\n  brace_style = options.brace_style || 'collapse';\n  max_char = options.max_char == 0 ? Infinity : options.max_char || 70;\n  unformatted = options.unformatted || ['a', 'span', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n\n  function Parser() {\n\n    this.pos = 0; //Parser position\n    this.token = '';\n    this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT\n    this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values\n      parent: 'parent1',\n      parentcount: 1,\n      parent1: ''\n    };\n    this.tag_type = '';\n    this.token_text = this.last_token = this.last_text = this.token_type = '';\n\n    this.Utils = { //Uilities made available to the various functions\n      whitespace: \"\\n\\r\\t \".split(''),\n      single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML\n      extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them\n      in_array: function (what, arr) {\n        for (var i=0; i<arr.length; i++) {\n          if (what === arr[i]) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }\n\n    this.get_content = function () { //function to capture regular content between tags\n\n      var input_char = '',\n          content = [],\n          space = false; //if a space is needed\n\n      while (this.input.charAt(this.pos) !== '<') {\n        if (this.pos >= this.input.length) {\n          return content.length?content.join(''):['', 'TK_EOF'];\n        }\n\n        input_char = this.input.charAt(this.pos);\n        this.pos++;\n        this.line_char_count++;\n\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n          if (content.length) {\n            space = true;\n          }\n          this.line_char_count--;\n          continue; //don't want to insert unnecessary space\n        }\n        else if (space) {\n          if (this.line_char_count >= this.max_char) { //insert a line when the max_char is reached\n            content.push('\\n');\n            for (var i=0; i<this.indent_level; i++) {\n              content.push(this.indent_string);\n            }\n            this.line_char_count = 0;\n          }\n          else{\n            content.push(' ');\n            this.line_char_count++;\n          }\n          space = false;\n        }\n        content.push(input_char); //letter at-a-time (or string) inserted to an array\n      }\n      return content.length?content.join(''):'';\n    }\n\n    this.get_contents_to = function (name) { //get the full content of a script or style to pass to js_beautify\n      if (this.pos == this.input.length) {\n        return ['', 'TK_EOF'];\n      }\n      var input_char = '';\n      var content = '';\n      var reg_match = new RegExp('\\<\\/' + name + '\\\\s*\\>', 'igm');\n      reg_match.lastIndex = this.pos;\n      var reg_array = reg_match.exec(this.input);\n      var end_script = reg_array?reg_array.index:this.input.length; //absolute end of script\n      if(this.pos < end_script) { //get everything in between the script tags\n        content = this.input.substring(this.pos, end_script);\n        this.pos = end_script;\n      }\n      return content;\n    }\n\n    this.record_tag = function (tag){ //function to record a tag and its parent in this.tags Object\n      if (this.tags[tag + 'count']) { //check for the existence of this tag type\n        this.tags[tag + 'count']++;\n        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n      }\n      else { //otherwise initialize this tag type\n        this.tags[tag + 'count'] = 1;\n        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n      }\n      this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)\n      this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')\n    }\n\n    this.retrieve_tag = function (tag) { //function to retrieve the opening tag to the corresponding closer\n      if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it\n        var temp_parent = this.tags.parent; //check to see if it's a closable tag.\n        while (temp_parent) { //till we reach '' (the initial value);\n          if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it\n            break;\n          }\n          temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree\n        }\n        if (temp_parent) { //if we caught something\n          this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly\n          this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent\n        }\n        delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...\n        delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself\n        if (this.tags[tag + 'count'] == 1) {\n          delete this.tags[tag + 'count'];\n        }\n        else {\n          this.tags[tag + 'count']--;\n        }\n      }\n    }\n\n    this.get_tag = function () { //function to get a full tag and parse its type\n      var input_char = '',\n          content = [],\n          space = false,\n          tag_start, tag_end;\n\n      do {\n        if (this.pos >= this.input.length) {\n          return content.length?content.join(''):['', 'TK_EOF'];\n        }\n\n        input_char = this.input.charAt(this.pos);\n        this.pos++;\n        this.line_char_count++;\n\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space\n          space = true;\n          this.line_char_count--;\n          continue;\n        }\n\n        if (input_char === \"'\" || input_char === '\"') {\n          if (!content[1] || content[1] !== '!') { //if we're in a comment strings don't get treated specially\n            input_char += this.get_unformatted(input_char);\n            space = true;\n          }\n        }\n\n        if (input_char === '=') { //no space before =\n          space = false;\n        }\n\n        if (content.length && content[content.length-1] !== '=' && input_char !== '>'\n            && space) { //no space after = or before >\n          if (this.line_char_count >= this.max_char) {\n            this.print_newline(false, content);\n            this.line_char_count = 0;\n          }\n          else {\n            content.push(' ');\n            this.line_char_count++;\n          }\n          space = false;\n        }\n        if (input_char === '<') {\n            tag_start = this.pos - 1;\n        }\n        content.push(input_char); //inserts character at-a-time (or string)\n      } while (input_char !== '>');\n\n      var tag_complete = content.join('');\n      var tag_index;\n      if (tag_complete.indexOf(' ') != -1) { //if there's whitespace, thats where the tag name ends\n        tag_index = tag_complete.indexOf(' ');\n      }\n      else { //otherwise go with the tag ending\n        tag_index = tag_complete.indexOf('>');\n      }\n      var tag_check = tag_complete.substring(1, tag_index).toLowerCase();\n      if (tag_complete.charAt(tag_complete.length-2) === '/' ||\n          this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)\n        this.tag_type = 'SINGLE';\n      }\n      else if (tag_check === 'script') { //for later script handling\n        this.record_tag(tag_check);\n        this.tag_type = 'SCRIPT';\n      }\n      else if (tag_check === 'style') { //for future style handling (for now it justs uses get_content)\n        this.record_tag(tag_check);\n        this.tag_type = 'STYLE';\n      }\n      else if (this.Utils.in_array(tag_check, unformatted)) { // do not reformat the \"unformatted\" tags\n        var comment = this.get_unformatted('</'+tag_check+'>', tag_complete); //...delegate to get_unformatted function\n        content.push(comment);\n        // Preserve collapsed whitespace either before or after this tag.\n        if (tag_start > 0 && this.Utils.in_array(this.input.charAt(tag_start - 1), this.Utils.whitespace)){\n            content.splice(0, 0, this.input.charAt(tag_start - 1));\n        }\n        tag_end = this.pos - 1;\n        if (this.Utils.in_array(this.input.charAt(tag_end + 1), this.Utils.whitespace)){\n            content.push(this.input.charAt(tag_end + 1));\n        }\n        this.tag_type = 'SINGLE';\n      }\n      else if (tag_check.charAt(0) === '!') { //peek for <!-- comment\n        if (tag_check.indexOf('[if') != -1) { //peek for <!--[if conditional comment\n          if (tag_complete.indexOf('!IE') != -1) { //this type needs a closing --> so...\n            var comment = this.get_unformatted('-->', tag_complete); //...delegate to get_unformatted\n            content.push(comment);\n          }\n          this.tag_type = 'START';\n        }\n        else if (tag_check.indexOf('[endif') != -1) {//peek for <!--[endif end conditional comment\n          this.tag_type = 'END';\n          this.unindent();\n        }\n        else if (tag_check.indexOf('[cdata[') != -1) { //if it's a <[cdata[ comment...\n          var comment = this.get_unformatted(']]>', tag_complete); //...delegate to get_unformatted function\n          content.push(comment);\n          this.tag_type = 'SINGLE'; //<![CDATA[ comments are treated like single tags\n        }\n        else {\n          var comment = this.get_unformatted('-->', tag_complete);\n          content.push(comment);\n          this.tag_type = 'SINGLE';\n        }\n      }\n      else {\n        if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending\n          this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors\n          this.tag_type = 'END';\n        }\n        else { //otherwise it's a start-tag\n          this.record_tag(tag_check); //push it on the tag stack\n          this.tag_type = 'START';\n        }\n        if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line\n          this.print_newline(true, this.output);\n        }\n      }\n      return content.join(''); //returns fully formatted tag\n    }\n\n    this.get_unformatted = function (delimiter, orig_tag) { //function to return unformatted content in its entirety\n\n      if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) != -1) {\n        return '';\n      }\n      var input_char = '';\n      var content = '';\n      var space = true;\n      do {\n\n        if (this.pos >= this.input.length) {\n          return content;\n        }\n\n        input_char = this.input.charAt(this.pos);\n        this.pos++\n\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n          if (!space) {\n            this.line_char_count--;\n            continue;\n          }\n          if (input_char === '\\n' || input_char === '\\r') {\n            content += '\\n';\n            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'\n            for (var i=0; i<this.indent_level; i++) {\n              content += this.indent_string;\n            }\n            space = false; //...and make sure other indentation is erased\n            */\n            this.line_char_count = 0;\n            continue;\n          }\n        }\n        content += input_char;\n        this.line_char_count++;\n        space = true;\n\n\n      } while (content.toLowerCase().indexOf(delimiter) == -1);\n      return content;\n    }\n\n    this.get_token = function () { //initial handler for token-retrieval\n      var token;\n\n      if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript\n       var type = this.last_token.substr(7)\n       token = this.get_contents_to(type);\n        if (typeof token !== 'string') {\n          return token;\n        }\n        return [token, 'TK_' + type];\n      }\n      if (this.current_mode === 'CONTENT') {\n        token = this.get_content();\n        if (typeof token !== 'string') {\n          return token;\n        }\n        else {\n          return [token, 'TK_CONTENT'];\n        }\n      }\n\n      if (this.current_mode === 'TAG') {\n        token = this.get_tag();\n        if (typeof token !== 'string') {\n          return token;\n        }\n        else {\n          var tag_name_type = 'TK_TAG_' + this.tag_type;\n          return [token, tag_name_type];\n        }\n      }\n    }\n\n    this.get_full_indent = function (level) {\n      level = this.indent_level + level || 0;\n      if (level < 1)\n        return '';\n\n      return Array(level + 1).join(this.indent_string);\n    }\n\n\n    this.printer = function (js_source, indent_character, indent_size, max_char, brace_style) { //handles input/output and some other printing functions\n\n      this.input = js_source || ''; //gets the input for the Parser\n      this.output = [];\n      this.indent_character = indent_character;\n      this.indent_string = '';\n      this.indent_size = indent_size;\n      this.brace_style = brace_style;\n      this.indent_level = 0;\n      this.max_char = max_char;\n      this.line_char_count = 0; //count to see if max_char was exceeded\n\n      for (var i=0; i<this.indent_size; i++) {\n        this.indent_string += this.indent_character;\n      }\n\n      this.print_newline = function (ignore, arr) {\n        this.line_char_count = 0;\n        if (!arr || !arr.length) {\n          return;\n        }\n        if (!ignore) { //we might want the extra line\n          while (this.Utils.in_array(arr[arr.length-1], this.Utils.whitespace)) {\n            arr.pop();\n          }\n        }\n        arr.push('\\n');\n        for (var i=0; i<this.indent_level; i++) {\n          arr.push(this.indent_string);\n        }\n      }\n\n      this.print_token = function (text) {\n        this.output.push(text);\n      }\n\n      this.indent = function () {\n        this.indent_level++;\n      }\n\n      this.unindent = function () {\n        if (this.indent_level > 0) {\n          this.indent_level--;\n        }\n      }\n    }\n    return this;\n  }\n\n  /*_____________________--------------------_____________________*/\n\n  multi_parser = new Parser(); //wrapping functions Parser\n  multi_parser.printer(html_source, indent_character, indent_size, max_char, brace_style); //initialize starting values\n\n  while (true) {\n      var t = multi_parser.get_token();\n      multi_parser.token_text = t[0];\n      multi_parser.token_type = t[1];\n\n    if (multi_parser.token_type === 'TK_EOF') {\n      break;\n    }\n\n    switch (multi_parser.token_type) {\n      case 'TK_TAG_START':\n        multi_parser.print_newline(false, multi_parser.output);\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.indent();\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_TAG_STYLE':\n      case 'TK_TAG_SCRIPT':\n        multi_parser.print_newline(false, multi_parser.output);\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_TAG_END':\n        //Print new line only if the tag has no content and has child\n        if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {\n            var tag_name = multi_parser.token_text.match(/\\w+/)[0];\n            var tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length -1].match(/<\\s*(\\w+)/);\n            if (tag_extracted_from_last_output === null || tag_extracted_from_last_output[1] !== tag_name)\n                multi_parser.print_newline(true, multi_parser.output);\n        }\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_TAG_SINGLE':\n        // Don't add a newline before elements that should remain unformatted.\n        var tag_check = multi_parser.token_text.match(/^\\s*<([a-z]+)/i);\n        if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)){\n            multi_parser.print_newline(false, multi_parser.output);\n        }\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_CONTENT':\n        if (multi_parser.token_text !== '') {\n          multi_parser.print_token(multi_parser.token_text);\n        }\n        multi_parser.current_mode = 'TAG';\n        break;\n      case 'TK_STYLE':\n      case 'TK_SCRIPT':\n        if (multi_parser.token_text !== '') {\n          multi_parser.output.push('\\n');\n          var text = multi_parser.token_text;\n          if (multi_parser.token_type == 'TK_SCRIPT') {\n            var _beautifier = typeof js_beautify == 'function' && js_beautify;\n          } else if (multi_parser.token_type == 'TK_STYLE') {\n            var _beautifier = typeof css_beautify == 'function' && css_beautify;\n          }\n\n          if (options.indent_scripts == \"keep\") {\n            var script_indent_level = 0;\n          } else if (options.indent_scripts == \"separate\") {\n            var script_indent_level = -multi_parser.indent_level;\n          } else {\n            var script_indent_level = 1;\n          }\n\n          var indentation = multi_parser.get_full_indent(script_indent_level);\n          if (_beautifier) {\n            // call the Beautifier if avaliable\n            text = _beautifier(text.replace(/^\\s*/, indentation), options);\n          } else {\n            // simply indent the string otherwise\n            var white = text.match(/^\\s*/)[0];\n            var _level = white.match(/[^\\n\\r]*$/)[0].split(multi_parser.indent_string).length - 1;\n            var reindent = multi_parser.get_full_indent(script_indent_level -_level);\n            text = text.replace(/^\\s*/, indentation)\n                   .replace(/\\r\\n|\\r|\\n/g, '\\n' + reindent)\n                   .replace(/\\s*$/, '');\n          }\n          if (text) {\n            multi_parser.print_token(text);\n            multi_parser.print_newline(true, multi_parser.output);\n          }\n        }\n        multi_parser.current_mode = 'TAG';\n        break;\n    }\n    multi_parser.last_token = multi_parser.token_type;\n    multi_parser.last_text = multi_parser.token_text;\n  }\n  return multi_parser.output.join('');\n}\n\nmodule.exports = {\n  prettyPrint: style_html\n};","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('./empty')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', './empty'], factory) :\n\t(factory((global.jsondiffpatch = {}),global.chalk));\n}(this, (function (exports,chalk) { 'use strict';\n\nchalk = chalk && chalk.hasOwnProperty('default') ? chalk['default'] : chalk;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar Processor = function () {\n  function Processor(options) {\n    classCallCheck(this, Processor);\n\n    this.selfOptions = options || {};\n    this.pipes = {};\n  }\n\n  createClass(Processor, [{\n    key: 'options',\n    value: function options(_options) {\n      if (_options) {\n        this.selfOptions = _options;\n      }\n      return this.selfOptions;\n    }\n  }, {\n    key: 'pipe',\n    value: function pipe(name, pipeArg) {\n      var pipe = pipeArg;\n      if (typeof name === 'string') {\n        if (typeof pipe === 'undefined') {\n          return this.pipes[name];\n        } else {\n          this.pipes[name] = pipe;\n        }\n      }\n      if (name && name.name) {\n        pipe = name;\n        if (pipe.processor === this) {\n          return pipe;\n        }\n        this.pipes[pipe.name] = pipe;\n      }\n      pipe.processor = this;\n      return pipe;\n    }\n  }, {\n    key: 'process',\n    value: function process(input, pipe) {\n      var context = input;\n      context.options = this.options();\n      var nextPipe = pipe || input.pipe || 'default';\n      var lastPipe = void 0;\n      var lastContext = void 0;\n      while (nextPipe) {\n        if (typeof context.nextAfterChildren !== 'undefined') {\n          // children processed and coming back to parent\n          context.next = context.nextAfterChildren;\n          context.nextAfterChildren = null;\n        }\n\n        if (typeof nextPipe === 'string') {\n          nextPipe = this.pipe(nextPipe);\n        }\n        nextPipe.process(context);\n        lastContext = context;\n        lastPipe = nextPipe;\n        nextPipe = null;\n        if (context) {\n          if (context.next) {\n            context = context.next;\n            nextPipe = lastContext.nextPipe || context.pipe || lastPipe;\n          }\n        }\n      }\n      return context.hasResult ? context.result : undefined;\n    }\n  }]);\n  return Processor;\n}();\n\nvar Pipe = function () {\n  function Pipe(name) {\n    classCallCheck(this, Pipe);\n\n    this.name = name;\n    this.filters = [];\n  }\n\n  createClass(Pipe, [{\n    key: 'process',\n    value: function process(input) {\n      if (!this.processor) {\n        throw new Error('add this pipe to a processor before using it');\n      }\n      var debug = this.debug;\n      var length = this.filters.length;\n      var context = input;\n      for (var index = 0; index < length; index++) {\n        var filter = this.filters[index];\n        if (debug) {\n          this.log('filter: ' + filter.filterName);\n        }\n        filter(context);\n        if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) === 'object' && context.exiting) {\n          context.exiting = false;\n          break;\n        }\n      }\n      if (!context.next && this.resultCheck) {\n        this.resultCheck(context);\n      }\n    }\n  }, {\n    key: 'log',\n    value: function log(msg) {\n      console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);\n    }\n  }, {\n    key: 'append',\n    value: function append() {\n      var _filters;\n\n      (_filters = this.filters).push.apply(_filters, arguments);\n      return this;\n    }\n  }, {\n    key: 'prepend',\n    value: function prepend() {\n      var _filters2;\n\n      (_filters2 = this.filters).unshift.apply(_filters2, arguments);\n      return this;\n    }\n  }, {\n    key: 'indexOf',\n    value: function indexOf(filterName) {\n      if (!filterName) {\n        throw new Error('a filter name is required');\n      }\n      for (var index = 0; index < this.filters.length; index++) {\n        var filter = this.filters[index];\n        if (filter.filterName === filterName) {\n          return index;\n        }\n      }\n      throw new Error('filter not found: ' + filterName);\n    }\n  }, {\n    key: 'list',\n    value: function list() {\n      return this.filters.map(function (f) {\n        return f.filterName;\n      });\n    }\n  }, {\n    key: 'after',\n    value: function after(filterName) {\n      var index = this.indexOf(filterName);\n      var params = Array.prototype.slice.call(arguments, 1);\n      if (!params.length) {\n        throw new Error('a filter is required');\n      }\n      params.unshift(index + 1, 0);\n      Array.prototype.splice.apply(this.filters, params);\n      return this;\n    }\n  }, {\n    key: 'before',\n    value: function before(filterName) {\n      var index = this.indexOf(filterName);\n      var params = Array.prototype.slice.call(arguments, 1);\n      if (!params.length) {\n        throw new Error('a filter is required');\n      }\n      params.unshift(index, 0);\n      Array.prototype.splice.apply(this.filters, params);\n      return this;\n    }\n  }, {\n    key: 'replace',\n    value: function replace(filterName) {\n      var index = this.indexOf(filterName);\n      var params = Array.prototype.slice.call(arguments, 1);\n      if (!params.length) {\n        throw new Error('a filter is required');\n      }\n      params.unshift(index, 1);\n      Array.prototype.splice.apply(this.filters, params);\n      return this;\n    }\n  }, {\n    key: 'remove',\n    value: function remove(filterName) {\n      var index = this.indexOf(filterName);\n      this.filters.splice(index, 1);\n      return this;\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.filters.length = 0;\n      return this;\n    }\n  }, {\n    key: 'shouldHaveResult',\n    value: function shouldHaveResult(should) {\n      if (should === false) {\n        this.resultCheck = null;\n        return;\n      }\n      if (this.resultCheck) {\n        return;\n      }\n      var pipe = this;\n      this.resultCheck = function (context) {\n        if (!context.hasResult) {\n          console.log(context);\n          var error = new Error(pipe.name + ' failed');\n          error.noResult = true;\n          throw error;\n        }\n      };\n      return this;\n    }\n  }]);\n  return Pipe;\n}();\n\nvar Context = function () {\n  function Context() {\n    classCallCheck(this, Context);\n  }\n\n  createClass(Context, [{\n    key: 'setResult',\n    value: function setResult(result) {\n      this.result = result;\n      this.hasResult = true;\n      return this;\n    }\n  }, {\n    key: 'exit',\n    value: function exit() {\n      this.exiting = true;\n      return this;\n    }\n  }, {\n    key: 'switchTo',\n    value: function switchTo(next, pipe) {\n      if (typeof next === 'string' || next instanceof Pipe) {\n        this.nextPipe = next;\n      } else {\n        this.next = next;\n        if (pipe) {\n          this.nextPipe = pipe;\n        }\n      }\n      return this;\n    }\n  }, {\n    key: 'push',\n    value: function push(child, name) {\n      child.parent = this;\n      if (typeof name !== 'undefined') {\n        child.childName = name;\n      }\n      child.root = this.root || this;\n      child.options = child.options || this.options;\n      if (!this.children) {\n        this.children = [child];\n        this.nextAfterChildren = this.next || null;\n        this.next = child;\n      } else {\n        this.children[this.children.length - 1].next = child;\n        this.children.push(child);\n      }\n      child.next = this;\n      return this;\n    }\n  }]);\n  return Context;\n}();\n\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n  return a instanceof Array;\n};\n\nfunction cloneRegExp(re) {\n  var regexMatch = /^\\/(.*)\\/([gimyu]*)$/.exec(re.toString());\n  return new RegExp(regexMatch[1], regexMatch[2]);\n}\n\nfunction clone(arg) {\n  if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) !== 'object') {\n    return arg;\n  }\n  if (arg === null) {\n    return null;\n  }\n  if (isArray(arg)) {\n    return arg.map(clone);\n  }\n  if (arg instanceof Date) {\n    return new Date(arg.getTime());\n  }\n  if (arg instanceof RegExp) {\n    return cloneRegExp(arg);\n  }\n  var cloned = {};\n  for (var name in arg) {\n    if (Object.prototype.hasOwnProperty.call(arg, name)) {\n      cloned[name] = clone(arg[name]);\n    }\n  }\n  return cloned;\n}\n\nvar DiffContext = function (_Context) {\n  inherits(DiffContext, _Context);\n\n  function DiffContext(left, right) {\n    classCallCheck(this, DiffContext);\n\n    var _this = possibleConstructorReturn(this, (DiffContext.__proto__ || Object.getPrototypeOf(DiffContext)).call(this));\n\n    _this.left = left;\n    _this.right = right;\n    _this.pipe = 'diff';\n    return _this;\n  }\n\n  createClass(DiffContext, [{\n    key: 'setResult',\n    value: function setResult(result) {\n      if (this.options.cloneDiffValues && (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {\n        var clone$$1 = typeof this.options.cloneDiffValues === 'function' ? this.options.cloneDiffValues : clone;\n        if (_typeof(result[0]) === 'object') {\n          result[0] = clone$$1(result[0]);\n        }\n        if (_typeof(result[1]) === 'object') {\n          result[1] = clone$$1(result[1]);\n        }\n      }\n      return Context.prototype.setResult.apply(this, arguments);\n    }\n  }]);\n  return DiffContext;\n}(Context);\n\nvar PatchContext = function (_Context) {\n  inherits(PatchContext, _Context);\n\n  function PatchContext(left, delta) {\n    classCallCheck(this, PatchContext);\n\n    var _this = possibleConstructorReturn(this, (PatchContext.__proto__ || Object.getPrototypeOf(PatchContext)).call(this));\n\n    _this.left = left;\n    _this.delta = delta;\n    _this.pipe = 'patch';\n    return _this;\n  }\n\n  return PatchContext;\n}(Context);\n\nvar ReverseContext = function (_Context) {\n  inherits(ReverseContext, _Context);\n\n  function ReverseContext(delta) {\n    classCallCheck(this, ReverseContext);\n\n    var _this = possibleConstructorReturn(this, (ReverseContext.__proto__ || Object.getPrototypeOf(ReverseContext)).call(this));\n\n    _this.delta = delta;\n    _this.pipe = 'reverse';\n    return _this;\n  }\n\n  return ReverseContext;\n}(Context);\n\nvar isArray$1 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n  return a instanceof Array;\n};\n\nvar diffFilter = function trivialMatchesDiffFilter(context) {\n  if (context.left === context.right) {\n    context.setResult(undefined).exit();\n    return;\n  }\n  if (typeof context.left === 'undefined') {\n    if (typeof context.right === 'function') {\n      throw new Error('functions are not supported');\n    }\n    context.setResult([context.right]).exit();\n    return;\n  }\n  if (typeof context.right === 'undefined') {\n    context.setResult([context.left, 0, 0]).exit();\n    return;\n  }\n  if (typeof context.left === 'function' || typeof context.right === 'function') {\n    throw new Error('functions are not supported');\n  }\n  context.leftType = context.left === null ? 'null' : _typeof(context.left);\n  context.rightType = context.right === null ? 'null' : _typeof(context.right);\n  if (context.leftType !== context.rightType) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  if (context.leftType === 'boolean' || context.leftType === 'number') {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  if (context.leftType === 'object') {\n    context.leftIsArray = isArray$1(context.left);\n  }\n  if (context.rightType === 'object') {\n    context.rightIsArray = isArray$1(context.right);\n  }\n  if (context.leftIsArray !== context.rightIsArray) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n\n  if (context.left instanceof RegExp) {\n    if (context.right instanceof RegExp) {\n      context.setResult([context.left.toString(), context.right.toString()]).exit();\n    } else {\n      context.setResult([context.left, context.right]).exit();\n    }\n  }\n};\ndiffFilter.filterName = 'trivial';\n\nvar patchFilter = function trivialMatchesPatchFilter(context) {\n  if (typeof context.delta === 'undefined') {\n    context.setResult(context.left).exit();\n    return;\n  }\n  context.nested = !isArray$1(context.delta);\n  if (context.nested) {\n    return;\n  }\n  if (context.delta.length === 1) {\n    context.setResult(context.delta[0]).exit();\n    return;\n  }\n  if (context.delta.length === 2) {\n    if (context.left instanceof RegExp) {\n      var regexArgs = /^\\/(.*)\\/([gimyu]+)$/.exec(context.delta[1]);\n      if (regexArgs) {\n        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();\n        return;\n      }\n    }\n    context.setResult(context.delta[1]).exit();\n    return;\n  }\n  if (context.delta.length === 3 && context.delta[2] === 0) {\n    context.setResult(undefined).exit();\n  }\n};\npatchFilter.filterName = 'trivial';\n\nvar reverseFilter = function trivialReferseFilter(context) {\n  if (typeof context.delta === 'undefined') {\n    context.setResult(context.delta).exit();\n    return;\n  }\n  context.nested = !isArray$1(context.delta);\n  if (context.nested) {\n    return;\n  }\n  if (context.delta.length === 1) {\n    context.setResult([context.delta[0], 0, 0]).exit();\n    return;\n  }\n  if (context.delta.length === 2) {\n    context.setResult([context.delta[1], context.delta[0]]).exit();\n    return;\n  }\n  if (context.delta.length === 3 && context.delta[2] === 0) {\n    context.setResult([context.delta[0]]).exit();\n  }\n};\nreverseFilter.filterName = 'trivial';\n\nfunction collectChildrenDiffFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  var length = context.children.length;\n  var child = void 0;\n  var result = context.result;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (typeof child.result === 'undefined') {\n      continue;\n    }\n    result = result || {};\n    result[child.childName] = child.result;\n  }\n  if (result && context.leftIsArray) {\n    result._t = 'a';\n  }\n  context.setResult(result).exit();\n}\ncollectChildrenDiffFilter.filterName = 'collectChildren';\n\nfunction objectsDiffFilter(context) {\n  if (context.leftIsArray || context.leftType !== 'object') {\n    return;\n  }\n\n  var name = void 0;\n  var child = void 0;\n  var propertyFilter = context.options.propertyFilter;\n  for (name in context.left) {\n    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {\n      continue;\n    }\n    if (propertyFilter && !propertyFilter(name, context)) {\n      continue;\n    }\n    child = new DiffContext(context.left[name], context.right[name]);\n    context.push(child, name);\n  }\n  for (name in context.right) {\n    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {\n      continue;\n    }\n    if (propertyFilter && !propertyFilter(name, context)) {\n      continue;\n    }\n    if (typeof context.left[name] === 'undefined') {\n      child = new DiffContext(undefined, context.right[name]);\n      context.push(child, name);\n    }\n  }\n\n  if (!context.children || context.children.length === 0) {\n    context.setResult(undefined).exit();\n    return;\n  }\n  context.exit();\n}\nobjectsDiffFilter.filterName = 'objects';\n\nvar patchFilter$1 = function nestedPatchFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var name = void 0;\n  var child = void 0;\n  for (name in context.delta) {\n    child = new PatchContext(context.left[name], context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\npatchFilter$1.filterName = 'objects';\n\nvar collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var length = context.children.length;\n  var child = void 0;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === undefined) {\n      delete context.left[child.childName];\n    } else if (context.left[child.childName] !== child.result) {\n      context.left[child.childName] = child.result;\n    }\n  }\n  context.setResult(context.left).exit();\n};\ncollectChildrenPatchFilter.filterName = 'collectChildren';\n\nvar reverseFilter$1 = function nestedReverseFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var name = void 0;\n  var child = void 0;\n  for (name in context.delta) {\n    child = new ReverseContext(context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\nreverseFilter$1.filterName = 'objects';\n\nfunction collectChildrenReverseFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var length = context.children.length;\n  var child = void 0;\n  var delta = {};\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (delta[child.childName] !== child.result) {\n      delta[child.childName] = child.result;\n    }\n  }\n  context.setResult(delta).exit();\n}\ncollectChildrenReverseFilter.filterName = 'collectChildren';\n\n/*\n\nLCS implementation that supports arrays or strings\n\nreference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n\n*/\n\nvar defaultMatch = function defaultMatch(array1, array2, index1, index2) {\n  return array1[index1] === array2[index2];\n};\n\nvar lengthMatrix = function lengthMatrix(array1, array2, match, context) {\n  var len1 = array1.length;\n  var len2 = array2.length;\n  var x = void 0,\n      y = void 0;\n\n  // initialize empty matrix of len1+1 x len2+1\n  var matrix = [len1 + 1];\n  for (x = 0; x < len1 + 1; x++) {\n    matrix[x] = [len2 + 1];\n    for (y = 0; y < len2 + 1; y++) {\n      matrix[x][y] = 0;\n    }\n  }\n  matrix.match = match;\n  // save sequence lengths for each coordinate\n  for (x = 1; x < len1 + 1; x++) {\n    for (y = 1; y < len2 + 1; y++) {\n      if (match(array1, array2, x - 1, y - 1, context)) {\n        matrix[x][y] = matrix[x - 1][y - 1] + 1;\n      } else {\n        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);\n      }\n    }\n  }\n  return matrix;\n};\n\nvar backtrack = function backtrack(matrix, array1, array2, context) {\n  var index1 = array1.length;\n  var index2 = array2.length;\n  var subsequence = {\n    sequence: [],\n    indices1: [],\n    indices2: []\n  };\n\n  while (index1 !== 0 && index2 !== 0) {\n    var sameLetter = matrix.match(array1, array2, index1 - 1, index2 - 1, context);\n    if (sameLetter) {\n      subsequence.sequence.unshift(array1[index1 - 1]);\n      subsequence.indices1.unshift(index1 - 1);\n      subsequence.indices2.unshift(index2 - 1);\n      --index1;\n      --index2;\n    } else {\n      var valueAtMatrixAbove = matrix[index1][index2 - 1];\n      var valueAtMatrixLeft = matrix[index1 - 1][index2];\n      if (valueAtMatrixAbove > valueAtMatrixLeft) {\n        --index2;\n      } else {\n        --index1;\n      }\n    }\n  }\n  return subsequence;\n};\n\nvar get$1 = function get(array1, array2, match, context) {\n  var innerContext = context || {};\n  var matrix = lengthMatrix(array1, array2, match || defaultMatch, innerContext);\n  var result = backtrack(matrix, array1, array2, innerContext);\n  if (typeof array1 === 'string' && typeof array2 === 'string') {\n    result.sequence = result.sequence.join('');\n  }\n  return result;\n};\n\nvar lcs = {\n  get: get$1\n};\n\nvar ARRAY_MOVE = 3;\n\nvar isArray$2 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n  return a instanceof Array;\n};\n\nvar arrayIndexOf = typeof Array.prototype.indexOf === 'function' ? function (array, item) {\n  return array.indexOf(item);\n} : function (array, item) {\n  var length = array.length;\n  for (var i = 0; i < length; i++) {\n    if (array[i] === item) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nfunction arraysHaveMatchByRef(array1, array2, len1, len2) {\n  for (var index1 = 0; index1 < len1; index1++) {\n    var val1 = array1[index1];\n    for (var index2 = 0; index2 < len2; index2++) {\n      var val2 = array2[index2];\n      if (index1 !== index2 && val1 === val2) {\n        return true;\n      }\n    }\n  }\n}\n\nfunction matchItems(array1, array2, index1, index2, context) {\n  var value1 = array1[index1];\n  var value2 = array2[index2];\n  if (value1 === value2) {\n    return true;\n  }\n  if ((typeof value1 === 'undefined' ? 'undefined' : _typeof(value1)) !== 'object' || (typeof value2 === 'undefined' ? 'undefined' : _typeof(value2)) !== 'object') {\n    return false;\n  }\n  var objectHash = context.objectHash;\n  if (!objectHash) {\n    // no way to match objects was provided, try match by position\n    return context.matchByPosition && index1 === index2;\n  }\n  var hash1 = void 0;\n  var hash2 = void 0;\n  if (typeof index1 === 'number') {\n    context.hashCache1 = context.hashCache1 || [];\n    hash1 = context.hashCache1[index1];\n    if (typeof hash1 === 'undefined') {\n      context.hashCache1[index1] = hash1 = objectHash(value1, index1);\n    }\n  } else {\n    hash1 = objectHash(value1);\n  }\n  if (typeof hash1 === 'undefined') {\n    return false;\n  }\n  if (typeof index2 === 'number') {\n    context.hashCache2 = context.hashCache2 || [];\n    hash2 = context.hashCache2[index2];\n    if (typeof hash2 === 'undefined') {\n      context.hashCache2[index2] = hash2 = objectHash(value2, index2);\n    }\n  } else {\n    hash2 = objectHash(value2);\n  }\n  if (typeof hash2 === 'undefined') {\n    return false;\n  }\n  return hash1 === hash2;\n}\n\nvar diffFilter$1 = function arraysDiffFilter(context) {\n  if (!context.leftIsArray) {\n    return;\n  }\n\n  var matchContext = {\n    objectHash: context.options && context.options.objectHash,\n    matchByPosition: context.options && context.options.matchByPosition\n  };\n  var commonHead = 0;\n  var commonTail = 0;\n  var index = void 0;\n  var index1 = void 0;\n  var index2 = void 0;\n  var array1 = context.left;\n  var array2 = context.right;\n  var len1 = array1.length;\n  var len2 = array2.length;\n\n  var child = void 0;\n\n  if (len1 > 0 && len2 > 0 && !matchContext.objectHash && typeof matchContext.matchByPosition !== 'boolean') {\n    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);\n  }\n\n  // separate common head\n  while (commonHead < len1 && commonHead < len2 && matchItems(array1, array2, commonHead, commonHead, matchContext)) {\n    index = commonHead;\n    child = new DiffContext(context.left[index], context.right[index]);\n    context.push(child, index);\n    commonHead++;\n  }\n  // separate common tail\n  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 && matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {\n    index1 = len1 - 1 - commonTail;\n    index2 = len2 - 1 - commonTail;\n    child = new DiffContext(context.left[index1], context.right[index2]);\n    context.push(child, index2);\n    commonTail++;\n  }\n  var result = void 0;\n  if (commonHead + commonTail === len1) {\n    if (len1 === len2) {\n      // arrays are identical\n      context.setResult(undefined).exit();\n      return;\n    }\n    // trivial case, a block (1 or more consecutive items) was added\n    result = result || {\n      _t: 'a'\n    };\n    for (index = commonHead; index < len2 - commonTail; index++) {\n      result[index] = [array2[index]];\n    }\n    context.setResult(result).exit();\n    return;\n  }\n  if (commonHead + commonTail === len2) {\n    // trivial case, a block (1 or more consecutive items) was removed\n    result = result || {\n      _t: 'a'\n    };\n    for (index = commonHead; index < len1 - commonTail; index++) {\n      result['_' + index] = [array1[index], 0, 0];\n    }\n    context.setResult(result).exit();\n    return;\n  }\n  // reset hash cache\n  delete matchContext.hashCache1;\n  delete matchContext.hashCache2;\n\n  // diff is not trivial, find the LCS (Longest Common Subsequence)\n  var trimmed1 = array1.slice(commonHead, len1 - commonTail);\n  var trimmed2 = array2.slice(commonHead, len2 - commonTail);\n  var seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext);\n  var removedItems = [];\n  result = result || {\n    _t: 'a'\n  };\n  for (index = commonHead; index < len1 - commonTail; index++) {\n    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {\n      // removed\n      result['_' + index] = [array1[index], 0, 0];\n      removedItems.push(index);\n    }\n  }\n\n  var detectMove = true;\n  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {\n    detectMove = false;\n  }\n  var includeValueOnMove = false;\n  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {\n    includeValueOnMove = true;\n  }\n\n  var removedItemsLength = removedItems.length;\n  for (index = commonHead; index < len2 - commonTail; index++) {\n    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);\n    if (indexOnArray2 < 0) {\n      // added, try to match with a removed item and register as position move\n      var isMove = false;\n      if (detectMove && removedItemsLength > 0) {\n        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {\n          index1 = removedItems[removeItemIndex1];\n          if (matchItems(trimmed1, trimmed2, index1 - commonHead, index - commonHead, matchContext)) {\n            // store position move as: [originalValue, newPosition, ARRAY_MOVE]\n            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);\n            if (!includeValueOnMove) {\n              // don't include moved value on diff, to save bytes\n              result['_' + index1][0] = '';\n            }\n\n            index2 = index;\n            child = new DiffContext(context.left[index1], context.right[index2]);\n            context.push(child, index2);\n            removedItems.splice(removeItemIndex1, 1);\n            isMove = true;\n            break;\n          }\n        }\n      }\n      if (!isMove) {\n        // added\n        result[index] = [array2[index]];\n      }\n    } else {\n      // match, do inner diff\n      index1 = seq.indices1[indexOnArray2] + commonHead;\n      index2 = seq.indices2[indexOnArray2] + commonHead;\n      child = new DiffContext(context.left[index1], context.right[index2]);\n      context.push(child, index2);\n    }\n  }\n\n  context.setResult(result).exit();\n};\ndiffFilter$1.filterName = 'arrays';\n\nvar compare = {\n  numerically: function numerically(a, b) {\n    return a - b;\n  },\n  numericallyBy: function numericallyBy(name) {\n    return function (a, b) {\n      return a[name] - b[name];\n    };\n  }\n};\n\nvar patchFilter$2 = function nestedPatchFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var index = void 0;\n  var index1 = void 0;\n\n  var delta = context.delta;\n  var array = context.left;\n\n  // first, separate removals, insertions and modifications\n  var toRemove = [];\n  var toInsert = [];\n  var toModify = [];\n  for (index in delta) {\n    if (index !== '_t') {\n      if (index[0] === '_') {\n        // removed item from original array\n        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {\n          toRemove.push(parseInt(index.slice(1), 10));\n        } else {\n          throw new Error('only removal or move can be applied at original array indices,' + (' invalid diff type: ' + delta[index][2]));\n        }\n      } else {\n        if (delta[index].length === 1) {\n          // added item at new array\n          toInsert.push({\n            index: parseInt(index, 10),\n            value: delta[index][0]\n          });\n        } else {\n          // modified item at new array\n          toModify.push({\n            index: parseInt(index, 10),\n            delta: delta[index]\n          });\n        }\n      }\n    }\n  }\n\n  // remove items, in reverse order to avoid sawing our own floor\n  toRemove = toRemove.sort(compare.numerically);\n  for (index = toRemove.length - 1; index >= 0; index--) {\n    index1 = toRemove[index];\n    var indexDiff = delta['_' + index1];\n    var removedValue = array.splice(index1, 1)[0];\n    if (indexDiff[2] === ARRAY_MOVE) {\n      // reinsert later\n      toInsert.push({\n        index: indexDiff[1],\n        value: removedValue\n      });\n    }\n  }\n\n  // insert items, in reverse order to avoid moving our own floor\n  toInsert = toInsert.sort(compare.numericallyBy('index'));\n  var toInsertLength = toInsert.length;\n  for (index = 0; index < toInsertLength; index++) {\n    var insertion = toInsert[index];\n    array.splice(insertion.index, 0, insertion.value);\n  }\n\n  // apply modifications\n  var toModifyLength = toModify.length;\n  var child = void 0;\n  if (toModifyLength > 0) {\n    for (index = 0; index < toModifyLength; index++) {\n      var modification = toModify[index];\n      child = new PatchContext(context.left[modification.index], modification.delta);\n      context.push(child, modification.index);\n    }\n  }\n\n  if (!context.children) {\n    context.setResult(context.left).exit();\n    return;\n  }\n  context.exit();\n};\npatchFilter$2.filterName = 'arrays';\n\nvar collectChildrenPatchFilter$1 = function collectChildrenPatchFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var length = context.children.length;\n  var child = void 0;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    context.left[child.childName] = child.result;\n  }\n  context.setResult(context.left).exit();\n};\ncollectChildrenPatchFilter$1.filterName = 'arraysCollectChildren';\n\nvar reverseFilter$2 = function arraysReverseFilter(context) {\n  if (!context.nested) {\n    if (context.delta[2] === ARRAY_MOVE) {\n      context.newName = '_' + context.delta[1];\n      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();\n    }\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var name = void 0;\n  var child = void 0;\n  for (name in context.delta) {\n    if (name === '_t') {\n      continue;\n    }\n    child = new ReverseContext(context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\nreverseFilter$2.filterName = 'arrays';\n\nvar reverseArrayDeltaIndex = function reverseArrayDeltaIndex(delta, index, itemDelta) {\n  if (typeof index === 'string' && index[0] === '_') {\n    return parseInt(index.substr(1), 10);\n  } else if (isArray$2(itemDelta) && itemDelta[2] === 0) {\n    return '_' + index;\n  }\n\n  var reverseIndex = +index;\n  for (var deltaIndex in delta) {\n    var deltaItem = delta[deltaIndex];\n    if (isArray$2(deltaItem)) {\n      if (deltaItem[2] === ARRAY_MOVE) {\n        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);\n        var moveToIndex = deltaItem[1];\n        if (moveToIndex === +index) {\n          return moveFromIndex;\n        }\n        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {\n          reverseIndex++;\n        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {\n          reverseIndex--;\n        }\n      } else if (deltaItem[2] === 0) {\n        var deleteIndex = parseInt(deltaIndex.substr(1), 10);\n        if (deleteIndex <= reverseIndex) {\n          reverseIndex++;\n        }\n      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {\n        reverseIndex--;\n      }\n    }\n  }\n\n  return reverseIndex;\n};\n\nfunction collectChildrenReverseFilter$1(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var length = context.children.length;\n  var child = void 0;\n  var delta = {\n    _t: 'a'\n  };\n\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    var name = child.newName;\n    if (typeof name === 'undefined') {\n      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);\n    }\n    if (delta[name] !== child.result) {\n      delta[name] = child.result;\n    }\n  }\n  context.setResult(delta).exit();\n}\ncollectChildrenReverseFilter$1.filterName = 'arraysCollectChildren';\n\nvar diffFilter$2 = function datesDiffFilter(context) {\n  if (context.left instanceof Date) {\n    if (context.right instanceof Date) {\n      if (context.left.getTime() !== context.right.getTime()) {\n        context.setResult([context.left, context.right]);\n      } else {\n        context.setResult(undefined);\n      }\n    } else {\n      context.setResult([context.left, context.right]);\n    }\n    context.exit();\n  } else if (context.right instanceof Date) {\n    context.setResult([context.left, context.right]).exit();\n  }\n};\ndiffFilter$2.filterName = 'dates';\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar diffMatchPatch = createCommonjsModule(function (module) {\n/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nfunction diff_match_patch() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n}\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/** @typedef {{0: number, 1: string}} */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n             [DIFF_EQUAL, shorttext],\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, '']);\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = a.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, a[j]);\n          }\n          pointer = pointer + a.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n      lineStart = lineEnd + 1;\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n    }\n    return chars;\n  }\n\n  var chars1 = diff_linesToCharsMunge_(text1);\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var x = 0; x < diffs.length; x++) {\n    var chars = diffs[x][1];\n    var text = [];\n    for (var y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)];\n    }\n    diffs[x][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastequality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastequality && (lastequality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastequality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastequality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastequality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastequality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastequality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastequality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_insert,\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete,\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\n                [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert +\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\n        } else {\n          diffs[diffsLength++] = [DIFF_DELETE, text];\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push([DIFF_EQUAL, suffix]);\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] = patch.diffs[y].slice();\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push([DIFF_EQUAL, nullPadding]);\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push([DIFF_EQUAL, precontext]);\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push([diff_type, diff_text]);\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push([diff_type, diff_text]);\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push([DIFF_EQUAL, postcontext]);\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push([DIFF_DELETE, line]);\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push([DIFF_INSERT, line]);\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push([DIFF_EQUAL, line]);\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emmulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indicies are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports['diff_match_patch'] = diff_match_patch;\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;\n});\n\n/* global diff_match_patch */\nvar TEXT_DIFF = 2;\nvar DEFAULT_MIN_LENGTH = 60;\nvar cachedDiffPatch = null;\n\nvar getDiffMatchPatch = function getDiffMatchPatch(required) {\n  /* jshint camelcase: false */\n\n  if (!cachedDiffPatch) {\n    var instance = void 0;\n    /* eslint-disable camelcase, new-cap */\n    if (typeof diff_match_patch !== 'undefined') {\n      // already loaded, probably a browser\n      instance = typeof diff_match_patch === 'function' ? new diff_match_patch() : new diff_match_patch.diff_match_patch();\n    } else if (diffMatchPatch) {\n      try {\n        instance = diffMatchPatch && new diffMatchPatch();\n      } catch (err) {\n        instance = null;\n      }\n    }\n    /* eslint-enable camelcase, new-cap */\n    if (!instance) {\n      if (!required) {\n        return null;\n      }\n      var error = new Error('text diff_match_patch library not found');\n      // eslint-disable-next-line camelcase\n      error.diff_match_patch_not_found = true;\n      throw error;\n    }\n    cachedDiffPatch = {\n      diff: function diff(txt1, txt2) {\n        return instance.patch_toText(instance.patch_make(txt1, txt2));\n      },\n      patch: function patch(txt1, _patch) {\n        var results = instance.patch_apply(instance.patch_fromText(_patch), txt1);\n        for (var i = 0; i < results[1].length; i++) {\n          if (!results[1][i]) {\n            var _error = new Error('text patch failed');\n            _error.textPatchFailed = true;\n          }\n        }\n        return results[0];\n      }\n    };\n  }\n  return cachedDiffPatch;\n};\n\nvar diffFilter$3 = function textsDiffFilter(context) {\n  if (context.leftType !== 'string') {\n    return;\n  }\n  var minLength = context.options && context.options.textDiff && context.options.textDiff.minLength || DEFAULT_MIN_LENGTH;\n  if (context.left.length < minLength || context.right.length < minLength) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  // large text, try to use a text-diff algorithm\n  var diffMatchPatch$$1 = getDiffMatchPatch();\n  if (!diffMatchPatch$$1) {\n    // diff-match-patch library not available,\n    // fallback to regular string replace\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  var diff = diffMatchPatch$$1.diff;\n  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();\n};\ndiffFilter$3.filterName = 'texts';\n\nvar patchFilter$3 = function textsPatchFilter(context) {\n  if (context.nested) {\n    return;\n  }\n  if (context.delta[2] !== TEXT_DIFF) {\n    return;\n  }\n\n  // text-diff, use a text-patch algorithm\n  var patch = getDiffMatchPatch(true).patch;\n  context.setResult(patch(context.left, context.delta[0])).exit();\n};\npatchFilter$3.filterName = 'texts';\n\nvar textDeltaReverse = function textDeltaReverse(delta) {\n  var i = void 0;\n  var l = void 0;\n  var lines = void 0;\n  var line = void 0;\n  var lineTmp = void 0;\n  var header = null;\n  var headerRegex = /^@@ +-(\\d+),(\\d+) +\\+(\\d+),(\\d+) +@@$/;\n  var lineHeader = void 0;\n  lines = delta.split('\\n');\n  for (i = 0, l = lines.length; i < l; i++) {\n    line = lines[i];\n    var lineStart = line.slice(0, 1);\n    if (lineStart === '@') {\n      header = headerRegex.exec(line);\n      lineHeader = i;\n\n      // fix header\n      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';\n    } else if (lineStart === '+') {\n      lines[i] = '-' + lines[i].slice(1);\n      if (lines[i - 1].slice(0, 1) === '+') {\n        // swap lines to keep default order (-+)\n        lineTmp = lines[i];\n        lines[i] = lines[i - 1];\n        lines[i - 1] = lineTmp;\n      }\n    } else if (lineStart === '-') {\n      lines[i] = '+' + lines[i].slice(1);\n    }\n  }\n  return lines.join('\\n');\n};\n\nvar reverseFilter$3 = function textsReverseFilter(context) {\n  if (context.nested) {\n    return;\n  }\n  if (context.delta[2] !== TEXT_DIFF) {\n    return;\n  }\n\n  // text-diff, use a text-diff algorithm\n  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();\n};\nreverseFilter$3.filterName = 'texts';\n\nvar DiffPatcher = function () {\n  function DiffPatcher(options) {\n    classCallCheck(this, DiffPatcher);\n\n    this.processor = new Processor(options);\n    this.processor.pipe(new Pipe('diff').append(collectChildrenDiffFilter, diffFilter, diffFilter$2, diffFilter$3, objectsDiffFilter, diffFilter$1).shouldHaveResult());\n    this.processor.pipe(new Pipe('patch').append(collectChildrenPatchFilter, collectChildrenPatchFilter$1, patchFilter, patchFilter$3, patchFilter$1, patchFilter$2).shouldHaveResult());\n    this.processor.pipe(new Pipe('reverse').append(collectChildrenReverseFilter, collectChildrenReverseFilter$1, reverseFilter, reverseFilter$3, reverseFilter$1, reverseFilter$2).shouldHaveResult());\n  }\n\n  createClass(DiffPatcher, [{\n    key: 'options',\n    value: function options() {\n      var _processor;\n\n      return (_processor = this.processor).options.apply(_processor, arguments);\n    }\n  }, {\n    key: 'diff',\n    value: function diff(left, right) {\n      return this.processor.process(new DiffContext(left, right));\n    }\n  }, {\n    key: 'patch',\n    value: function patch(left, delta) {\n      return this.processor.process(new PatchContext(left, delta));\n    }\n  }, {\n    key: 'reverse',\n    value: function reverse(delta) {\n      return this.processor.process(new ReverseContext(delta));\n    }\n  }, {\n    key: 'unpatch',\n    value: function unpatch(right, delta) {\n      return this.patch(right, this.reverse(delta));\n    }\n  }, {\n    key: 'clone',\n    value: function clone$$1(value) {\n      return clone(value);\n    }\n  }]);\n  return DiffPatcher;\n}();\n\nvar isArray$3 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n  return a instanceof Array;\n};\n\nvar getObjectKeys = typeof Object.keys === 'function' ? function (obj) {\n  return Object.keys(obj);\n} : function (obj) {\n  var names = [];\n  for (var property in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, property)) {\n      names.push(property);\n    }\n  }\n  return names;\n};\n\nvar trimUnderscore = function trimUnderscore(str) {\n  if (str.substr(0, 1) === '_') {\n    return str.slice(1);\n  }\n  return str;\n};\n\nvar arrayKeyToSortNumber = function arrayKeyToSortNumber(key) {\n  if (key === '_t') {\n    return -1;\n  } else {\n    if (key.substr(0, 1) === '_') {\n      return parseInt(key.slice(1), 10);\n    } else {\n      return parseInt(key, 10) + 0.1;\n    }\n  }\n};\n\nvar arrayKeyComparer = function arrayKeyComparer(key1, key2) {\n  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);\n};\n\nvar BaseFormatter = function () {\n  function BaseFormatter() {\n    classCallCheck(this, BaseFormatter);\n  }\n\n  createClass(BaseFormatter, [{\n    key: 'format',\n    value: function format(delta, left) {\n      var context = {};\n      this.prepareContext(context);\n      this.recurse(context, delta, left);\n      return this.finalize(context);\n    }\n  }, {\n    key: 'prepareContext',\n    value: function prepareContext(context) {\n      context.buffer = [];\n      context.out = function () {\n        var _buffer;\n\n        (_buffer = this.buffer).push.apply(_buffer, arguments);\n      };\n    }\n  }, {\n    key: 'typeFormattterNotFound',\n    value: function typeFormattterNotFound(context, deltaType) {\n      throw new Error('cannot format delta type: ' + deltaType);\n    }\n  }, {\n    key: 'typeFormattterErrorFormatter',\n    value: function typeFormattterErrorFormatter(context, err) {\n      return err.toString();\n    }\n  }, {\n    key: 'finalize',\n    value: function finalize(_ref) {\n      var buffer = _ref.buffer;\n\n      if (isArray$3(buffer)) {\n        return buffer.join('');\n      }\n    }\n  }, {\n    key: 'recurse',\n    value: function recurse(context, delta, left, key, leftKey, movedFrom, isLast) {\n      var useMoveOriginHere = delta && movedFrom;\n      var leftValue = useMoveOriginHere ? movedFrom.value : left;\n\n      if (typeof delta === 'undefined' && typeof key === 'undefined') {\n        return undefined;\n      }\n\n      var type = this.getDeltaType(delta, movedFrom);\n      var nodeType = type === 'node' ? delta._t === 'a' ? 'array' : 'object' : '';\n\n      if (typeof key !== 'undefined') {\n        this.nodeBegin(context, key, leftKey, type, nodeType, isLast);\n      } else {\n        this.rootBegin(context, type, nodeType);\n      }\n\n      var typeFormattter = void 0;\n      try {\n        typeFormattter = this['format_' + type] || this.typeFormattterNotFound(context, type);\n        typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);\n      } catch (err) {\n        this.typeFormattterErrorFormatter(context, err, delta, leftValue, key, leftKey, movedFrom);\n        if (typeof console !== 'undefined' && console.error) {\n          console.error(err.stack);\n        }\n      }\n\n      if (typeof key !== 'undefined') {\n        this.nodeEnd(context, key, leftKey, type, nodeType, isLast);\n      } else {\n        this.rootEnd(context, type, nodeType);\n      }\n    }\n  }, {\n    key: 'formatDeltaChildren',\n    value: function formatDeltaChildren(context, delta, left) {\n      var self = this;\n      this.forEachDeltaKey(delta, left, function (key, leftKey, movedFrom, isLast) {\n        self.recurse(context, delta[key], left ? left[leftKey] : undefined, key, leftKey, movedFrom, isLast);\n      });\n    }\n  }, {\n    key: 'forEachDeltaKey',\n    value: function forEachDeltaKey(delta, left, fn) {\n      var keys = getObjectKeys(delta);\n      var arrayKeys = delta._t === 'a';\n      var moveDestinations = {};\n      var name = void 0;\n      if (typeof left !== 'undefined') {\n        for (name in left) {\n          if (Object.prototype.hasOwnProperty.call(left, name)) {\n            if (typeof delta[name] === 'undefined' && (!arrayKeys || typeof delta['_' + name] === 'undefined')) {\n              keys.push(name);\n            }\n          }\n        }\n      }\n      // look for move destinations\n      for (name in delta) {\n        if (Object.prototype.hasOwnProperty.call(delta, name)) {\n          var value = delta[name];\n          if (isArray$3(value) && value[2] === 3) {\n            moveDestinations[value[1].toString()] = {\n              key: name,\n              value: left && left[parseInt(name.substr(1))]\n            };\n            if (this.includeMoveDestinations !== false) {\n              if (typeof left === 'undefined' && typeof delta[value[1]] === 'undefined') {\n                keys.push(value[1].toString());\n              }\n            }\n          }\n        }\n      }\n      if (arrayKeys) {\n        keys.sort(arrayKeyComparer);\n      } else {\n        keys.sort();\n      }\n      for (var index = 0, length = keys.length; index < length; index++) {\n        var key = keys[index];\n        if (arrayKeys && key === '_t') {\n          continue;\n        }\n        var leftKey = arrayKeys ? typeof key === 'number' ? key : parseInt(trimUnderscore(key), 10) : key;\n        var isLast = index === length - 1;\n        fn(key, leftKey, moveDestinations[leftKey], isLast);\n      }\n    }\n  }, {\n    key: 'getDeltaType',\n    value: function getDeltaType(delta, movedFrom) {\n      if (typeof delta === 'undefined') {\n        if (typeof movedFrom !== 'undefined') {\n          return 'movedestination';\n        }\n        return 'unchanged';\n      }\n      if (isArray$3(delta)) {\n        if (delta.length === 1) {\n          return 'added';\n        }\n        if (delta.length === 2) {\n          return 'modified';\n        }\n        if (delta.length === 3 && delta[2] === 0) {\n          return 'deleted';\n        }\n        if (delta.length === 3 && delta[2] === 2) {\n          return 'textdiff';\n        }\n        if (delta.length === 3 && delta[2] === 3) {\n          return 'moved';\n        }\n      } else if ((typeof delta === 'undefined' ? 'undefined' : _typeof(delta)) === 'object') {\n        return 'node';\n      }\n      return 'unknown';\n    }\n  }, {\n    key: 'parseTextDiff',\n    value: function parseTextDiff(value) {\n      var output = [];\n      var lines = value.split('\\n@@ ');\n      for (var i = 0, l = lines.length; i < l; i++) {\n        var line = lines[i];\n        var lineOutput = {\n          pieces: []\n        };\n        var location = /^(?:@@ )?[-+]?(\\d+),(\\d+)/.exec(line).slice(1);\n        lineOutput.location = {\n          line: location[0],\n          chr: location[1]\n        };\n        var pieces = line.split('\\n').slice(1);\n        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n          var piece = pieces[pieceIndex];\n          if (!piece.length) {\n            continue;\n          }\n          var pieceOutput = {\n            type: 'context'\n          };\n          if (piece.substr(0, 1) === '+') {\n            pieceOutput.type = 'added';\n          } else if (piece.substr(0, 1) === '-') {\n            pieceOutput.type = 'deleted';\n          }\n          pieceOutput.text = piece.slice(1);\n          lineOutput.pieces.push(pieceOutput);\n        }\n        output.push(lineOutput);\n      }\n      return output;\n    }\n  }]);\n  return BaseFormatter;\n}();\n\n\n\nvar base = Object.freeze({\n\tdefault: BaseFormatter\n});\n\nvar HtmlFormatter = function (_BaseFormatter) {\n  inherits(HtmlFormatter, _BaseFormatter);\n\n  function HtmlFormatter() {\n    classCallCheck(this, HtmlFormatter);\n    return possibleConstructorReturn(this, (HtmlFormatter.__proto__ || Object.getPrototypeOf(HtmlFormatter)).apply(this, arguments));\n  }\n\n  createClass(HtmlFormatter, [{\n    key: 'typeFormattterErrorFormatter',\n    value: function typeFormattterErrorFormatter(context, err) {\n      context.out('<pre class=\"jsondiffpatch-error\">' + err + '</pre>');\n    }\n  }, {\n    key: 'formatValue',\n    value: function formatValue(context, value) {\n      context.out('<pre>' + htmlEscape(JSON.stringify(value, null, 2)) + '</pre>');\n    }\n  }, {\n    key: 'formatTextDiffString',\n    value: function formatTextDiffString(context, value) {\n      var lines = this.parseTextDiff(value);\n      context.out('<ul class=\"jsondiffpatch-textdiff\">');\n      for (var i = 0, l = lines.length; i < l; i++) {\n        var line = lines[i];\n        context.out('<li><div class=\"jsondiffpatch-textdiff-location\">' + ('<span class=\"jsondiffpatch-textdiff-line-number\">' + line.location.line + '</span><span class=\"jsondiffpatch-textdiff-char\">' + line.location.chr + '</span></div><div class=\"jsondiffpatch-textdiff-line\">'));\n        var pieces = line.pieces;\n        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n          /* global decodeURI */\n          var piece = pieces[pieceIndex];\n          context.out('<span class=\"jsondiffpatch-textdiff-' + piece.type + '\">' + htmlEscape(decodeURI(piece.text)) + '</span>');\n        }\n        context.out('</div></li>');\n      }\n      context.out('</ul>');\n    }\n  }, {\n    key: 'rootBegin',\n    value: function rootBegin(context, type, nodeType) {\n      var nodeClass = 'jsondiffpatch-' + type + (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');\n      context.out('<div class=\"jsondiffpatch-delta ' + nodeClass + '\">');\n    }\n  }, {\n    key: 'rootEnd',\n    value: function rootEnd(context) {\n      context.out('</div>' + (context.hasArrows ? '<script type=\"text/javascript\">setTimeout(' + (adjustArrows.toString() + ',10);</script>') : ''));\n    }\n  }, {\n    key: 'nodeBegin',\n    value: function nodeBegin(context, key, leftKey, type, nodeType) {\n      var nodeClass = 'jsondiffpatch-' + type + (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');\n      context.out('<li class=\"' + nodeClass + '\" data-key=\"' + leftKey + '\">' + ('<div class=\"jsondiffpatch-property-name\">' + leftKey + '</div>'));\n    }\n  }, {\n    key: 'nodeEnd',\n    value: function nodeEnd(context) {\n      context.out('</li>');\n    }\n\n    /* jshint camelcase: false */\n    /* eslint-disable camelcase */\n\n  }, {\n    key: 'format_unchanged',\n    value: function format_unchanged(context, delta, left) {\n      if (typeof left === 'undefined') {\n        return;\n      }\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatValue(context, left);\n      context.out('</div>');\n    }\n  }, {\n    key: 'format_movedestination',\n    value: function format_movedestination(context, delta, left) {\n      if (typeof left === 'undefined') {\n        return;\n      }\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatValue(context, left);\n      context.out('</div>');\n    }\n  }, {\n    key: 'format_node',\n    value: function format_node(context, delta, left) {\n      // recurse\n      var nodeType = delta._t === 'a' ? 'array' : 'object';\n      context.out('<ul class=\"jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '\">');\n      this.formatDeltaChildren(context, delta, left);\n      context.out('</ul>');\n    }\n  }, {\n    key: 'format_added',\n    value: function format_added(context, delta) {\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatValue(context, delta[0]);\n      context.out('</div>');\n    }\n  }, {\n    key: 'format_modified',\n    value: function format_modified(context, delta) {\n      context.out('<div class=\"jsondiffpatch-value jsondiffpatch-left-value\">');\n      this.formatValue(context, delta[0]);\n      context.out('</div>' + '<div class=\"jsondiffpatch-value jsondiffpatch-right-value\">');\n      this.formatValue(context, delta[1]);\n      context.out('</div>');\n    }\n  }, {\n    key: 'format_deleted',\n    value: function format_deleted(context, delta) {\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatValue(context, delta[0]);\n      context.out('</div>');\n    }\n  }, {\n    key: 'format_moved',\n    value: function format_moved(context, delta) {\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatValue(context, delta[0]);\n      context.out('</div><div class=\"jsondiffpatch-moved-destination\">' + delta[1] + '</div>');\n\n      // draw an SVG arrow from here to move destination\n      context.out(\n      /* jshint multistr: true */\n      '<div class=\"jsondiffpatch-arrow\" ' + 'style=\"position: relative; left: -34px;\">\\n          <svg width=\"30\" height=\"60\" ' + 'style=\"position: absolute; display: none;\">\\n          <defs>\\n              <marker id=\"markerArrow\" markerWidth=\"8\" markerHeight=\"8\"\\n                 refx=\"2\" refy=\"4\"\\n                     orient=\"auto\" markerUnits=\"userSpaceOnUse\">\\n                  <path d=\"M1,1 L1,7 L7,4 L1,1\" style=\"fill: #339;\" />\\n              </marker>\\n          </defs>\\n          <path d=\"M30,0 Q-10,25 26,50\"\\n            style=\"stroke: #88f; stroke-width: 2px; fill: none; ' + 'stroke-opacity: 0.5; marker-end: url(#markerArrow);\"\\n          ></path>\\n          </svg>\\n      </div>');\n      context.hasArrows = true;\n    }\n  }, {\n    key: 'format_textdiff',\n    value: function format_textdiff(context, delta) {\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatTextDiffString(context, delta[0]);\n      context.out('</div>');\n    }\n  }]);\n  return HtmlFormatter;\n}(BaseFormatter);\n\nfunction htmlEscape(text) {\n  var html = text;\n  var replacements = [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/'/g, '&apos;'], [/\"/g, '&quot;']];\n  for (var i = 0; i < replacements.length; i++) {\n    html = html.replace(replacements[i][0], replacements[i][1]);\n  }\n  return html;\n}\n\nvar adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {\n  var node = nodeArg || document;\n  var getElementText = function getElementText(_ref) {\n    var textContent = _ref.textContent,\n        innerText = _ref.innerText;\n    return textContent || innerText;\n  };\n  var eachByQuery = function eachByQuery(el, query, fn) {\n    var elems = el.querySelectorAll(query);\n    for (var i = 0, l = elems.length; i < l; i++) {\n      fn(elems[i]);\n    }\n  };\n  var eachChildren = function eachChildren(_ref2, fn) {\n    var children = _ref2.children;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      fn(children[i], i);\n    }\n  };\n  eachByQuery(node, '.jsondiffpatch-arrow', function (_ref3) {\n    var parentNode = _ref3.parentNode,\n        children = _ref3.children,\n        style = _ref3.style;\n\n    var arrowParent = parentNode;\n    var svg = children[0];\n    var path = svg.children[1];\n    svg.style.display = 'none';\n    var destination = getElementText(arrowParent.querySelector('.jsondiffpatch-moved-destination'));\n    var container = arrowParent.parentNode;\n    var destinationElem = void 0;\n    eachChildren(container, function (child) {\n      if (child.getAttribute('data-key') === destination) {\n        destinationElem = child;\n      }\n    });\n    if (!destinationElem) {\n      return;\n    }\n    try {\n      var distance = destinationElem.offsetTop - arrowParent.offsetTop;\n      svg.setAttribute('height', Math.abs(distance) + 6);\n      style.top = -8 + (distance > 0 ? 0 : distance) + 'px';\n      var curve = distance > 0 ? 'M30,0 Q-10,' + Math.round(distance / 2) + ' 26,' + (distance - 4) : 'M30,' + -distance + ' Q-10,' + Math.round(-distance / 2) + ' 26,4';\n      path.setAttribute('d', curve);\n      svg.style.display = '';\n    } catch (err) {}\n  });\n};\n\n/* jshint camelcase: true */\n/* eslint-enable camelcase */\n\nvar showUnchanged = function showUnchanged(show, node, delay) {\n  var el = node || document.body;\n  var prefix = 'jsondiffpatch-unchanged-';\n  var classes = {\n    showing: prefix + 'showing',\n    hiding: prefix + 'hiding',\n    visible: prefix + 'visible',\n    hidden: prefix + 'hidden'\n  };\n  var list = el.classList;\n  if (!list) {\n    return;\n  }\n  if (!delay) {\n    list.remove(classes.showing);\n    list.remove(classes.hiding);\n    list.remove(classes.visible);\n    list.remove(classes.hidden);\n    if (show === false) {\n      list.add(classes.hidden);\n    }\n    return;\n  }\n  if (show === false) {\n    list.remove(classes.showing);\n    list.add(classes.visible);\n    setTimeout(function () {\n      list.add(classes.hiding);\n    }, 10);\n  } else {\n    list.remove(classes.hiding);\n    list.add(classes.showing);\n    list.remove(classes.hidden);\n  }\n  var intervalId = setInterval(function () {\n    adjustArrows(el);\n  }, 100);\n  setTimeout(function () {\n    list.remove(classes.showing);\n    list.remove(classes.hiding);\n    if (show === false) {\n      list.add(classes.hidden);\n      list.remove(classes.visible);\n    } else {\n      list.add(classes.visible);\n      list.remove(classes.hidden);\n    }\n    setTimeout(function () {\n      list.remove(classes.visible);\n      clearInterval(intervalId);\n    }, delay + 400);\n  }, delay);\n};\n\nvar hideUnchanged = function hideUnchanged(node, delay) {\n  return showUnchanged(false, node, delay);\n};\n\nvar defaultInstance = void 0;\n\nfunction format(delta, left) {\n  if (!defaultInstance) {\n    defaultInstance = new HtmlFormatter();\n  }\n  return defaultInstance.format(delta, left);\n}\n\n\n\nvar html = Object.freeze({\n\tshowUnchanged: showUnchanged,\n\thideUnchanged: hideUnchanged,\n\tdefault: HtmlFormatter,\n\tformat: format\n});\n\nvar AnnotatedFormatter = function (_BaseFormatter) {\n  inherits(AnnotatedFormatter, _BaseFormatter);\n\n  function AnnotatedFormatter() {\n    classCallCheck(this, AnnotatedFormatter);\n\n    var _this = possibleConstructorReturn(this, (AnnotatedFormatter.__proto__ || Object.getPrototypeOf(AnnotatedFormatter)).call(this));\n\n    _this.includeMoveDestinations = false;\n    return _this;\n  }\n\n  createClass(AnnotatedFormatter, [{\n    key: 'prepareContext',\n    value: function prepareContext(context) {\n      get(AnnotatedFormatter.prototype.__proto__ || Object.getPrototypeOf(AnnotatedFormatter.prototype), 'prepareContext', this).call(this, context);\n      context.indent = function (levels) {\n        this.indentLevel = (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);\n        this.indentPad = new Array(this.indentLevel + 1).join('&nbsp;&nbsp;');\n      };\n      context.row = function (json, htmlNote) {\n        context.out('<tr><td style=\"white-space: nowrap;\">' + '<pre class=\"jsondiffpatch-annotated-indent\"' + ' style=\"display: inline-block\">');\n        context.out(context.indentPad);\n        context.out('</pre><pre style=\"display: inline-block\">');\n        context.out(json);\n        context.out('</pre></td><td class=\"jsondiffpatch-delta-note\"><div>');\n        context.out(htmlNote);\n        context.out('</div></td></tr>');\n      };\n    }\n  }, {\n    key: 'typeFormattterErrorFormatter',\n    value: function typeFormattterErrorFormatter(context, err) {\n      context.row('', '<pre class=\"jsondiffpatch-error\">' + err + '</pre>');\n    }\n  }, {\n    key: 'formatTextDiffString',\n    value: function formatTextDiffString(context, value) {\n      var lines = this.parseTextDiff(value);\n      context.out('<ul class=\"jsondiffpatch-textdiff\">');\n      for (var i = 0, l = lines.length; i < l; i++) {\n        var line = lines[i];\n        context.out('<li><div class=\"jsondiffpatch-textdiff-location\">' + ('<span class=\"jsondiffpatch-textdiff-line-number\">' + line.location.line + '</span><span class=\"jsondiffpatch-textdiff-char\">' + line.location.chr + '</span></div><div class=\"jsondiffpatch-textdiff-line\">'));\n        var pieces = line.pieces;\n        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n          var piece = pieces[pieceIndex];\n          context.out('<span class=\"jsondiffpatch-textdiff-' + piece.type + '\">' + piece.text + '</span>');\n        }\n        context.out('</div></li>');\n      }\n      context.out('</ul>');\n    }\n  }, {\n    key: 'rootBegin',\n    value: function rootBegin(context, type, nodeType) {\n      context.out('<table class=\"jsondiffpatch-annotated-delta\">');\n      if (type === 'node') {\n        context.row('{');\n        context.indent();\n      }\n      if (nodeType === 'array') {\n        context.row('\"_t\": \"a\",', 'Array delta (member names indicate array indices)');\n      }\n    }\n  }, {\n    key: 'rootEnd',\n    value: function rootEnd(context, type) {\n      if (type === 'node') {\n        context.indent(-1);\n        context.row('}');\n      }\n      context.out('</table>');\n    }\n  }, {\n    key: 'nodeBegin',\n    value: function nodeBegin(context, key, leftKey, type, nodeType) {\n      context.row('&quot;' + key + '&quot;: {');\n      if (type === 'node') {\n        context.indent();\n      }\n      if (nodeType === 'array') {\n        context.row('\"_t\": \"a\",', 'Array delta (member names indicate array indices)');\n      }\n    }\n  }, {\n    key: 'nodeEnd',\n    value: function nodeEnd(context, key, leftKey, type, nodeType, isLast) {\n      if (type === 'node') {\n        context.indent(-1);\n      }\n      context.row('}' + (isLast ? '' : ','));\n    }\n\n    /* jshint camelcase: false */\n\n    /* eslint-disable camelcase */\n\n  }, {\n    key: 'format_unchanged',\n    value: function format_unchanged() {}\n  }, {\n    key: 'format_movedestination',\n    value: function format_movedestination() {}\n  }, {\n    key: 'format_node',\n    value: function format_node(context, delta, left) {\n      // recurse\n      this.formatDeltaChildren(context, delta, left);\n    }\n  }]);\n  return AnnotatedFormatter;\n}(BaseFormatter);\n\n/* eslint-enable camelcase */\n\nvar wrapPropertyName = function wrapPropertyName(name) {\n  return '<pre style=\"display:inline-block\">&quot;' + name + '&quot;</pre>';\n};\n\nvar deltaAnnotations = {\n  added: function added(delta, left, key, leftKey) {\n    var formatLegend = ' <pre>([newValue])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return 'new value' + formatLegend;\n    }\n    if (typeof leftKey === 'number') {\n      return 'insert at index ' + leftKey + formatLegend;\n    }\n    return 'add property ' + wrapPropertyName(leftKey) + formatLegend;\n  },\n  modified: function modified(delta, left, key, leftKey) {\n    var formatLegend = ' <pre>([previousValue, newValue])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return 'modify value' + formatLegend;\n    }\n    if (typeof leftKey === 'number') {\n      return 'modify at index ' + leftKey + formatLegend;\n    }\n    return 'modify property ' + wrapPropertyName(leftKey) + formatLegend;\n  },\n  deleted: function deleted(delta, left, key, leftKey) {\n    var formatLegend = ' <pre>([previousValue, 0, 0])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return 'delete value' + formatLegend;\n    }\n    if (typeof leftKey === 'number') {\n      return 'remove index ' + leftKey + formatLegend;\n    }\n    return 'delete property ' + wrapPropertyName(leftKey) + formatLegend;\n  },\n  moved: function moved(delta, left, key, leftKey) {\n    return 'move from <span title=\"(position to remove at original state)\">' + ('index ' + leftKey + '</span> to <span title=\"(position to insert at final') + (' state)\">index ' + delta[1] + '</span>');\n  },\n  textdiff: function textdiff(delta, left, key, leftKey) {\n    var location = typeof leftKey === 'undefined' ? '' : typeof leftKey === 'number' ? ' at index ' + leftKey : ' at property ' + wrapPropertyName(leftKey);\n    return 'text diff' + location + ', format is <a href=\"https://code.google.com/' + 'p/google-diff-match-patch/wiki/Unidiff\">a variation of Unidiff</a>';\n  }\n};\n\nvar formatAnyChange = function formatAnyChange(context, delta) {\n  var deltaType = this.getDeltaType(delta);\n  var annotator = deltaAnnotations[deltaType];\n  var htmlNote = annotator && annotator.apply(annotator, Array.prototype.slice.call(arguments, 1));\n  var json = JSON.stringify(delta, null, 2);\n  if (deltaType === 'textdiff') {\n    // split text diffs lines\n    json = json.split('\\\\n').join('\\\\n\"+\\n   \"');\n  }\n  context.indent();\n  context.row(json, htmlNote);\n  context.indent(-1);\n};\n\n/* eslint-disable camelcase */\nAnnotatedFormatter.prototype.format_added = formatAnyChange;\nAnnotatedFormatter.prototype.format_modified = formatAnyChange;\nAnnotatedFormatter.prototype.format_deleted = formatAnyChange;\nAnnotatedFormatter.prototype.format_moved = formatAnyChange;\nAnnotatedFormatter.prototype.format_textdiff = formatAnyChange;\nvar defaultInstance$1 = void 0;\n\nfunction format$1(delta, left) {\n  if (!defaultInstance$1) {\n    defaultInstance$1 = new AnnotatedFormatter();\n  }\n  return defaultInstance$1.format(delta, left);\n}\n\n\n\nvar annotated = Object.freeze({\n\tdefault: AnnotatedFormatter,\n\tformat: format$1\n});\n\nvar OPERATIONS = {\n  add: 'add',\n  remove: 'remove',\n  replace: 'replace',\n  move: 'move'\n};\n\nvar JSONFormatter = function (_BaseFormatter) {\n  inherits(JSONFormatter, _BaseFormatter);\n\n  function JSONFormatter() {\n    classCallCheck(this, JSONFormatter);\n\n    var _this = possibleConstructorReturn(this, (JSONFormatter.__proto__ || Object.getPrototypeOf(JSONFormatter)).call(this));\n\n    _this.includeMoveDestinations = true;\n    return _this;\n  }\n\n  createClass(JSONFormatter, [{\n    key: 'prepareContext',\n    value: function prepareContext(context) {\n      get(JSONFormatter.prototype.__proto__ || Object.getPrototypeOf(JSONFormatter.prototype), 'prepareContext', this).call(this, context);\n      context.result = [];\n      context.path = [];\n      context.pushCurrentOp = function (obj) {\n        var op = obj.op,\n            value = obj.value;\n\n        var val = {\n          op: op,\n          path: this.currentPath()\n        };\n        if (typeof value !== 'undefined') {\n          val.value = value;\n        }\n        this.result.push(val);\n      };\n\n      context.pushMoveOp = function (to) {\n        var from = this.currentPath();\n        this.result.push({\n          op: OPERATIONS.move,\n          from: from,\n          path: this.toPath(to)\n        });\n      };\n\n      context.currentPath = function () {\n        return '/' + this.path.join('/');\n      };\n\n      context.toPath = function (toPath) {\n        var to = this.path.slice();\n        to[to.length - 1] = toPath;\n        return '/' + to.join('/');\n      };\n    }\n  }, {\n    key: 'typeFormattterErrorFormatter',\n    value: function typeFormattterErrorFormatter(context, err) {\n      context.out('[ERROR] ' + err);\n    }\n  }, {\n    key: 'rootBegin',\n    value: function rootBegin() {}\n  }, {\n    key: 'rootEnd',\n    value: function rootEnd() {}\n  }, {\n    key: 'nodeBegin',\n    value: function nodeBegin(_ref, key, leftKey) {\n      var path = _ref.path;\n\n      path.push(leftKey);\n    }\n  }, {\n    key: 'nodeEnd',\n    value: function nodeEnd(_ref2) {\n      var path = _ref2.path;\n\n      path.pop();\n    }\n\n    /* jshint camelcase: false */\n    /* eslint-disable camelcase */\n\n  }, {\n    key: 'format_unchanged',\n    value: function format_unchanged() {}\n  }, {\n    key: 'format_movedestination',\n    value: function format_movedestination() {}\n  }, {\n    key: 'format_node',\n    value: function format_node(context, delta, left) {\n      this.formatDeltaChildren(context, delta, left);\n    }\n  }, {\n    key: 'format_added',\n    value: function format_added(context, delta) {\n      context.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] });\n    }\n  }, {\n    key: 'format_modified',\n    value: function format_modified(context, delta) {\n      context.pushCurrentOp({ op: OPERATIONS.replace, value: delta[1] });\n    }\n  }, {\n    key: 'format_deleted',\n    value: function format_deleted(context) {\n      context.pushCurrentOp({ op: OPERATIONS.remove });\n    }\n  }, {\n    key: 'format_moved',\n    value: function format_moved(context, delta) {\n      var to = delta[1];\n      context.pushMoveOp(to);\n    }\n  }, {\n    key: 'format_textdiff',\n    value: function format_textdiff() {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: 'format',\n    value: function format(delta, left) {\n      var context = {};\n      this.prepareContext(context);\n      this.recurse(context, delta, left);\n      return context.result;\n    }\n  }]);\n  return JSONFormatter;\n}(BaseFormatter);\n\nvar last = function last(arr) {\n  return arr[arr.length - 1];\n};\n\nvar sortBy = function sortBy(arr, pred) {\n  arr.sort(pred);\n  return arr;\n};\n\nvar compareByIndexDesc = function compareByIndexDesc(indexA, indexB) {\n  var lastA = parseInt(indexA, 10);\n  var lastB = parseInt(indexB, 10);\n  if (!(isNaN(lastA) || isNaN(lastB))) {\n    return lastB - lastA;\n  } else {\n    return 0;\n  }\n};\n\nvar opsByDescendingOrder = function opsByDescendingOrder(removeOps) {\n  return sortBy(removeOps, function (a, b) {\n    var splitA = a.path.split('/');\n    var splitB = b.path.split('/');\n    if (splitA.length !== splitB.length) {\n      return splitA.length - splitB.length;\n    } else {\n      return compareByIndexDesc(last(splitA), last(splitB));\n    }\n  });\n};\n\nvar partitionOps = function partitionOps(arr, fns) {\n  var initArr = Array(fns.length + 1).fill().map(function () {\n    return [];\n  });\n  return arr.map(function (item) {\n    var position = fns.map(function (fn) {\n      return fn(item);\n    }).indexOf(true);\n    if (position < 0) {\n      position = fns.length;\n    }\n    return { item: item, position: position };\n  }).reduce(function (acc, item) {\n    acc[item.position].push(item.item);\n    return acc;\n  }, initArr);\n};\nvar isMoveOp = function isMoveOp(_ref3) {\n  var op = _ref3.op;\n  return op === 'move';\n};\nvar isRemoveOp = function isRemoveOp(_ref4) {\n  var op = _ref4.op;\n  return op === 'remove';\n};\n\nvar reorderOps = function reorderOps(diff) {\n  var _partitionOps = partitionOps(diff, [isMoveOp, isRemoveOp]),\n      _partitionOps2 = slicedToArray(_partitionOps, 3),\n      moveOps = _partitionOps2[0],\n      removedOps = _partitionOps2[1],\n      restOps = _partitionOps2[2];\n\n  var removeOpsReverse = opsByDescendingOrder(removedOps);\n  return [].concat(toConsumableArray(removeOpsReverse), toConsumableArray(moveOps), toConsumableArray(restOps));\n};\n\nvar defaultInstance$2 = void 0;\n\nvar format$2 = function format(delta, left) {\n  if (!defaultInstance$2) {\n    defaultInstance$2 = new JSONFormatter();\n  }\n  return reorderOps(defaultInstance$2.format(delta, left));\n};\n\nvar log = function log(delta, left) {\n  console.log(format$2(delta, left));\n};\n\n\n\nvar jsonpatch = Object.freeze({\n\tdefault: JSONFormatter,\n\tpartitionOps: partitionOps,\n\tformat: format$2,\n\tlog: log\n});\n\nfunction chalkColor(name) {\n  return chalk && chalk[name] || function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return args;\n  };\n}\n\nvar colors = {\n  added: chalkColor('green'),\n  deleted: chalkColor('red'),\n  movedestination: chalkColor('gray'),\n  moved: chalkColor('yellow'),\n  unchanged: chalkColor('gray'),\n  error: chalkColor('white.bgRed'),\n  textDiffLine: chalkColor('gray')\n};\n\nvar ConsoleFormatter = function (_BaseFormatter) {\n  inherits(ConsoleFormatter, _BaseFormatter);\n\n  function ConsoleFormatter() {\n    classCallCheck(this, ConsoleFormatter);\n\n    var _this = possibleConstructorReturn(this, (ConsoleFormatter.__proto__ || Object.getPrototypeOf(ConsoleFormatter)).call(this));\n\n    _this.includeMoveDestinations = false;\n    return _this;\n  }\n\n  createClass(ConsoleFormatter, [{\n    key: 'prepareContext',\n    value: function prepareContext(context) {\n      get(ConsoleFormatter.prototype.__proto__ || Object.getPrototypeOf(ConsoleFormatter.prototype), 'prepareContext', this).call(this, context);\n      context.indent = function (levels) {\n        this.indentLevel = (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);\n        this.indentPad = new Array(this.indentLevel + 1).join('  ');\n        this.outLine();\n      };\n      context.outLine = function () {\n        this.buffer.push('\\n' + (this.indentPad || ''));\n      };\n      context.out = function () {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        for (var i = 0, l = args.length; i < l; i++) {\n          var lines = args[i].split('\\n');\n          var text = lines.join('\\n' + (this.indentPad || ''));\n          if (this.color && this.color[0]) {\n            text = this.color[0](text);\n          }\n          this.buffer.push(text);\n        }\n      };\n      context.pushColor = function (color) {\n        this.color = this.color || [];\n        this.color.unshift(color);\n      };\n      context.popColor = function () {\n        this.color = this.color || [];\n        this.color.shift();\n      };\n    }\n  }, {\n    key: 'typeFormattterErrorFormatter',\n    value: function typeFormattterErrorFormatter(context, err) {\n      context.pushColor(colors.error);\n      context.out('[ERROR]' + err);\n      context.popColor();\n    }\n  }, {\n    key: 'formatValue',\n    value: function formatValue(context, value) {\n      context.out(JSON.stringify(value, null, 2));\n    }\n  }, {\n    key: 'formatTextDiffString',\n    value: function formatTextDiffString(context, value) {\n      var lines = this.parseTextDiff(value);\n      context.indent();\n      for (var i = 0, l = lines.length; i < l; i++) {\n        var line = lines[i];\n        context.pushColor(colors.textDiffLine);\n        context.out(line.location.line + ',' + line.location.chr + ' ');\n        context.popColor();\n        var pieces = line.pieces;\n        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n          var piece = pieces[pieceIndex];\n          context.pushColor(colors[piece.type]);\n          context.out(piece.text);\n          context.popColor();\n        }\n        if (i < l - 1) {\n          context.outLine();\n        }\n      }\n      context.indent(-1);\n    }\n  }, {\n    key: 'rootBegin',\n    value: function rootBegin(context, type, nodeType) {\n      context.pushColor(colors[type]);\n      if (type === 'node') {\n        context.out(nodeType === 'array' ? '[' : '{');\n        context.indent();\n      }\n    }\n  }, {\n    key: 'rootEnd',\n    value: function rootEnd(context, type, nodeType) {\n      if (type === 'node') {\n        context.indent(-1);\n        context.out(nodeType === 'array' ? ']' : '}');\n      }\n      context.popColor();\n    }\n  }, {\n    key: 'nodeBegin',\n    value: function nodeBegin(context, key, leftKey, type, nodeType) {\n      context.pushColor(colors[type]);\n      context.out(leftKey + ': ');\n      if (type === 'node') {\n        context.out(nodeType === 'array' ? '[' : '{');\n        context.indent();\n      }\n    }\n  }, {\n    key: 'nodeEnd',\n    value: function nodeEnd(context, key, leftKey, type, nodeType, isLast) {\n      if (type === 'node') {\n        context.indent(-1);\n        context.out(nodeType === 'array' ? ']' : '}' + (isLast ? '' : ','));\n      }\n      if (!isLast) {\n        context.outLine();\n      }\n      context.popColor();\n    }\n\n    /* jshint camelcase: false */\n    /* eslint-disable camelcase */\n\n  }, {\n    key: 'format_unchanged',\n    value: function format_unchanged(context, delta, left) {\n      if (typeof left === 'undefined') {\n        return;\n      }\n      this.formatValue(context, left);\n    }\n  }, {\n    key: 'format_movedestination',\n    value: function format_movedestination(context, delta, left) {\n      if (typeof left === 'undefined') {\n        return;\n      }\n      this.formatValue(context, left);\n    }\n  }, {\n    key: 'format_node',\n    value: function format_node(context, delta, left) {\n      // recurse\n      this.formatDeltaChildren(context, delta, left);\n    }\n  }, {\n    key: 'format_added',\n    value: function format_added(context, delta) {\n      this.formatValue(context, delta[0]);\n    }\n  }, {\n    key: 'format_modified',\n    value: function format_modified(context, delta) {\n      context.pushColor(colors.deleted);\n      this.formatValue(context, delta[0]);\n      context.popColor();\n      context.out(' => ');\n      context.pushColor(colors.added);\n      this.formatValue(context, delta[1]);\n      context.popColor();\n    }\n  }, {\n    key: 'format_deleted',\n    value: function format_deleted(context, delta) {\n      this.formatValue(context, delta[0]);\n    }\n  }, {\n    key: 'format_moved',\n    value: function format_moved(context, delta) {\n      context.out('==> ' + delta[1]);\n    }\n  }, {\n    key: 'format_textdiff',\n    value: function format_textdiff(context, delta) {\n      this.formatTextDiffString(context, delta[0]);\n    }\n  }]);\n  return ConsoleFormatter;\n}(BaseFormatter);\n\nvar defaultInstance$3 = void 0;\n\nvar format$3 = function format(delta, left) {\n  if (!defaultInstance$3) {\n    defaultInstance$3 = new ConsoleFormatter();\n  }\n  return defaultInstance$3.format(delta, left);\n};\n\nfunction log$1(delta, left) {\n  console.log(format$3(delta, left));\n}\n\n\n\nvar console$1 = Object.freeze({\n\tdefault: ConsoleFormatter,\n\tformat: format$3,\n\tlog: log$1\n});\n\n\n\nvar index = Object.freeze({\n\tbase: base,\n\thtml: html,\n\tannotated: annotated,\n\tjsonpatch: jsonpatch,\n\tconsole: console$1\n});\n\n// use as 2nd parameter for JSON.parse to revive Date instances\nfunction dateReviver(key, value) {\n  var parts = void 0;\n  if (typeof value === 'string') {\n    // eslint-disable-next-line max-len\n    parts = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d*))?(Z|([+-])(\\d{2}):(\\d{2}))$/.exec(value);\n    if (parts) {\n      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));\n    }\n  }\n  return value;\n}\n\nfunction create(options) {\n  return new DiffPatcher(options);\n}\n\nvar defaultInstance$4 = void 0;\n\nfunction diff() {\n  if (!defaultInstance$4) {\n    defaultInstance$4 = new DiffPatcher();\n  }\n  return defaultInstance$4.diff.apply(defaultInstance$4, arguments);\n}\n\nfunction patch() {\n  if (!defaultInstance$4) {\n    defaultInstance$4 = new DiffPatcher();\n  }\n  return defaultInstance$4.patch.apply(defaultInstance$4, arguments);\n}\n\nfunction unpatch() {\n  if (!defaultInstance$4) {\n    defaultInstance$4 = new DiffPatcher();\n  }\n  return defaultInstance$4.unpatch.apply(defaultInstance$4, arguments);\n}\n\nfunction reverse() {\n  if (!defaultInstance$4) {\n    defaultInstance$4 = new DiffPatcher();\n  }\n  return defaultInstance$4.reverse.apply(defaultInstance$4, arguments);\n}\n\nfunction clone$1() {\n  if (!defaultInstance$4) {\n    defaultInstance$4 = new DiffPatcher();\n  }\n  return defaultInstance$4.clone.apply(defaultInstance$4, arguments);\n}\n\nexports.DiffPatcher = DiffPatcher;\nexports.formatters = index;\nexports.console = console$1;\nexports.create = create;\nexports.dateReviver = dateReviver;\nexports.diff = diff;\nexports.patch = patch;\nexports.unpatch = unpatch;\nexports.reverse = reverse;\nexports.clone = clone$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","import { DiffPatcher } from 'jsondiffpatch'\n\nconst diffPatcher = new DiffPatcher({\n  arrays: { detectMove: false, includeValueOnMove: false },\n  textDiff: { minLength: 1 }\n})\n\nexport function diff(inputA: any, inputB: any) {\n  return diffPatcher.diff(inputA, inputB)\n}\n","import type { Transaction } from 'prosemirror-state'\n\nconst addedProperties = [\n  'docChanged',\n  'isGeneric',\n  'scrolledIntoView',\n  'selectionSet',\n  'storedMarksSet'\n]\n\nexport function addPropertiesToTransaction(tr: Transaction) {\n  return Object.keys(tr)\n    .concat(addedProperties)\n    .reduce((acc, key) => {\n      // @ts-ignore\n      acc[key] = tr[key]\n      return acc\n    }, {} as Transaction)\n}\n","import type { EditorState, Selection, Transaction } from 'prosemirror-state'\nimport { DOMSerializer } from 'prosemirror-model'\nimport { prettyPrint } from 'html'\n\nimport { diff } from './diff'\nimport { addPropertiesToTransaction } from './transaction'\nimport type { HistoryEntry } from '$typings/history'\n\nfunction buildSelection(selection: Selection) {\n  return {\n    // @ts-ignore\n    type: selection.type,\n    empty: selection.empty,\n    anchor: selection.anchor,\n    head: selection.head,\n    from: selection.from,\n    to: selection.to\n  }\n}\n\nfunction pad(num: number) {\n  return ('00' + num).slice(-2)\n}\n\nfunction pad3(num: number) {\n  return ('000' + num).slice(-3)\n}\n\nconst formatTimestamp = (timestamp: number) => {\n  const date = new Date(timestamp)\n  return [\n    pad(date.getHours()),\n    pad(date.getMinutes()),\n    pad(date.getSeconds()),\n    pad3(date.getMilliseconds())\n  ].join(':')\n}\n\nconst regexp = /(&lt;\\/?[\\w\\d\\s=\"']+&gt;)/gim\nconst highlightHtmlString = (html: string) =>\n  html\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(regexp, \"<span style='color: cadetblue;'>$&</span>\")\n\nexport function createHistoryEntry(\n  tr: Transaction,\n  state: EditorState,\n  stateBeforeDispatch: EditorState,\n  oldEntry?: HistoryEntry\n): HistoryEntry {\n  const serializer = DOMSerializer.fromSchema(state.schema)\n  const selection = state.selection\n  const domFragment = serializer.serializeFragment(selection.content().content)\n\n  const selectedElementsAsHtml = []\n  if (domFragment) {\n    let child = domFragment.firstChild as HTMLElement | null\n    while (child) {\n      selectedElementsAsHtml.push(child.outerHTML)\n      child = child.nextSibling as HTMLElement | null\n    }\n  }\n\n  // As described in stateHistory.ts the first entry is a special exception\n  const prevState = oldEntry ? oldEntry.state : stateBeforeDispatch\n  const contentDiff = diff(prevState.doc.toJSON(), state.doc.toJSON())\n  const selectionDiff = diff(buildSelection(prevState.selection), buildSelection(state.selection))\n\n  return {\n    id: Math.random().toString() + Math.random().toString(),\n    state,\n    tr: addPropertiesToTransaction(tr),\n    timestamp: tr.time,\n    timeStr: formatTimestamp(tr.time),\n    contentDiff,\n    selectionDiff,\n    selectionHtml: highlightHtmlString(\n      prettyPrint(selectedElementsAsHtml.join('\\n'), {\n        max_char: 60,\n        indent_size: 2\n      })\n    )\n  }\n}\n","import { get, writable } from 'svelte/store'\nimport { EditorState, Transaction } from 'prosemirror-state'\n\nimport { createHistoryEntry } from '../history-and-diff/createHistoryEntry'\n\nimport type { HistoryEntry, HistoryGroup } from '$typings/history'\n\nexport const stateHistory = writable<Map<string, HistoryEntry>>(new Map())\nexport const shownHistoryGroups = writable<HistoryGroup[]>([])\nexport const latestEntry = writable<HistoryEntry | undefined>(undefined)\n\nexport function appendNewHistoryEntry(tr: Transaction, state: EditorState, stateBeforeDispatch: EditorState) {\n  const entryMap = get(stateHistory)\n  const prevGroup = get(shownHistoryGroups)[0]\n  const oldEntry = entryMap.get(prevGroup?.topEntryId || '')\n  // In the case of first entry there aren't oldEntries to diff against, therefore we have to use the state\n  // before the transaction. We can't use it for the next entries because it will always be one state behind,\n  // as the current state is the one _after_ the dispatch. You can observe this in the old dev-tools.\n  const newEntry = createHistoryEntry(tr, state, stateBeforeDispatch, oldEntry)\n\n  stateHistory.update(val => new Map(val.set(newEntry.id, newEntry)))\n  latestEntry.set(newEntry)\n\n  // Groups are subsequent transactions where the doc hasn't changed (eg selection was set) OR the diff was equal\n  // Haven't seen necessary to differentiate between selection-only vs equal diffs\n  const isGroup = !newEntry.contentDiff\n  if (prevGroup?.isGroup && isGroup) {\n    const newGroup = {\n      isGroup,\n      entryIds: [newEntry.id, ...prevGroup.entryIds],\n      topEntryId: newEntry.id,\n      expanded: prevGroup.expanded\n    }\n    shownHistoryGroups.update(val => [newGroup, ...val.slice(1)])\n  } else {\n    const newGroup = {\n      isGroup,\n      entryIds: [newEntry.id],\n      topEntryId: newEntry.id,\n      expanded: false\n    }\n    shownHistoryGroups.update(val => [newGroup, ...val])\n  }\n}\n\nexport function resetHistory() {\n  stateHistory.set(new Map())\n  shownHistoryGroups.set([])\n  latestEntry.set(undefined)\n}\n","import { Selection } from 'prosemirror-state'\n\nconst defaultProperties = ['jsonID', 'empty', 'anchor', 'from', 'head', 'to']\nconst resolvedPosProperties = ['$anchor', '$head', '$cursor', '$to', '$from']\nconst resolvedPosSubProperties = ['nodeAfter', 'nodeBefore', 'textOffset']\n\nexport function createSelection(selection: Selection) {\n  return defaultProperties.reduce((acc, key) => {\n    // @ts-ignore\n    acc[key] = selection[key]\n    return acc\n  }, {} as { [key: string]: any })\n}\n\nexport function createFullSelection(selection: Selection) {\n  return defaultProperties.concat(resolvedPosProperties).reduce((acc, key) => {\n    // @ts-ignore\n    let val = selection[key]\n    if (val && resolvedPosProperties.includes(key)) {\n      const additionalProperties = {}\n      resolvedPosSubProperties.forEach(subKey => {\n        // @ts-ignore\n        additionalProperties[subKey] = val[subKey]\n      })\n      val = { ...val, ...additionalProperties }\n    }\n    acc[key] = val\n    return acc\n  }, {} as { [key: string]: any })\n}\n","export function createNode(index, key, value, depth, parent) {\n    const path = parent ? [...parent.path, index] : [];\n    return {\n        id: `[${path.join(',')}]`,\n        index,\n        key,\n        value,\n        depth: depth + 1,\n        collapsed: true,\n        type: getValueType(value),\n        path,\n        parentId: parent ? parent.id : null,\n        circularOfId: null,\n        children: []\n    };\n}\nexport function getValueType(value) {\n    if (Array.isArray(value)) {\n        return 'array';\n    }\n    else if (value instanceof Map) {\n        return 'map';\n    }\n    else if (value instanceof Set) {\n        return 'set';\n    }\n    else if (value instanceof Date) {\n        return 'date';\n    }\n    else if (value === null) {\n        return 'null';\n    }\n    else {\n        return typeof value;\n    }\n}\n// From redux-dev-tools\n// case 'Object':\n//   case 'Error':\n//   case 'Array':\n//   case 'Iterable':\n//   case 'Map':\n//   case 'Set':\n//   case 'MapEntry':\n//   case 'Number':\n//     return undefined;\n//   case 'String':\n//     return raw => `\"${raw}\"`;\n//   case 'Boolean':\n//     return raw => (raw ? 'true' : 'false');\n//   case 'Date':\n//     return raw => raw.toISOString();\n//   case 'Null':\n//     return () => 'null';\n//   case 'Undefined':\n//     return () => 'undefined';\n//   case 'Function':\n//   case 'Symbol':\n// export function objType(obj: any) {\n//   const type = Object.prototype.toString.call(obj).slice(8, -1)\n//   if (type === 'Object') {\n//     if (typeof obj[Symbol.iterator] === 'function') {\n//       return 'Iterable'\n//     }\n//     return obj.constructor.name\n//   }\n//   return type\n// }\nfunction getChildren(value, type) {\n    switch (type) {\n        case 'array':\n            return value.map((v, i) => [i.toString(), v]);\n        case 'map':\n            // eslint-disable-next-line no-case-declarations\n            const entries = Array.from(value.entries());\n            return entries.map(([key, value], i) => [\n                `[map entry ${i}]`,\n                {\n                    '[key]': key,\n                    '[value]': value\n                }\n            ]);\n        case 'set':\n            return Array.from(value.values()).map((v, i) => [`[set entry ${i}]`, v]);\n        case 'object':\n            return Object.entries(value);\n        default:\n            return [];\n    }\n}\nfunction shouldRecurseChildren(node, parent, iteratedValues, opts) {\n    if (!parent) {\n        // The root node's children should always be recursed\n        return true;\n    }\n    else if (node.collapsed && (parent === null || parent === void 0 ? void 0 : parent.collapsed)) {\n        // If the node's parent is uncollapsed the node's children should still be recursed\n        // in order to compute its value properly eg \"{} 4 keys\" and to place clickable arrow caret.\n        // Only when the node is completely hidden it should not be recursed\n        return false;\n    }\n    else if (!opts.stopCircularRecursion) {\n        return true;\n    }\n    else if (opts.isCircularNode) {\n        return opts.isCircularNode(node, iteratedValues);\n    }\n    else if (node.type === 'object' || node.type === 'array') {\n        const existingNodeWithValue = iteratedValues.get(node.value);\n        if (existingNodeWithValue && node.id !== existingNodeWithValue.id) {\n            node.circularOfId = existingNodeWithValue.id;\n            return false;\n        }\n        iteratedValues.set(node.value, node);\n    }\n    return true;\n}\nexport function recurseObjectProperties(index, key, value, depth, ensureNotCollapsed, parent, treeMap, oldTreeMap, iteratedValues, recomputeExpandNode, opts) {\n    var _a;\n    if (((_a = opts.omitKeys) === null || _a === void 0 ? void 0 : _a.includes(key)) || (opts.maxDepth && depth >= opts.maxDepth)) {\n        return null;\n    }\n    const node = createNode(index, key, value, depth, parent);\n    const oldNode = oldTreeMap.get(node.id);\n    if (ensureNotCollapsed) {\n        // Used to ensure that either root node is always uncollapsed or when uncollapsing new nodes\n        // with expandNodeChildren the node children are recursed (if applicable) with mapChildren\n        node.collapsed = false;\n    }\n    else if (oldNode && !recomputeExpandNode) {\n        // Maintain the same expanded/collapsed toggle for a node in this path/id\n        // EXCEPT when the shouldExpandNode prop is changed...\n        node.collapsed = oldNode.collapsed;\n    }\n    else if (opts.shouldExpandNode) {\n        node.collapsed = !opts.shouldExpandNode(node);\n    }\n    treeMap.set(node.id, node);\n    if (shouldRecurseChildren(node, parent, iteratedValues, opts)) {\n        const mappedChildren = opts.mapChildren && opts.mapChildren(value, getValueType(value), node);\n        const children = mappedChildren !== null && mappedChildren !== void 0 ? mappedChildren : getChildren(value, getValueType(value));\n        node.children = children\n            .map(([key, val], idx) => recurseObjectProperties(idx, key, val, depth + 1, false, node, treeMap, oldTreeMap, iteratedValues, recomputeExpandNode, opts))\n            .filter(n => n !== null);\n    }\n    return node;\n}\nexport function recomputeTree(data, oldTreeMap, recursionOpts, recomputeExpandNode) {\n    const treeMap = new Map();\n    const iteratedValues = new Map();\n    const newTree = recurseObjectProperties(-1, 'root', data, -1, true, null, treeMap, oldTreeMap, iteratedValues, recomputeExpandNode, recursionOpts);\n    return { treeMap, tree: newTree, iteratedValues };\n}\n","<script >import { getContext } from 'svelte';\nexport let id;\nconst { treeStore, propsStore, rootElementStore } = getContext('svelte-tree-view');\nlet node;\n$: {\n    let found = treeStore.getNode(id);\n    // Should explode rather than have logic written around undefinedness\n    // as this component should be unmounted if it's undefined.\n    if (!found) {\n        throw Error('[svelte-tree-view] TreeViewNode.svelte received undefined node from treeMapStore whereas it should be already unmounted!');\n    }\n    node = found;\n}\n$: hasChildren = node && node.children.length > 0;\n$: props = propsStore.props;\n$: valueComponent = $props.valueComponent;\ntreeStore.treeMap.subscribe(value => {\n    const n = value.get(id);\n    if (n && node !== n) {\n        node = n;\n    }\n});\nfunction handleLogNode() {\n    // eslint-disable-next-line no-console\n    console.info('%c [svelte-tree-view]: Property added to window._node', 'color: #b8e248');\n    // eslint-disable-next-line no-console\n    console.log(node.value);\n    try {\n        if (typeof window !== 'undefined')\n            window._node = node.value;\n    }\n    catch (err) {\n        console.error('Failed to set _node, window was undefined');\n    }\n}\nfunction handleCopyNodeToClipboard() {\n    try {\n        navigator.clipboard.writeText(JSON.stringify(node.value));\n    }\n    catch (err) {\n        console.error('Copying node to clipboard failed: ', err);\n    }\n}\nfunction handleToggleCollapse() {\n    var _a;\n    if (hasChildren) {\n        treeStore.toggleCollapse(node.id);\n    }\n    else if (node.circularOfId) {\n        treeStore.expandAllNodesToNode(node.circularOfId);\n        (_a = $rootElementStore.querySelector(`li[data-tree-id=\"${node.circularOfId}\"]`)) === null || _a === void 0 ? void 0 : _a.scrollIntoView();\n    }\n}\nfunction valueComponentDefaultFormatter(val) {\n    return propsStore.formatValue(val, node);\n}\n</script>\n\n<li class=\"row\" class:collapsed={node.collapsed && hasChildren} data-tree-id={node.id}>\n  {#if hasChildren}\n    <button\n      class={`arrow-btn ${node.collapsed ? 'collapsed' : ''}`}\n      on:click={handleToggleCollapse}\n    >\n      \n    </button>\n  {/if}\n  <div\n    class=\"node-key\"\n    class:has-children={hasChildren}\n    class:p-left={!hasChildren}\n    on:click={handleToggleCollapse}\n  >\n    {node.key}:\n  </div>\n  <div\n    class=\"node-value\"\n    data-type={node.type}\n    class:expanded={!node.collapsed && hasChildren}\n    class:has-children={hasChildren}\n    on:click={handleToggleCollapse}\n  >\n    {#if valueComponent}\n      <svelte:component\n        this={valueComponent}\n        value={node.value}\n        {node}\n        defaultFormatter={valueComponentDefaultFormatter}\n      />\n    {:else}\n      {propsStore.formatValue(node.value, node)}\n    {/if}\n  </div>\n  <div class=\"buttons\">\n    {#if $props.showLogButton}\n      <button class=\"log-copy-button\" on:click={handleLogNode}>log</button>\n    {/if}\n    {#if $props.showCopyButton}\n      <button class=\"log-copy-button\" on:click={handleCopyNodeToClipboard}>copy</button>\n    {/if}\n  </div>\n</li>\n{#if !node.collapsed && hasChildren}\n  <li class=\"row\">\n    <ul>\n      {#each node.children as child}\n        <svelte:self id={child.id} />\n      {/each}\n    </ul>\n  </li>\n{/if}\n\n<style >ul {\n  display: flex;\n  flex-direction: column;\n  height: max-content;\n  list-style: none;\n  padding: 0;\n  padding-left: var(--tree-view-left-indent);\n  margin: 0;\n  width: 100%;\n}\n\nli {\n  align-items: baseline;\n  display: flex;\n  height: max-content;\n  line-height: var(--tree-view-line-height);\n  list-style: none;\n  width: 100%;\n}\n\nli + li {\n  margin-top: 0.25em;\n}\n\n.empty-block {\n  visibility: hidden;\n}\n\n.node-key {\n  color: var(--tree-view-base0D);\n  margin-right: var(--tree-view-key-margin-right);\n}\n.node-key.has-children {\n  cursor: pointer;\n}\n.node-key.p-left {\n  padding-left: 1.1em;\n}\n\n.node-value {\n  color: var(--tree-view-base0B);\n  margin-right: 0.5em;\n  word-break: break-all;\n}\n.node-value[data-type=number], .node-value[data-type=boolean] {\n  color: var(--tree-view-base09);\n}\n.node-value[data-type=null], .node-value[data-type=undefined] {\n  color: var(--tree-view-base08);\n}\n.node-value.expanded {\n  color: var(--tree-view-base03);\n}\n.node-value.has-children {\n  cursor: pointer;\n}\n\n.arrow-btn {\n  background: transparent;\n  border: 0;\n  color: var(--tree-view-base0D);\n  cursor: pointer;\n  margin-right: 0.7em;\n  padding: 0;\n  transition: all 150ms ease 0s;\n  transform: rotateZ(90deg);\n  transform-origin: 47% 43%;\n  position: relative;\n  line-height: 1.1em;\n  font-size: 0.75em;\n}\n.arrow-btn.collapsed {\n  transform: rotateZ(0deg);\n}\n\n.buttons {\n  display: flex;\n  flex-wrap: wrap;\n}\n\n.log-copy-button {\n  background: transparent;\n  border: 0;\n  color: var(--tree-view-base0D);\n  cursor: pointer;\n  margin: 0;\n  padding: 0 0.5em;\n}\n.log-copy-button:hover {\n  background: rgba(255, 162, 177, 0.4);\n  border-radius: 2px;\n  color: var(--tree-view-base07);\n}</style>\n","<script >var _a;\nimport { setContext, onMount } from 'svelte';\nimport { get } from 'svelte/store';\nimport { recomputeTree } from './tree-utils';\nimport { createPropsStore, createRootElementStore, createTreeStore, } from './stores';\nimport TreeViewNode from './TreeViewNode.svelte';\nexport let data, theme = undefined, showLogButton = false, showCopyButton = false, valueComponent = undefined, recursionOpts = {}, valueFormatter = undefined;\nlet rootElement = null;\nconst defaultRecursionOpts = {\n    maxDepth: 16,\n    omitKeys: [],\n    stopCircularRecursion: false,\n    shouldExpandNode: () => false\n};\nlet props = {\n    showLogButton,\n    showCopyButton,\n    valueComponent,\n    recursionOpts: Object.assign(Object.assign({}, defaultRecursionOpts), recursionOpts),\n    valueFormatter\n};\n$: rootNode = treeStore.tree;\n$: {\n    // To keep things less messy all props are joined to one object _except_ the recursionOpts\n    // which is picked from the old props. This is to allow checking between the old and new recursionOpts\n    // in the recomputeTree.\n    props = {\n        showLogButton,\n        showCopyButton,\n        valueComponent,\n        valueFormatter,\n        recursionOpts: props.recursionOpts\n    };\n}\n$: {\n    // Combine the defaultProps with the possible new recursion opts\n    const newRecursionOpts = Object.assign(Object.assign({}, defaultRecursionOpts), recursionOpts);\n    // Compare the old shouldExpandNode option with the possible new shouldExpandNode\n    // to know whether to whole tree should be recomputed.\n    const recomputeExpandNode = ((_a = props === null || props === void 0 ? void 0 : props.recursionOpts) === null || _a === void 0 ? void 0 : _a.shouldExpandNode) !== newRecursionOpts.shouldExpandNode;\n    const oldTreeMap = get(treeStore.treeMap);\n    const { treeMap, tree, iteratedValues } = recomputeTree(data, oldTreeMap, newRecursionOpts, recomputeExpandNode);\n    treeStore.init(tree, treeMap, iteratedValues);\n    props.recursionOpts = newRecursionOpts;\n    propsStore.setProps(props);\n}\n$: {\n    if (theme && rootElement) {\n        let key;\n        for (key in theme) {\n            // This ridiculous thing is for TypeScript type inference. Yey..?\n            const value = theme[key];\n            if (rootElement && key.includes('--tree-view-base') && value) {\n                rootElement.style.setProperty(`--tree-view-${key}`, value);\n            }\n        }\n    }\n}\nconst propsStore = createPropsStore(props);\nconst rootElementStore = createRootElementStore();\nconst treeStore = createTreeStore(propsStore);\nsetContext('svelte-tree-view', {\n    propsStore,\n    rootElementStore,\n    treeStore,\n});\nonMount(() => {\n    rootElementStore.set(rootElement);\n});\n</script>\n\n<ul class={`${$$props.class || ''} svelte-tree-view`} bind:this={rootElement}>\n  {#each $rootNode.children as child}\n    <TreeViewNode id={child.id} />\n  {/each}\n</ul>\n\n<style>\n  * {\n    box-sizing: border-box;\n  }\n  :root {\n    --tree-view-base00: #363755;\n    --tree-view-base01: #604d49;\n    --tree-view-base02: #6d5a55;\n    --tree-view-base03: #d1929b;\n    --tree-view-base04: #b79f8d;\n    --tree-view-base05: #f9f8f2;\n    --tree-view-base06: #f7f4f1;\n    --tree-view-base07: #faf8f5;\n    --tree-view-base08: #fa3e7e;\n    --tree-view-base09: #fd993c;\n    --tree-view-base0A: #f6bf81;\n    --tree-view-base0B: #b8e248;\n    --tree-view-base0C: #b4efe4;\n    --tree-view-base0D: #85d9ef;\n    --tree-view-base0E: #be87ff;\n    --tree-view-base0F: #d6724c;\n\n    --tree-view-font-family: 'Helvetica Neue', 'Calibri Light', Roboto, sans-serif;\n    --tree-view-font-size: 13px;\n    --tree-view-left-indent: 0.875em;\n    --tree-view-line-height: 1.1;\n    --tree-view-key-margin-right: 0.5em;\n  }\n  ul {\n    background: var(--tree-view-base00);\n    font-family: var(--tree-view-font-family);\n    font-size: var(--tree-view-font-size);\n    height: max-content;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: max-content;\n  }\n</style>\n","import { derived, get, writable } from 'svelte/store';\nexport const createPropsStore = (initialProps) => {\n    const props = writable(initialProps);\n    const recursionOpts = derived(props, p => p.recursionOpts);\n    return {\n        props,\n        recursionOpts,\n        setProps(newProps) {\n            props.set(newProps);\n        },\n        formatValue(val, node) {\n            const { valueFormatter } = get(props);\n            const customFormat = valueFormatter ? valueFormatter(val, node) : undefined;\n            if (customFormat) {\n                return customFormat;\n            }\n            switch (node.type) {\n                case 'array':\n                    return `${node.circularOfId ? 'circular' : ''} [] ${val.length} items`;\n                case 'object':\n                    return `${node.circularOfId ? 'circular' : ''} {} ${Object.keys(val).length} keys`;\n                case 'map':\n                case 'set':\n                    return `${node.circularOfId ? 'circular' : ''} () ${val.size} entries`;\n                case 'date':\n                    return `${val.toISOString()}`;\n                case 'string':\n                    return `\"${val}\"`;\n                case 'boolean':\n                    return val ? 'true' : 'false';\n                default:\n                    return val;\n            }\n        }\n    };\n};\n","import { writable } from 'svelte/store';\nexport const createRootElementStore = () => {\n    const rootElementStore = writable(null);\n    return {\n        set: rootElementStore.set,\n        subscribe: rootElementStore.subscribe\n    };\n};\n","import { get, writable } from 'svelte/store';\nimport { createNode, recurseObjectProperties } from '../tree-utils';\nexport const createTreeStore = (propsStore) => {\n    const defaultRootNode = createNode(0, 'root', [], 0, null);\n    const tree = writable(defaultRootNode);\n    const treeMap = writable(new Map());\n    const iteratedValues = writable(new Map());\n    return {\n        tree,\n        treeMap,\n        defaultRootNode,\n        init(newTree, newTreeMap, iterated) {\n            if (newTree) {\n                tree.set(newTree);\n            }\n            else {\n                tree.set(defaultRootNode);\n            }\n            treeMap.set(newTreeMap);\n            iteratedValues.set(iterated);\n        },\n        getNode(id) {\n            return get(treeMap).get(id);\n        },\n        toggleCollapse(id) {\n            const node = get(treeMap).get(id);\n            if (!node) {\n                console.warn(`Attempted to collapse non-existent node: ${id}`);\n                return;\n            }\n            const updatedNode = { ...node, collapsed: !node.collapsed };\n            treeMap.update(m => new Map(m.set(node.id, updatedNode)));\n            const recursionOpts = get(propsStore.recursionOpts);\n            if (recursionOpts) {\n                this.expandNodeChildren(updatedNode, recursionOpts);\n            }\n        },\n        expandNodeChildren(node, recursionOpts) {\n            const parent = this.getNode((node === null || node === void 0 ? void 0 : node.parentId) || '') || null;\n            if (!parent) {\n                // Only root node has no parent and it should not be expandable\n                throw Error('No parent in expandNodeChildren for node: ' + node);\n            }\n            const newTreeMap = new Map(get(treeMap));\n            const oldTreeMap = get(treeMap);\n            const previouslyIterated = get(iteratedValues);\n            const nodeWithUpdatedChildren = recurseObjectProperties(node.index, node.key, node.value, node.depth, !node.collapsed, // Ensure that when uncollapsed the node's children are always recursed\n            parent, newTreeMap, oldTreeMap, previouslyIterated, false, // Never recompute shouldExpandNode since it may override the collapsing of this node\n            recursionOpts);\n            if (!nodeWithUpdatedChildren)\n                return;\n            parent.children = parent.children.map(c => c.id === nodeWithUpdatedChildren.id ? nodeWithUpdatedChildren : c);\n            newTreeMap.set(nodeWithUpdatedChildren.id, nodeWithUpdatedChildren);\n            newTreeMap.set(parent.id, parent);\n            treeMap.set(newTreeMap);\n            iteratedValues.set(previouslyIterated);\n        },\n        expandAllNodesToNode(id) {\n            function recurseNodeUpwards(updated, node) {\n                if (!node)\n                    return;\n                updated.set(node.id, { ...node, collapsed: false });\n                if (node.parentId) {\n                    recurseNodeUpwards(updated, updated.get(node.parentId));\n                }\n            }\n            const updated = new Map(get(treeMap));\n            recurseNodeUpwards(updated, updated.get(id));\n            treeMap.set(updated);\n        }\n    };\n};\n","<section class=\"split-view\">\n  <slot class=\"left-panel\" name=\"left\" />\n  <slot class=\"right-panel\" name=\"right\" />\n</section>\n\n<style lang=\"scss\">\n  section {\n    border-top: 1px solid rgba($color-red-light, 0.2);\n    color: var(--color-white);\n    display: flex;\n    height: calc(100% - var(--height-tabs-menu));\n    width: 100%;\n  }\n  :global(.split-view h2) {\n    color: var(--color-red-gray);\n    font-family: var(--font-sans);\n    font-size: var(--font-medium);\n    font-weight: 400;\n    letter-spacing: 1px;\n    margin: 0;\n    text-transform: uppercase;\n  }\n  :global(.split-view > .left-panel) {\n    display: flex;\n    flex-direction: column;\n    flex-grow: 1;\n    overflow: scroll;\n    padding: 1em;\n  }\n  :global(.split-view > .right-panel) {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    display: flex;\n    flex-direction: column;\n    flex-grow: 1;\n    overflow: scroll;\n    padding: 1em;\n  }\n  :global(.split-view .hidden) {\n    visibility: hidden;\n  }\n</style>\n","<script lang=\"ts\">\n  export let selected = false\n  let buttonProps = {\n    class: [$$restProps.class]\n  }\n</script>\n\n<button on:click on:mouseover on:mouseenter on:mouseleave on:focus {...buttonProps} class:selected\n  ><slot /></button\n>\n\n<style lang=\"scss\">\n  button {\n    background: transparent;\n    border: 0;\n    border-radius: 2px;\n    color: var(--color-gray-light);\n    cursor: pointer;\n    font-size: var(--font-small);\n    padding: 6px 10px;\n    text-transform: uppercase;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: var(--color-white);\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n    }\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n  import { latestEntry } from '$stores/stateHistory'\n  import { getActiveMarks } from './getActiveMarks'\n  import { createSelection, createFullSelection } from './selection'\n\n  import TreeView from 'svelte-tree-view'\n  import type { TreeNode } from 'svelte-tree-view'\n  import SplitView from '../SplitView.svelte'\n  import Button from '$components/Button.svelte'\n\n  const { view } = getContext('editor-view')\n  let doc = view.state.doc.toJSON()\n  let selection = createSelection(view.state.selection)\n  let currentState = view.state\n  let activeMarks: string[] = []\n  let nodeSize = view.state.doc.nodeSize\n  let childCount = view.state.doc.childCount\n  let expandedSelection = false\n\n  latestEntry.subscribe(e => {\n    if (!e) return\n    const { state } = e\n    currentState = state\n    doc = state.doc.toJSON()\n    selection = expandedSelection ? createFullSelection(state.selection) : createSelection(state.selection)\n    activeMarks = getActiveMarks(state)\n    nodeSize = state.doc.nodeSize\n    childCount = state.doc.childCount\n  })\n\n  function handleClickLogDoc() {\n    console.log(doc)\n    window._doc = doc\n  }\n  function handleExpandSelection() {\n    expandedSelection = !expandedSelection\n    if (expandedSelection) {\n      selection = createFullSelection(currentState.selection)\n    } else {\n      selection = createSelection(currentState.selection)\n    }\n  }\n  function formatDocNodeValue(val: any, n: TreeNode) {\n    if (n.type === 'object' && val.type) {\n      return `{} ${val.type}`\n    }\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <div class=\"top-row\">\n      <h2>Current doc</h2>\n      <Button on:click={handleClickLogDoc}>log</Button>\n    </div>\n    <TreeView\n      class=\"tree-view\"\n      data={doc}\n      showLogButton\n      showCopyButton\n      valueFormatter={formatDocNodeValue}\n    />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    <div class=\"top-row\">\n      <h2>Selection</h2>\n      <Button class=\"selection-btn\" on:click={handleExpandSelection}\n        ><span class=\"caret-icon\" class:expanded={expandedSelection} /></Button\n      >\n    </div>\n    <TreeView class=\"tree-view\" data={selection} />\n    <div>\n      <h2>Active marks</h2>\n      {#if activeMarks.length === 0}\n        <div class=\"no-marks\">No active marks</div>\n      {:else}\n        <TreeView class=\"tree-view\" data={activeMarks} />\n      {/if}\n    </div>\n    <div>\n      <h2>Document stats</h2>\n      <TreeView\n        class=\"tree-view\"\n        data={{\n          nodeSize,\n          childCount\n        }}\n      />\n    </div>\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .left-panel {\n    overflow: scroll;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    flex-grow: 0;\n    min-width: 200px;\n    width: 200px;\n  }\n  :global(.split-view .selection-btn) {\n    height: 24px;\n    width: 35px;\n  }\n  .caret-icon::before {\n    content: '';\n  }\n  .caret-icon.expanded::before {\n    content: '';\n  }\n  .no-marks {\n    color: var(--color-blue-light);\n    margin: 0.5em 0 1em 1em;\n  }\n  :global(.split-view .tree-view) {\n    margin: 0.5em 0 1em 0;\n  }\n</style>\n","import { EditorState } from 'prosemirror-state'\n\n// From https://github.com/PierBover/prosemirror-cookbook\nexport function getActiveMarks(state: EditorState): string[] {\n  if (state.selection.empty) {\n    const $from = state.selection.$from\n    const storedMarks = state.storedMarks\n\n    // Return either the stored marks, or the marks at the cursor position.\n    // Stored marks are the marks that are going to be applied to the next input\n    // if you dispatched a mark toggle with an empty cursor.\n    if (storedMarks) {\n      return storedMarks.map(mark => mark.type.name)\n    } else {\n      return $from.marks().map(mark => mark.type.name)\n    }\n  } else {\n    const $head = state.selection.$head\n    const $anchor = state.selection.$anchor\n\n    // We're using a Set to not get duplicate values\n    const activeMarks = new Set<string>()\n\n    // Here we're getting the marks at the head and anchor of the selection\n    $head.marks().forEach(mark => activeMarks.add(mark.type.name))\n    $anchor.marks().forEach(mark => activeMarks.add(mark.type.name))\n\n    return Array.from(activeMarks)\n  }\n}\n","import type { Delta } from 'jsondiffpatch'\nimport type { TreeNode, ValueType } from 'svelte-tree-view'\n\n// function postprocessValue(value: any) {\n//   if (value && value._t === 'a') {\n//     const res: { [key: string]: string | string[] } = {}\n//     for (const key in value) {\n//       if (key !== '_t') {\n//         if (key[0] === '_' && !value[key.substr(1)]) {\n//           res[key.substr(1)] = value[key]\n//         } else if (value['_' + key]) {\n//           res[key] = [value['_' + key][0], value[key][0]]\n//         } else if (!value['_' + key] && key[0] !== '_') {\n//           res[key] = value[key]\n//         }\n//       }\n//     }\n//     return res\n//   }\n//   return value\n// }\n\nexport function mapSelectionDeltaChildren(\n  _val: any,\n  type: ValueType,\n  _parent: TreeNode\n): [string, any][] | undefined {\n  if (type !== 'array') return\n  return []\n}\n\n/**\n * Magic function to transform jsondiffpatch array deltas\n * https://github.com/benjamine/jsondiffpatch/blob/master/docs/deltas.md\n * https://benjamine.github.io/jsondiffpatch/demo/index.html\n */\nexport function mapDocDeltaChildren(delta: Delta, type: ValueType) {\n  // So due to the way the tree-view works, it will automatically map the children of an array\n  // to their own nodes. For diff deltas, however, we want to omit those children and just show\n  // a value wrapped with <span> to show either deleted or inserted content\n  if (type === 'array' && delta[1] === 0 && delta[2] === 0) {\n    // Remove operation is defined by two 0s in its delta [{ <deleted> }, 0, 0]\n    return []\n    // } else if (type === 'array' && typeof delta[0] === 'string' && typeof delta[1] === 'number' && delta[2] === 3) {\n    // Move operation is almost the same as remove, except its value is empty and the second number\n    // points to the moved index eg [\"\", 6, 3] AND the third value is always '3'\n    // But since these seem to never occur (and they weren't handled in the previous version) we are not doing anything\n    // with them for now.\n  } else if (type === 'array' && typeof delta[0] === 'string' && delta[1] === 0 && delta[2] === 2) {\n    // If a diff between two strings gets too long, a text diff algorithm is used which produces an array\n    // with unidiff as the first value, 0 as the second and 2 as third.\n    // Eg [\"@@ -1,4 +1,9 @@\\n-text\\n+paragraph\\n\", 0, 2]\n    return []\n  } else if (type === 'array' && delta.length === 1 && typeof delta[0] === 'object') {\n    // Insert operations do not have indexes (it's already indexed in the array) and carry\n    // only an object payload eg [{ <inserted> }]\n    return []\n  }\n\n  // The main delta objects are objects denoted by key '_t' with 'a' value which we shall omit.\n  // DiffValue component handles the text diffs otherwise.\n  if (type !== 'object' || delta._t !== 'a') return\n\n  // We shall remap the values to omit '_t' and remove underscores from the keys\n  const transformed: [string, any][] = []\n  for (const key in delta) {\n    if (key === '_t') continue\n    // Remove or move operation is indicated by an underscore before the index eg '_2'\n    if (key.charAt(0) === '_') {\n      transformed.push([key.substr(1), delta[key]])\n    } else {\n      transformed.push([key, delta[key]])\n    }\n  }\n  return transformed\n}\n","<script lang=\"ts\">\n  import type { HistoryEntry } from '$typings/history'\n\n  export let listItems: {\n      isGroup: boolean\n      topEntry: HistoryEntry | undefined\n      entries: (HistoryEntry | undefined)[]\n      expanded: boolean\n    }[] = [],\n    selectedId: string,\n    onSelect: (id: string, groupIdx: number, wasTopNode: boolean) => void\n</script>\n\n<ul>\n  {#each listItems as group, groupIdx}\n    <li class:selected={!group.expanded && selectedId === group?.topEntry?.id}>\n      <button\n        class:is-group={group.isGroup}\n        on:click={() => group.topEntry && onSelect(group.topEntry.id, groupIdx, true)}\n      >\n        <span>\n          {group?.topEntry?.timeStr}\n          {#if group.isGroup}\n            [{group.entries.length}]\n          {/if}\n        </span>\n        {#if group.isGroup && group.entries.length > 1}\n          <span class=\"caret-icon\" class:expanded={group.expanded} />\n        {/if}\n      </button>\n    </li>\n    {#if group.isGroup && group.expanded}\n      {#each group.entries as subEntry}\n        <li class:selected={selectedId === subEntry?.id}>\n          <button\n            class=\"p-left\"\n            on:click={() => subEntry && onSelect(subEntry.id, groupIdx, false)}\n          >\n            {subEntry?.timeStr}\n          </button>\n        </li>\n      {/each}\n    {/if}\n  {/each}\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    color: var(--color-white);\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n    width: 100%;\n  }\n  li {\n    transition: background 0.1s;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: var(--color-white);\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n    }\n  }\n  li + li {\n    border-top: 1px solid var(--color-purple);\n  }\n  button {\n    background: transparent;\n    border: 0;\n    color: var(--color-gray-light);\n    cursor: pointer;\n    display: flex;\n    font-family: monospace;\n    font-size: var(--font-small);\n    height: 100%;\n    justify-content: space-between;\n    padding: 6px 18px;\n    text-transform: uppercase;\n    width: 100%;\n\n    &.p-left {\n      margin-left: 1em;\n    }\n  }\n  .caret-icon::before {\n    content: '';\n  }\n  .caret-icon.expanded::before {\n    content: '';\n  }\n</style>\n","<script lang=\"ts\">\n  import type { TreeNode } from 'svelte-tree-view'\n\n  export let value: any, node: TreeNode, defaultFormatter: (val: any) => string\n\n  $: nodeVal = node.value\n\n  function replaceSpacesWithNonBreakingSpace(value: string) {\n    return value.replace(/\\s/gm, '')\n  }\n  function parseTextDiff(textDiff: string) {\n    const diffByLines = textDiff.split(/\\n/gm).slice(1)\n    return diffByLines.map(line => {\n      const type = line.startsWith('-') ? 'delete' : line.startsWith('+') ? 'add' : 'raw'\n\n      return { [type]: replaceSpacesWithNonBreakingSpace(line.substr(1)) }\n    })\n  }\n  function stringifyAndShrink(v: any) {\n    if (v === null) {\n      return 'null'\n    }\n    const str = JSON.stringify(v)\n    if (typeof str === 'undefined') {\n      return 'undefined'\n    }\n    return str.length > 22 ? `${str.substr(0, 15)}${str.substr(-5)}` : str\n  }\n\n  function getValueString(raw: any) {\n    if (typeof raw === 'string') {\n      return raw\n    }\n    return stringifyAndShrink(raw)\n  }\n</script>\n\n{#if Array.isArray(nodeVal)}\n  <!-- The why https://github.com/benjamine/jsondiffpatch/blob/master/docs/deltas.md -->\n  {#if nodeVal.length === 1}\n    <span class=\"added\">{getValueString(nodeVal[0])}</span>\n  {:else if nodeVal.length === 2}\n    <span class=\"updated\">\n      <span class=\"deleted\">{getValueString(nodeVal[0])}</span>\n      <span class=\"arrow\"> =&gt;</span>\n      <span class=\"added\">{getValueString(nodeVal[1])}</span>\n    </span>\n  {:else if nodeVal.length === 3 && nodeVal[1] === 0 && nodeVal[2] === 0}\n    <span class=\"deleted\">{getValueString(nodeVal[0])}</span>\n  {:else if nodeVal.length === 3 && nodeVal[2] === 2}\n    <span class=\"updated\">\n      {#each parseTextDiff(nodeVal[0]) as item}\n        {#if item.delete}\n          <span class=\"deleted\">{item.delete}</span>\n        {:else if item.add}\n          <span class=\"added\">{item.add}</span>\n        {:else}\n          <span>{item.raw}</span>\n        {/if}\n      {/each}\n    </span>\n  {/if}\n{:else}\n  {defaultFormatter(nodeVal)}\n{/if}\n\n<style>\n  .added {\n    display: inline-block;\n    background: var(--color-green-light);\n    border-radius: 1px;\n    color: var(--color-green);\n    padding: 1px 2px;\n    text-indent: 0;\n    min-height: 1ex;\n  }\n  .deleted {\n    display: inline-block;\n    background: var(--color-red);\n    border-radius: 1px;\n    color: var(--color-gray-light);\n    padding: 1px 2px;\n    text-decoration: line-through;\n    text-indent: 0;\n    min-height: 1ex;\n  }\n  .updated {\n    word-break: break-all;\n  }\n  .updated .added {\n    background: var(--color-yellow);\n  }\n  .arrow {\n    color: var(--color-green-light);\n  }\n</style>\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","<script lang=\"ts\">\n  import { stateHistory, shownHistoryGroups, latestEntry } from '$stores/stateHistory'\n  import type { HistoryEntry, HistoryGroup } from '$typings/history'\n  import { mapDocDeltaChildren, mapSelectionDeltaChildren } from './mapDeltas'\n\n  import SplitView from '../SplitView.svelte'\n  import TreeView from 'svelte-tree-view'\n  import HistoryList from './HistoryList.svelte'\n  import DiffValue from './DiffValue.svelte'\n  import Button from '$components/Button.svelte'\n\n  let selectedEntry: HistoryEntry | undefined = undefined,\n    showTr = false\n\n  let expandTrTreeView = false\n  let transactionRecursionOpts = {\n    maxDepth: 12,\n    stopCircularRecursion: true,\n    omitKeys: ['schema'],\n    shouldExpandNode: () => expandTrTreeView\n  }\n  $: listItems = $shownHistoryGroups.map((g: HistoryGroup) => ({\n    isGroup: g.isGroup,\n    topEntry: $stateHistory.get(g.topEntryId),\n    entries: g.entryIds.map(id => $stateHistory.get(id)),\n    expanded: g.expanded\n  }))\n  latestEntry.subscribe(v => {\n    if (v) selectedEntry = v\n  })\n\n  function toggleShowTr() {\n    showTr = !showTr\n  }\n  function handleLogTr() {\n    console.info('%c [prosemirror-dev-toolkit]: Property added to window._tr', 'color: #b8e248')\n    console.log(selectedEntry?.tr)\n    window._tr = selectedEntry?.tr\n  }\n  /**\n   * Handles the clicks of the history entries.\n   *\n   * Sets the clicked entry as the selectedEntry but in the case of topNode, meaning\n   * in a selection group (shown with [x] number) the entry has a sublist of entries\n   * where the previous is duplicated as the first entry. Therefore on expanding the group\n   * selecting the first sub-entry, otherwise collapsing but still keeping the topNode selected.\n   * Kinda confusing but eh.\n   */\n  function handleEntrySelect(id: string, groupIdx: number, wasTopNode: boolean) {\n    selectedEntry = $stateHistory.get(id)\n    const group = listItems[groupIdx]\n    if (group.isGroup && group.entries.length > 1 && wasTopNode) {\n      shownHistoryGroups.update(val =>\n        val.map((g, idx) => (idx !== groupIdx ? g : { ...g, expanded: !g.expanded }))\n      )\n    }\n  }\n  function handleToggleExpandTrTreeView() {\n    expandTrTreeView = !expandTrTreeView\n    transactionRecursionOpts = {\n      ...transactionRecursionOpts,\n      shouldExpandNode: () => expandTrTreeView\n    }\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <!-- Cant use optional chaining here as it wont get transpiled correctly to ES5 :( -->\n    <HistoryList {listItems} selectedId={selectedEntry?.id || ''} onSelect={handleEntrySelect} />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    {#if selectedEntry}\n      <div>\n        {#if selectedEntry.contentDiff}\n          <div class=\"entry-row\">\n            <div class=\"title-container\">\n              <h2>Doc diff</h2>\n              <Button class=\"hidden\">log</Button>\n            </div>\n            <TreeView\n              class=\"tree-view\"\n              data={selectedEntry.contentDiff}\n              showLogButton\n              showCopyButton\n              valueComponent={DiffValue}\n              recursionOpts={{\n                maxDepth: 12,\n                mapChildren: mapDocDeltaChildren,\n                shouldExpandNode: () => true\n              }}\n            />\n          </div>\n        {/if}\n        {#if selectedEntry.selectionDiff}\n          <div class=\"entry-row\">\n            <div class=\"title-container\">\n              <h2>Selection diff</h2>\n              <Button class=\"hidden\">log</Button>\n            </div>\n            <TreeView\n              class=\"tree-view\"\n              data={selectedEntry.selectionDiff}\n              valueComponent={DiffValue}\n              recursionOpts={{\n                mapChildren: mapSelectionDeltaChildren,\n                shouldExpandNode: () => true\n              }}\n            />\n          </div>\n        {/if}\n        {#if selectedEntry.selectionHtml.length > 0}\n          <div class=\"entry-row\">\n            <div class=\"title-container\">\n              <h2>Selection content</h2>\n              <Button class=\"hidden\">log</Button>\n            </div>\n            <pre class=\"selection-html\"><code>{@html selectedEntry.selectionHtml}</code></pre>\n          </div>\n        {/if}\n        <div class=\"entry-row\">\n          <div class=\"title-container\">\n            <h2>Transaction</h2>\n            <div>\n              {#if showTr}\n                <Button on:click={handleToggleExpandTrTreeView}>\n                  {expandTrTreeView ? 'collapse' : 'expand'}\n                </Button>\n                <Button on:click={handleLogTr}>log</Button>\n              {/if}\n              <Button on:click={toggleShowTr}>\n                {showTr ? 'hide' : 'show'}\n              </Button>\n            </div>\n          </div>\n          {#if showTr}\n            <TreeView\n              class=\"tree-view\"\n              data={selectedEntry.tr}\n              showLogButton\n              showCopyButton\n              recursionOpts={transactionRecursionOpts}\n            />\n          {/if}\n        </div>\n      </div>\n    {:else}\n      <div class=\"equal-diff\">Docs are equal.</div>\n    {/if}\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .left-panel {\n    flex-grow: 0;\n    padding: 0;\n    min-width: 190px;\n    width: 190px;\n  }\n  .title-container {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .entry-row + .entry-row {\n    margin-top: 1em;\n  }\n  .selection-html {\n    font-weight: 100;\n    margin: 0.5em 0 0 0;\n    padding: 0;\n  }\n  .equal-diff {\n    align-items: center;\n    color: var(--color-red-light);\n    display: flex;\n    font-size: 14px;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n  }\n</style>\n","<script lang=\"ts\">\n  export let listItems: { key: string; value: string }[] = [],\n    selectedKey: string | undefined,\n    onSelect: (item: { key: string; value: string }) => void\n</script>\n\n<ul>\n  {#each listItems as item}\n    <li>\n      <button class:selected={selectedKey === item.key} on:click={() => onSelect(item)}\n        >{item.value}</button\n      >\n    </li>\n  {/each}\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    color: var(--color-white);\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n    width: 100%;\n  }\n  li + li {\n    border-top: 1px solid var(--color-purple);\n  }\n  button {\n    background: transparent;\n    border: 0;\n    color: var(--color-gray-light);\n    cursor: pointer;\n    display: flex;\n    font-family: monospace;\n    font-size: var(--font-small);\n    font-weight: 100;\n    height: 100%;\n    padding: 6px 18px;\n    text-transform: uppercase;\n    width: 100%;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: var(--color-white);\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n      &.empty {\n        background: var(--color-purple-dark);\n      }\n    }\n    &.empty {\n      background: transparent;\n      color: var(--color-purple-light);\n      &:hover {\n        background: var(--color-purple-dark);\n      }\n    }\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n  import type { EditorState } from 'prosemirror-state'\n  import { latestEntry } from '$stores/stateHistory'\n\n  import SplitView from './SplitView.svelte'\n  import TreeView from 'svelte-tree-view'\n  import List from './List.svelte'\n  import Button from '$components/Button.svelte'\n\n  import type { Plugin } from '$typings/pm'\n\n  const { view } = getContext('editor-view')\n  let expandPluginState = false\n  let recursionOpts = {\n    maxDepth: 10,\n    stopCircularRecursion: true,\n    shouldExpandNode: () => expandPluginState\n  }\n  let editorState: EditorState = view.state\n  let plugins = editorState.plugins as Plugin[]\n  let selectedPlugin = plugins[0] as Plugin | undefined\n  $: pluginState = selectedPlugin?.getState(editorState) as unknown\n  $: listItems = plugins.map((p: Plugin) => ({\n    key: p.key, // TODO this can be undefined??\n    value: p.key.toUpperCase(),\n    empty: !p.getState(editorState)\n  }))\n\n  latestEntry.subscribe(e => {\n    if (!e) return\n    editorState = e.state\n    plugins = editorState.plugins as Plugin[]\n    selectedPlugin = plugins.find(p => p.key === selectedPlugin?.key) as Plugin\n  })\n\n  function handlePluginSelect(item: { key: string; value: string }) {\n    selectedPlugin = plugins.find(p => p.key === item.key) as Plugin\n  }\n  function handleToggleExpand() {\n    expandPluginState = !expandPluginState\n    recursionOpts = { ...recursionOpts, shouldExpandNode: () => expandPluginState }\n  }\n  function handleLogState() {\n    window._plugin = [selectedPlugin, pluginState]\n    console.info('%c [prosemirror-dev-toolkit]: Property added to window._plugin', 'color: #b8e248')\n    console.log(selectedPlugin)\n    console.log(pluginState)\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <List {listItems} selectedKey={selectedPlugin?.key} onSelect={handlePluginSelect} />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    {#if pluginState}\n      <div class=\"top-row\">\n        <h2>Plugin state</h2>\n        <div>\n          <Button on:click={handleToggleExpand}>\n            {expandPluginState ? 'collapse' : 'expand'}\n          </Button>\n          <Button on:click={handleLogState}>log</Button>\n        </div>\n      </div>\n    {/if}\n    {#if pluginState}\n      <TreeView data={pluginState} showLogButton showCopyButton {recursionOpts} />\n    {:else}\n      <div class=\"empty-state\">Plugin has no state</div>\n    {/if}\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n    margin-bottom: 0.5em;\n  }\n  .left-panel {\n    flex-grow: 0;\n    overflow: scroll;\n    padding: 0;\n    min-width: 190px;\n    width: 190px;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n  }\n  .empty-state {\n    align-items: center;\n    color: var(--color-red-light);\n    display: flex;\n    font-size: 14px;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n\n  import TreeView from 'svelte-tree-view'\n  import SplitView from './SplitView.svelte'\n  import Button from '$components/Button.svelte'\n\n  const { view } = getContext('editor-view')\n\n  let nodes = view.state.schema.nodes\n  let marks = view.state.schema.marks\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <div class=\"top-row\">\n      <h2>Nodes</h2>\n      <Button class=\"hidden\">log</Button>\n    </div>\n    <TreeView\n      class=\"tree-view\"\n      data={nodes}\n      showLogButton\n      showCopyButton\n      recursionOpts={{\n        stopCircularRecursion: true\n      }}\n    />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    <div class=\"top-row\">\n      <h2>Marks</h2>\n      <Button class=\"hidden\">log</Button>\n    </div>\n    <TreeView\n      class=\"tree-view\"\n      data={marks}\n      showLogButton\n      showCopyButton\n      recursionOpts={{\n        stopCircularRecursion: true\n      }}\n    />\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .left-panel {\n    overflow: scroll;\n    padding: 1em;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    overflow: scroll;\n    padding: 1em;\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n  import type { Node as PMNode } from 'prosemirror-model'\n  import type { Fragment } from '$typings/pm'\n\n  const { selected, colors, handleNodeClick } = getContext('doc-view')\n\n  export let node: PMNode,\n    startPos: number,\n    isRoot = false\n\n  $: fragment = node.content as Fragment\n  $: color = colors[node.type.name]\n  $: name =\n    node.isText && node.marks.length > 0\n      ? `${node.type.name} - [${node.marks.map(m => m.type.name).join(', ')}]`\n      : node.type.name\n\n  $: startPositions = Array(node.childCount)\n    .fill(undefined)\n    .reduce((acc, _, idx) => {\n      if (idx === 0) {\n        return [isRoot ? 0 : startPos + 1]\n      }\n      let prev = acc[idx - 1]\n      let cur = node.child(idx - 1)\n      return [...acc, prev + cur.nodeSize]\n    }, [])\n\n  $: endPos = startPos + node.nodeSize\n  $: inlineChildren = fragment.content.every(n => n.isInline)\n\n  function handleNameClick() {\n    handleNodeClick(node)\n  }\n</script>\n\n<li class={`${$$props.class || ''} doc-node`} class:root={isRoot}>\n  <div class=\"doc-node-body\" style={`background: ${color}`}>\n    <div class=\"number-box\">{startPos}</div>\n    <button class:selected={false} aria-label=\"Show node info button\" on:click={handleNameClick}\n      >{name}</button\n    >\n    <div class=\"number-box\">{endPos}</div>\n  </div>\n  <ul class:inline-children={inlineChildren}>\n    {#each fragment.content as child, i}\n      <svelte:self node={child} startPos={startPositions[i]} />\n    {/each}\n  </ul>\n</li>\n\n<style lang=\"scss\">\n  .doc-node {\n    border-left: 1px solid var(--color-blue-bg);\n    border-right: 1px solid var(--color-blue-bg);\n    display: flex;\n    flex-direction: column;\n    padding: 0 12px;\n    &.root {\n      border: 0;\n      padding: 0;\n    }\n  }\n  .doc-node-body {\n    background: var(--color-blue-bg);\n    color: var(--color-black);\n    display: flex;\n    font-size: 13px;\n    margin-top: 3px;\n  }\n  .number-box {\n    padding: 3px 6px;\n    background: rgba($color-white, 0.3);\n  }\n  button {\n    background: transparent;\n    border: 0;\n    color: var(--color-black);\n    cursor: pointer;\n    display: flex;\n    height: 100%;\n    padding: 3px 9px;\n    white-space: pre;\n    width: 100%;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: var(--color-white);\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n    }\n  }\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n  .inline-children {\n    border-left: 1px solid var(--color-purple);\n    border-right: 1px solid var(--color-purple);\n    display: flex;\n    flex-wrap: wrap;\n    padding: 0 12px;\n    /* TODO this hurts my soul */\n    & > :global(.doc-node) {\n      flex-grow: 1;\n      padding: 0;\n    }\n  }\n</style>\n","import { Schema } from 'prosemirror-model'\n\nconst nodeColors = <const>[\n  '#EA7C7F', // red\n  '#67B0C6', // cyan 400\n  '#94BB7F', // green\n  '#CA9EDB', // deep purple\n  '#DCDC5D', // lime\n  '#B9CC7C', // light green\n  '#DD97D8', // purple\n  '#FFB761', // orange\n  '#4D8FD1', // light blue\n  '#F36E98', // pink\n  '#E45F44', // deep orange\n  '#A6A4AE', // blue grey\n  '#FCC047', // yellow\n  '#FFC129', // amber\n  '#D3929C', // can can\n  '#4CBCD4', // cyan\n  '#8D7BC0' // indigo\n]\n\nexport function calculateSafeIndex(index: number, total: number) {\n  const quotient = index / total\n  return Math.round(total * (quotient - Math.floor(quotient)))\n}\n\nexport function buildColors(schema: Schema) {\n  return Object.keys(schema.nodes).reduce((acc, node, index) => {\n    const safeIndex =\n      index >= nodeColors.length ? calculateSafeIndex(index, nodeColors.length) : index\n\n    acc[node] = nodeColors[safeIndex]\n    return acc\n  }, {} as { [key: string]: typeof nodeColors[number] })\n}\n","<script lang=\"ts\">\n  import { setContext } from '$context'\n  import type { Node as PMNode, Schema } from 'prosemirror-model'\n\n  import DocNode from './DocNode.svelte'\n  import { buildColors } from './colors'\n\n  export let doc: PMNode,\n    schema: Schema,\n    selected = { type: '', start: 0, end: 0 },\n    handleNodeSelect: (n: PMNode) => void\n\n  setContext('doc-view', {\n    selected,\n    colors: buildColors(schema),\n    handleNodeClick: handleNodeSelect\n  })\n</script>\n\n<ul>\n  <DocNode class={$$props.class} node={doc} startPos={0} depth={0} isRoot />\n</ul>\n\n<style>\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n</style>\n","<script lang=\"ts\">\n  import type { Node as PMNode, Schema } from 'prosemirror-model'\n  import { getContext } from '$context'\n  import { latestEntry } from '$stores/stateHistory'\n\n  import TreeView from 'svelte-tree-view'\n  import SplitView from '../SplitView.svelte'\n  import DocView from './DocView.svelte'\n  import Button from '$components/Button.svelte'\n\n  const { view } = getContext('editor-view')\n  let doc: PMNode = view.state.doc\n  let selectedNode = view.state.doc\n  $: jsonNode = selectedNode.toJSON()\n  let schema: Schema = view.state.schema\n  let timer: number | undefined\n\n  latestEntry.subscribe(e => {\n    if (!e) return\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      doc = e.state.doc\n    }, 100)\n  })\n\n  function handleNodeSelect(n: PMNode) {\n    selectedNode = n\n  }\n  function handleClickLogNode() {\n    console.log(selectedNode)\n    window._node = selectedNode\n    console.info('%c [prosemirror-dev-toolkit]: Property added to window._node', 'color: #b8e248')\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <div class=\"top-row\">\n      <h2>Current doc</h2>\n      <Button class=\"hidden\">log</Button>\n    </div>\n    <DocView class=\"m-top\" {doc} {schema} {handleNodeSelect} />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    <div class=\"top-row\">\n      <h2>Node info</h2>\n      <Button on:click={handleClickLogNode}>log</Button>\n    </div>\n    <TreeView class=\"m-top\" data={jsonNode} />\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    flex-grow: 0;\n    min-width: 220px;\n    width: 220px;\n  }\n  :global(.split-view .m-top) {\n    margin-top: 0.5em;\n  }\n</style>\n","<script lang=\"ts\">\n  import type { Snapshot } from '$typings/snapshots'\n\n  export let snapshots: Snapshot[] = [],\n    selectedSnapshot: Snapshot | undefined = undefined,\n    onUpdate: (snap: Snapshot) => void,\n    onView: (snap?: Snapshot) => void,\n    onRestore: (snap: Snapshot) => void,\n    onExport: (snap: Snapshot) => void,\n    onDelete: (snap: Snapshot) => void\n\n  let editedSnap: Snapshot | undefined\n  let deleteSnap: Snapshot | undefined\n  let timer: number | undefined\n\n  const debounceUpdate = () => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      onUpdate(editedSnap as Snapshot)\n    }, 150)\n  }\n\n  function handleSnapDoubleclick(snap: Snapshot) {\n    editedSnap = snap\n    deleteSnap = undefined\n  }\n  function handleNameChange(evt: any) {\n    if (editedSnap) {\n      editedSnap.name = evt.target.value\n      debounceUpdate()\n    }\n  }\n  function handleNameKeyPress(evt: any) {\n    if (evt.key === 'Enter' && editedSnap) {\n      onUpdate(editedSnap)\n      clearTimeout(timer)\n      editedSnap = undefined\n      deleteSnap = undefined\n    }\n  }\n  function handleClickView(snap: Snapshot) {\n    if (selectedSnapshot?.timestamp === snap.timestamp) {\n      onView()\n    } else {\n      onView(snap)\n    }\n    deleteSnap = undefined\n  }\n  function handleRestoreClick(snap: Snapshot) {\n    onRestore(snap)\n    deleteSnap = undefined\n  }\n  function handleExportClick(snap: Snapshot) {\n    onExport(snap)\n    deleteSnap = undefined\n  }\n  function handleClickDelete(snap: Snapshot) {\n    if (!deleteSnap || deleteSnap.timestamp !== snap.timestamp) {\n      deleteSnap = snap\n    } else {\n      onDelete(snap)\n      deleteSnap = undefined\n    }\n  }\n</script>\n\n<ul>\n  {#each snapshots as snap}\n    <li>\n      {#if editedSnap && editedSnap.timestamp === snap.timestamp}\n        <input\n          value={editedSnap.name}\n          on:input={handleNameChange}\n          on:keypress={handleNameKeyPress}\n        />\n      {:else}\n        <button\n          class=\"unstyled-btn\"\n          aria-label=\"Edit snapshot name button\"\n          on:dblclick={() => handleSnapDoubleclick(snap)}>{snap.name}</button\n        >\n      {/if}\n      <button class=\"snapshot-btn ml-2\" on:click={() => handleClickView(snap)}>\n        {#if selectedSnapshot?.timestamp === snap.timestamp}\n          Hide\n        {:else}\n          Show\n        {/if}\n      </button>\n      <button class=\"snapshot-btn\" on:click={() => handleRestoreClick(snap)}>Restore</button>\n      <button class=\"snapshot-btn\" on:click={() => handleExportClick(snap)}>Export</button>\n      <button class=\"snapshot-btn\" on:click={() => handleClickDelete(snap)}>\n        {#if deleteSnap?.timestamp === snap.timestamp}\n          Confirm Delete\n        {:else}\n          Delete\n        {/if}\n      </button>\n    </li>\n  {/each}\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    color: var(--color-white);\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n    width: 100%;\n  }\n  li + li {\n    border-top: 1px solid var(--color-purple);\n  }\n  li {\n    align-items: center;\n    display: flex;\n    font-family: monospace;\n    padding: 6px 18px;\n    & > div {\n      align-items: center;\n      display: flex;\n      flex-grow: 1;\n    }\n  }\n  input {\n    background: transparent;\n    border: 0;\n    color: var(--color-white);\n    height: 100%;\n    margin: 0;\n    padding: 2px;\n    width: 100%;\n  }\n  .unstyled-btn {\n    background: transparent;\n    border: 0;\n    color: var(--color-white);\n    cursor: pointer;\n    display: block;\n    font-family: monospace;\n    margin: 0;\n    padding: 0;\n    text-align: start;\n    width: 100%;\n  }\n  .snapshot-btn {\n    background: transparent;\n    border: 0;\n    border-radius: 3px;\n    color: var(--color-gray-light);\n    cursor: pointer;\n    display: flex;\n    font-size: 11px;\n    padding: 6px 18px;\n    text-transform: uppercase;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: var(--color-white);\n    }\n  }\n  .ml-2 {\n    margin-left: 1rem;\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n\n  import SplitView from '$tabs/SplitView.svelte'\n  import SnapshotsList from './SnapshotsList.svelte'\n  import {\n    snapshots,\n    selectedSnapshot,\n    updateSnapshot,\n    toggleViewSnapshot,\n    restoreSnapshot,\n    exportSnapshot,\n    deleteSnapshot\n  } from '$stores/snapshots'\n  import { resetHistory } from '$stores/stateHistory'\n  import type { Snapshot } from '$typings/snapshots'\n\n  const { view } = getContext('editor-view')\n\n  function handleRestoreSnapshot(snapshot: Snapshot) {\n    restoreSnapshot(view, snapshot)\n    resetHistory()\n  }\n</script>\n\n<SplitView>\n  <div slot=\"right\" class=\"right-panel\">\n    {#if $snapshots.length === 0}\n      <div class=\"no-snapshots\">Save snapshots by clicking \"Save snapshot\" button.</div>\n    {:else}\n      <SnapshotsList\n        snapshots={$snapshots}\n        selectedSnapshot={$selectedSnapshot}\n        onUpdate={updateSnapshot}\n        onView={snap => toggleViewSnapshot(view, snap)}\n        onRestore={handleRestoreSnapshot}\n        onExport={exportSnapshot}\n        onDelete={deleteSnapshot}\n      />\n    {/if}\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .right-panel {\n    padding: 0;\n  }\n  .no-snapshots {\n    align-items: center;\n    color: var(--color-red-light);\n    display: flex;\n    font-size: 14px;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n  }\n</style>\n","<script lang=\"ts\">\n  import { onDestroy } from 'svelte'\n  import { getContext } from '$context'\n\n  import { saveSnapshot, importSnapshot } from '$stores/snapshots'\n\n  import TabsMenu from '$tabs/TabsMenu.svelte'\n  import StateTab from '$tabs/state/StateTab.svelte'\n  import HistoryTab from '$tabs/history/HistoryTab.svelte'\n  import PluginsTab from '$tabs/PluginsTab.svelte'\n  import SchemaTab from '$tabs/SchemaTab.svelte'\n  import StructureTab from '$tabs/structure/StructureTab.svelte'\n  import SnapshotsTab from '$tabs/snapshots/SnapshotsTab.svelte'\n\n  export let onClose: () => void\n\n  const { view } = getContext('editor-view')\n  let openTab = 'state',\n    dockTop = 50,\n    dockHeight = 50,\n    fileinput: HTMLInputElement\n\n  onDestroy(() => {\n    document.removeEventListener('mousemove', dragMove)\n    document.removeEventListener('mouseup', dragEnd)\n  })\n\n  function handleResizeMouseDown(e: any) {\n    document.addEventListener('mousemove', dragMove)\n    document.addEventListener('mouseup', dragEnd)\n  }\n  function dragMove(evt: MouseEvent) {\n    evt.preventDefault()\n    dockTop = (100 * evt.clientY) / window.innerHeight\n    dockHeight = 100 * (1 - evt.clientY / window.innerHeight)\n  }\n  function dragEnd(evt: MouseEvent) {\n    evt.preventDefault()\n    document.removeEventListener('mousemove', dragMove)\n    document.removeEventListener('mouseup', dragEnd)\n  }\n  function handleSaveSnapshot() {\n    const defaultName = new Date().toLocaleString('sv')\n    const snapshotName = prompt('Enter snapshot name', defaultName)\n    if (snapshotName) {\n      saveSnapshot(snapshotName, view.state.doc.toJSON())\n    }\n  }\n  function handleImportSnapshot() {\n    fileinput.click()\n  }\n  function handleFileSelected(\n    e: Event & {\n      currentTarget: EventTarget & HTMLInputElement\n    }\n  ) {\n    const target = <HTMLInputElement>e.target\n    Array.from(target.files || []).forEach(file => {\n      const reader = new FileReader()\n      reader.readAsText(file)\n      reader.onload = e => {\n        const data = typeof e.target?.result === 'string' ? e.target?.result : ''\n        try {\n          const json = JSON.parse(data)\n          if (!json || typeof json !== 'object') {\n            throw Error('Imported snapshot was not a JSON object' + json)\n          }\n          const name = file.name.slice(0, file.name.lastIndexOf('.'))\n          importSnapshot(name, json, view.state.schema)\n        } catch (err) {\n          console.error('Failed to import snapshot: ' + err)\n        }\n      }\n    })\n  }\n  function handleClickTab(tab: string) {\n    openTab = tab\n  }\n</script>\n\n<div class=\"floating-dock-wrapper\">\n  <div class=\"floating-dock\" style={`top: ${dockTop}%; height: ${dockHeight}%;`}>\n    <div class=\"resizing-div\" on:mousedown={handleResizeMouseDown} />\n    <div class=\"container\">\n      <div>\n        <button class=\"snap-save-btn\" on:click={handleSaveSnapshot}>Save snapshot</button>\n        <button class=\"snap-import-btn\" on:click={handleImportSnapshot}>Import snapshot</button>\n        <button class=\"close-btn\" aria-label=\"Close dev-toolkit button\" on:click={onClose}>X</button\n        >\n      </div>\n      <input\n        style=\"display:none\"\n        type=\"file\"\n        accept=\".json\"\n        multiple\n        on:change={handleFileSelected}\n        bind:this={fileinput}\n      />\n      <TabsMenu onClickTab={handleClickTab} active={openTab} />\n      {#if openTab === 'state'}\n        <StateTab />\n      {:else if openTab === 'history'}\n        <HistoryTab />\n      {:else if openTab === 'plugins'}\n        <PluginsTab />\n      {:else if openTab === 'schema'}\n        <SchemaTab />\n      {:else if openTab === 'structure'}\n        <StructureTab />\n      {:else if openTab === 'snapshots'}\n        <SnapshotsTab />\n      {:else}\n        <p>nuting here</p>\n      {/if}\n    </div>\n  </div>\n</div>\n\n<style lang=\"scss\">\n  .floating-dock-wrapper {\n    position: fixed;\n    width: 0px;\n    height: 0px;\n    top: 0px;\n    left: 0px;\n    z-index: 99999999;\n  }\n  .floating-dock {\n    background-color: var(--color-blue-bg);\n    position: fixed;\n    z-index: 1;\n    box-shadow: rgba($color-black, 0.3) 0px 0px 4px 0px;\n    left: 0px;\n    top: 50%;\n    width: 100%;\n    height: 50%;\n  }\n  .resizing-div {\n    position: absolute;\n    z-index: 2;\n    opacity: 0;\n    top: -5px;\n    height: 10px;\n    left: 0px;\n    width: 100%;\n    cursor: row-resize;\n  }\n  .container {\n    height: 100%;\n  }\n  .snap-save-btn {\n    background: rgba($color-red-light, 0.6);\n    border: 0;\n    border-radius: 3px;\n    color: var(--color-white);\n    cursor: pointer;\n    font-size: 12px;\n    height: 24px;\n    line-height: 25px;\n    padding: 0 6px;\n    position: absolute;\n    right: 134px;\n    top: -28px;\n    &:hover {\n      background: rgba($color-red-light, 0.8);\n    }\n  }\n  .snap-import-btn {\n    background: rgba($color-red-light, 0.6);\n    border: 0;\n    border-radius: 3px;\n    color: var(--color-white);\n    cursor: pointer;\n    font-size: 12px;\n    height: 24px;\n    line-height: 25px;\n    padding: 0 6px;\n    position: absolute;\n    right: 32px;\n    top: -28px;\n    &:hover {\n      background: rgba($color-red-light, 0.8);\n    }\n  }\n  .close-btn {\n    background: rgba($color-red-light, 0.6);\n    border: 0;\n    border-radius: 3px;\n    color: var(--color-white);\n    cursor: pointer;\n    height: 24px;\n    position: absolute;\n    right: 4px;\n    top: -28px;\n    width: 24px;\n    &:hover {\n      background: rgba($color-red-light, 0.8);\n    }\n  }\n</style>\n","<script lang=\"ts\">\n  import { onMount } from 'svelte'\n  import type { EditorView } from 'prosemirror-view'\n  import { setContext } from '$context'\n\n  import FloatingBtn from './FloatingBtn.svelte'\n  import FloatingDock from './FloatingDock.svelte'\n\n  import type { ButtonPosition } from '../types'\n\n  export let view: EditorView,\n    devToolsExpanded = false,\n    buttonPosition: ButtonPosition = 'bottom-right'\n\n  setContext('editor-view', {\n    view\n  })\n\n  onMount(() => {\n    const html = document && document.querySelector('html')\n    if (devToolsExpanded && html) {\n      html.style.marginBottom = '341px'\n    }\n  })\n\n  function handleFloatingBtnClick() {\n    devToolsExpanded = true\n    const html = document && document.querySelector('html')\n    if (html) {\n      html.style.marginBottom = '341px'\n    }\n  }\n  function handleFloatingDockClose() {\n    devToolsExpanded = false\n    const html = document && document.querySelector('html')\n    if (html) {\n      html.style.marginBottom = ''\n    }\n  }\n</script>\n\n<section>\n  {#if devToolsExpanded}\n    <FloatingDock onClose={handleFloatingDockClose} />\n  {:else}\n    <FloatingBtn on:click={handleFloatingBtnClick} {buttonPosition} />\n  {/if}\n</section>\n\n<style lang=\"scss\">\n  * {\n    --font-sans: Helvetica Neue, Calibri Light, Roboto, sans-serif;\n    --font-small: 11px;\n    --font-medium: 13px;\n    --font-large: 16px;\n    --height-tabs-menu: 48px;\n    --color-black: #222;\n    --color-blue-bg: #363755;\n    --color-blue-light: #85d9ef;\n    /* --color-green-text: #b8e248; */\n    --color-gray-light: #d3d3d9;\n    --color-green: green; // diff inserted\n    --color-green-light: #87cc86; // diff deleted color\n    --color-purple-dark: rgb(80, 68, 93); // list darker bg\n    --color-purple: rgb(96, 76, 104); // borders in eg lists\n    --color-purple-light: rgb(99, 99, 123); // list text color\n    --color-red: #d66363; // diff deleted\n    --color-red-gray: rgb(187, 145, 163); // h2 color\n    --color-red-light: rgb(255, 162, 177);\n    --color-yellow: #eaea37; // diff updated\n    --color-white: #fff;\n  }\n  :root {\n    --tree-view-base00: #363755;\n    --tree-view-base01: #604d49;\n    --tree-view-base02: #6d5a55;\n    --tree-view-base03: #d1929b;\n    --tree-view-base04: #b79f8d;\n    --tree-view-base05: #f9f8f2;\n    --tree-view-base06: #f7f4f1;\n    --tree-view-base07: #faf8f5;\n    --tree-view-base08: #fa3e7e;\n    --tree-view-base09: #fd993c;\n    --tree-view-base0A: #f6bf81;\n    --tree-view-base0B: #b8e248;\n    --tree-view-base0C: #b4efe4;\n    --tree-view-base0D: #85d9ef;\n    --tree-view-base0E: #be87ff;\n    --tree-view-base0F: #d6724c;\n  }\n  section {\n    font-family: var(--font-sans);\n    font-size: var(--font-medium);\n  }\n</style>\n","import type { EditorView } from 'prosemirror-view'\nimport type { Transaction } from 'prosemirror-state'\n\nimport { appendNewHistoryEntry } from '$stores/stateHistory'\n\nlet active = false, resetDispatch: (() => void) | undefined = undefined\n\nexport function subscribeToDispatchTransaction(view: EditorView) : Promise<void> {\n  active = true\n  // Use timeout to make sure other hooks don't interfere with our patching of dispatchTransaction\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resetDispatch && resetDispatch()\n      const oldDispatchFn = (view.someProp('dispatchTransaction') || view.dispatch).bind(view)\n      view.setProps({\n        dispatchTransaction: (tr: Transaction) => {\n          const stateBeforeDispatch = view.state\n          oldDispatchFn(tr)\n          if (active) {\n            appendNewHistoryEntry(tr, view.state, stateBeforeDispatch)\n          }\n        }\n      })\n      resetDispatch = () => view.setProps({ dispatchTransaction: oldDispatchFn })\n      resolve()\n    }, 1)\n  })\n}\n\nexport function unsubscribeDispatchTransaction() {\n  active = false\n  resetDispatch && resetDispatch()\n  resetDispatch = undefined\n}\n","import type { Transaction } from 'prosemirror-state'\nimport type { EditorView } from 'prosemirror-view'\nimport DevTools from './components/DevTools.svelte'\nimport {\n  subscribeToDispatchTransaction,\n  unsubscribeDispatchTransaction\n} from './history-and-diff/subscribeToTransactions'\nimport { resetHistory } from './stores/stateHistory'\n\nimport { DevToolsOpts } from './types'\nimport type { Plugin } from './typings/pm'\n\ndeclare global {\n  interface Window {\n    applyDevTools: typeof applyDevTools\n    editorView?: EditorView\n    _node?: any\n    _doc?: { [key: string]: any }\n    _tr?: Transaction\n    _plugin?: [Plugin | undefined, unknown]\n  }\n}\n\nconst DEVTOOLS_CLASS_NAME = '__prosemirror-dev-toolkit__'\n\ntry {\n  // Make the dev tools available globally for some scripting shenanigans\n  if (typeof window !== 'undefined') window.applyDevTools = applyDevTools\n} catch (err) {}\n\nfunction createOrFindPlace() {\n  let place: HTMLElement | null = document.querySelector(`.${DEVTOOLS_CLASS_NAME}`)\n\n  if (!place) {\n    place = document.createElement('div')\n    place.className = DEVTOOLS_CLASS_NAME\n    document.body.appendChild(place)\n  }\n\n  return place\n}\n\nlet removeCallback: (() => void) | undefined\n\nexport function applyDevTools(view: EditorView, opts: DevToolsOpts = {}) {\n  const place = createOrFindPlace()\n\n  removeDevTools()\n\n  const comp = new DevTools({\n    target: place,\n    props: {\n      view,\n      ...opts\n    }\n  })\n  try {\n    // Make the editor view available since it might be handy for quick debugging\n    if (typeof window !== 'undefined') window.editorView = view\n  } catch (err) {}\n\n  // Bind the component's life-cycle to the editorView to automatically unmount the devTools\n  const oldDestroyFn = view.destroy.bind(view)\n  view.destroy = () => {\n    // DevTools must always be removed before view as the resetDispatch requires view to be still present\n    removeDevTools()\n    oldDestroyFn()\n  }\n\n  removeCallback = () => {\n    resetHistory()\n    unsubscribeDispatchTransaction()\n    // TODO add test to check no \"Component already destroyed\" warnings appear\n    comp.$destroy()\n  }\n  return subscribeToDispatchTransaction(view)\n}\n\nexport function removeDevTools() {\n  removeCallback && removeCallback()\n  removeCallback = undefined\n}\n"],"sourceRoot":""}