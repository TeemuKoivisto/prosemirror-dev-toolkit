{"version":3,"sources":["components/NavBar.tsx","components/WrappedRoute.tsx","pm/schema.ts","pm/example-plugin/types.ts","pm/example-plugin/index.ts","pm/example-plugin/findChangedNodes.ts","pm/PMEditor.tsx","components/Editor.tsx","pages/FrontPage.tsx","pages/DevToolsPage.tsx","routes.tsx","index.tsx","../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../../../node_modules/@babel/runtime/helpers/typeof.js","../../../node_modules/svelte/internal/index.mjs","../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../../../node_modules/@babel/runtime/helpers/esm/typeof.js","../../src/context.ts","../../../node_modules/style-inject/dist/style-inject.es.js","../../src/components/FloatingBtn.svelte","../../../node_modules/svelte/store/index.mjs","../../src/stores/snapshots.ts","../../src/tabs/TabsMenu.svelte","../../../node_modules/prosemirror-model/dist/index.es.js","../../../node_modules/html/lib/html.js","../../../node_modules/jsondiffpatch/dist/jsondiffpatch.umd.js","../../src/history-and-diff/diff.ts","../../src/history-and-diff/transaction.ts","../../src/history-and-diff/createHistoryEntry.ts","../../src/stores/stateHistory.ts","../../src/tabs/state/selection.ts","../../../node_modules/svelte-tree-view/package/tree-utils.js","../../../node_modules/svelte-tree-view/package/TreeViewNode.svelte","../../../node_modules/svelte-tree-view/package/TreeView.svelte","../../../node_modules/svelte-tree-view/package/stores/props.js","../../../node_modules/svelte-tree-view/package/stores/root-element.js","../../../node_modules/svelte-tree-view/package/stores/tree.js","../../src/tabs/SplitView.svelte","../../src/components/Button.svelte","../../src/tabs/state/StateTab.svelte","../../src/tabs/state/getActiveMarks.ts","../../src/tabs/history/mapDeltas.ts","../../src/tabs/history/HistoryList.svelte","../../src/tabs/history/DiffValue.svelte","../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../src/tabs/history/HistoryTab.svelte","../../src/tabs/List.svelte","../../src/tabs/PluginsTab.svelte","../../src/tabs/SchemaTab.svelte","../../src/tabs/structure/DocNode.svelte","../../src/tabs/structure/colors.ts","../../src/tabs/structure/DocView.svelte","../../src/tabs/structure/StructureTab.svelte","../../src/tabs/snapshots/SnapshotsList.svelte","../../src/tabs/snapshots/SnapshotsTab.svelte","../../src/components/FloatingDock.svelte","../../src/components/DevTools.svelte","../../src/history-and-diff/subscribeToTransactions.ts","../../src/index.ts"],"names":["NavBar","props","className","Container","Nav","Link","to","exact","activeClassName","styled","div","nav","NavLink","WrappedRoute","Component","component","rest","render","MainWrapper","MainContainer","main","schema","Schema","nodes","doc","content","paragraph","group","parseDOM","tag","toDOM","blockquote","defining","horizontal_rule","heading","attrs","level","default","node","code_block","marks","code","preserveWhitespace","text","image","inline","src","alt","title","draggable","getAttrs","p","dom","getAttribute","hard_break","selectable","link","href","inclusive","italic","style","bold","fontWeight","test","DummyClass","values","a","examplePluginKey","PluginKey","joinStates","s1","s2","changedNodesMap","Map","entries","forEach","val","key","set","changedNodesTypesSet","Set","add","tr","examplePlugin","Plugin","state","init","config","instance","decorationSet","DecorationSet","empty","exampleMap","exampleSet","document","createElement","exampleClasses","trackedTrs","joined","apply","value","oldState","newState","oldDoc","nodesMap","typesSet","steps","step","from","slice","sliceSize","size","isInsert","isReplace","operation","nodesBetween","n","pos","has","type","descendants","findAddedOrRemovedNodes","getMeta","decorations","this","getState","PMEditor","editorViewRef","useRef","editorRef","dispatchTransaction","transaction","current","editorState","updateState","onEdit","useLayoutEffect","EditorState","create","plugins","exampleSetup","concat","editorViewDOM","element","EditorView","mount","createEditorView","onEditorReady","destroy","id","ref","EditorStore","view","currentEditorState","localStorageKey","setEditorView","fromJSON","syncCurrentEditorState","toJSON","localStorage","setItem","JSON","stringify","window","existing","getItem","length","stored","parse","Editor","useDevTools","editorStore","useMemo","debouncedSync","debounce","applyDevTools","applyDevToolkit","devToolsExpanded","buttonPosition","FrontPage","DevToolsPage","Routes","basename","process","path","getElementById","_classCallCheck","Constructor","TypeError","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","o","Object","_inherits","subClass","superClass","constructor","writable","configurable","setPrototypeOf","Symbol","module","_typeof","obj","_possibleConstructorReturn","call","assertThisInitialized","_getPrototypeOf","_arrayLikeToArray","arr","len","i","arr2","Array","_unsupportedIterableToArray","minLen","arrayLikeToArray","_slicedToArray","arrayWithHoles","_i","_arr","_n","_d","_s","err","_e","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","_toConsumableArray","arrayWithoutHoles","iter","iterableToArray","nonIterableSpread","_defineProperties","target","descriptor","noop","assign","tar","run","fn","blank_object","run_all","fns","is_function","thing","safe_not_equal","b","subscribe","store","callbacks","unsub","get_store_value","_","component_subscribe","callback","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","get_slot_changes","dirty","lets","merged","Math","update_slot_base","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","get_all_dirty_from_scope","exclude_internal_props","result","k","compute_rest_props","keys","null_to_empty","append","insert","anchor","detach","destroy_each","iterations","detaching","name","svg_element","data","space","listen","event","handler","options","attr","attribute","set_attributes","attributes","descriptors","xlink_attr","children","set_data","toggle_class","toggle","set_current_component","current_component","get_current_component","Error","onMount","bubble","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","update_scheduled","add_render_callback","flushing","seen_callbacks","flush","update","$$","outroing","group_outros","outros","r","c","check_outros","transition_in","block","local","transition_out","create_component","mount_component","customElement","fragment","on_mount","on_destroy","after_update","new_on_destroy","destroy_component","make_dirty","create_fragment","not_equal","append_styles","parent_component","bound","on_disconnect","before_update","context","skip_bound","root","ready","ret","SvelteComponent","protoProps","staticProps","index","$$set","setContext","setCtx","getContext","getCtx","styleInject","css","insertAt","head","subscriber_queue","start","subscribers","run_queue","subscriber","invalidate","stop","derived","stores","initial_value","single","stores_array","auto","inited","pending","cleanup","sync","unsubscribers","SNAPSHOTS_KEY","snapshots","selectedSnapshot","previousEditorState","persisted","parsed","console","error","setEditorDoc","getPrototypeOf","nodeFromJSON","updateSnapshot","snapshot","map","s","timestamp","exportSnapshot","file","Blob","URL","createObjectURL","download","click","deleteSnapshot","filter","selected","get","undefined","active","onClickTab","findDiffStart","childA","childB","j","inner","findDiffEnd","posA","posB","iA","iB","same","minSize","Fragment","prototypeAccessors","firstChild","lastChild","childCount","f","nodeStart","child","end","separated","leafText","other","last","first","copy","eq","found","RangeError","otherPos","round","retIndex","curPos","join","array","fromArray","offset","compareDeep","p$1","Mark","ReplaceError","message","placed","excludes","json","Slice","openStart","openEnd","prototypeAccessors$1","removeRange","ref$1","indexTo","offsetTo","insertInto","dist","parent","replace","$from","$to","replaceOuter","depth","$along","extra","prepareSliceForReplace","close","replaceThreeWay","replaceTwoWay","checkJoin","sub","joinable","$before","$after","addNode","addRange","$start","$end","startIndex","endIndex","openIsolating","n$1","ResolvedPos","parentOffset","prototypeAccessors$2","textOffset","nodeAfter","nodeBefore","resolveDepth","dOff","cut","tmp","after","maybeChild","next","d","inlineContent","pred","NodeRange","str","rem","resolveCache","cached","resolveCachePos","resolveCacheSize","prototypeAccessors$1$1","before","indexAfter","emptyAttrs","Node","prototypeAccessors$3","nodeSize","textContent","isBlock","isTextblock","isInline","isText","isLeaf","isAtom","startPos","textBetween","blockSeparator","sameMarkup","hasMarkup","includeParents","resolve","findIndex","spec","toDebugString","wrapMarks","match","contentMatch","matchFragment","replacement","one","contentMatchAt","two","allowsMarks","matchType","canReplace","compatibleContent","validContent","toString","addToSet","m","ContentMatch","validEnd","prototypeAccessors$4","defaultType","edgeCount","stream","TokenStream","string","expr","parseExpr","nfa","labeled","explore","nullFrom","out","states","term","known","states$1","dfa","connect","compile","edge","edges","loop","loop$1","cur","i$1","next$1","i$2","next$2","work","dead","checkForDeadEnds","frag","toEnd","seen","finished","types","tp","search","wrapCache","computed","computeWrapping","via","scan","nodeTypes","tokens","prototypeAccessors$1$2","exprs","parseExprSeq","parseExprSubscript","type$1","resolveName","parseExprAtom","parseExprRange","parseNum","Number","min","max","cmp","tok","SyntaxError","NodeType","Attribute","initAttrs","defaults","defaultAttrs","prototypeAccessors$5","compatible","built","given","computeAttrs","fillBefore","markSet","indexOf","markType","allowsMarkType","topType","prototypeAccessors$1$3","isRequired","blockTags","address","article","aside","canvas","dd","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","output","pre","section","table","tfoot","ul","ignoreTags","object","script","listTags","wsOptionsFor","NodeContext","pendingMarks","solid","fill","wrap","findWrapping","exec","stashMarks","mark","splice","markMayApply","ParseContext","parser","open","topNode","topOptions","topContext","prototypeAccessors$6","top","currentPos","nodeType","v","returned","readStyles","re","parseStyles","domNodeBefore","prevItem","normalizeList","rule","ruleFromNode","ruleID","matchTag","oldNeedsBlock","styles","matchStyle","this$1","insertNode","enter","startIn","continueAfter","contentDOM","cx","route","findPlace","ok","preserveWS","finish","isOpen","find","textNode","parts","option","useRoot","minDepth","part","$context","deflt","findSameMarkInSet","stashMark","DOMSerializer","gatherToDOM","keep","rendered","markDOM","serializeNodeInner","serializeMark","xmlNS","structure","tagName","space$1","innerContent","nodesFromSchema","marksFromSchema","html","prettyPrint","html_source","indent_size","indent_character","brace_style","max_char","unformatted","multi_parser","parentcount","parent1","last_token","last_text","token_type","whitespace","split","single_token","extra_liners","in_array","what","input_char","input","charAt","Utils","line_char_count","reg_match","RegExp","reg_array","end_script","substring","tags","temp_parent","get_unformatted","tag_start","tag_complete","tag_index","tag_check","comment","tag_end","delimiter","orig_tag","substr","token","get_contents_to","current_mode","indent_level","js_source","ignore","t","tag_name","tag_extracted_from_last_output","_beautifier","js_beautify","css_beautify","script_indent_level","indentation","_level","white","reindent","exports","chalk","_typeof2","classCallCheck","createClass","defineProperties","property","receiver","Function","desc","getter","inherits","enumerable","possibleConstructorReturn","slicedToArray","sliceIterator","toConsumableArray","Processor","_options","pipeArg","pipe","pipes","nextPipe","lastPipe","lastContext","Pipe","debug","filters","msg","_filters","_filters2","filterName","params","should","Context","isArray","regexMatch","arg","Date","cloneRegExp","cloned","clone","DiffContext","_Context","_this","cloneDiffValues","clone$$1","PatchContext","ReverseContext","isArray$1","diffFilter","patchFilter","regexArgs","reverseFilter","propertyFilter","collectChildrenDiffFilter","objectsDiffFilter","patchFilter$1","collectChildrenPatchFilter","reverseFilter$1","delta","collectChildrenReverseFilter","defaultMatch","array1","array2","index1","index2","lengthMatrix","len1","len2","x","y","matrix","backtrack","subsequence","sequence","indices1","indices2","lcs","innerContext","ARRAY_MOVE","isArray$2","arrayIndexOf","item","val1","val2","value1","value2","objectHash","hash1","hash2","diffFilter$1","matchContext","matchByPosition","commonHead","commonTail","arraysHaveMatchByRef","matchItems","trimmed1","trimmed2","seq","removedItems","_t","detectMove","includeValueOnMove","removedItemsLength","indexOnArray2","isMove","removeItemIndex1","compare","numerically","numericallyBy","patchFilter$2","toRemove","toInsert","toModify","parseInt","indexDiff","removedValue","toInsertLength","insertion","toModifyLength","modification","collectChildrenPatchFilter$1","reverseFilter$2","reverseArrayDeltaIndex","itemDelta","reverseIndex","deltaItem","moveFromIndex","deltaIndex","moveToIndex","collectChildrenReverseFilter$1","diffFilter$2","diffMatchPatch","createCommonjsModule","DIFF_DELETE","DIFF_INSERT","DIFF_EQUAL","diff_match_patch","opt_deadline","Diff_Timeout","deadline","text1","text2","opt_checklines","checklines","commonlength","diff_commonPrefix","commonprefix","diff_commonSuffix","commonsuffix","diffs","diff_compute_","longtext","shorttext","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diff_main","diffs_b","diff_lineMode_","diff_bisect_","diff_linesToChars_","linearray","pointer","count_delete","count_insert","text_delete","text_insert","text1_length","text2_length","max_d","v_offset","v_length","v1","v2","front","k1start","k1end","k2start","k2end","k1","k1_offset","y1","x1","k2_offset","x2","diff_bisectSplit_","k2","y2","text1a","text2a","text1b","text2b","diffsb","lineArray","lineHash","chars","lineStart","lineEnd","lineArrayLength","line","String","chars1","diff_linesToCharsMunge_","chars2","pointermin","pointermax","pointermid","pointerstart","pointerend","text_length","best","pattern","dmp","seed","best_common","prefixLength","suffixLength","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","hm1","diff_halfMatchI_","hm2","changes","equalities","equalitiesLength","lastequality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","deletion","overlap_length1","diff_commonOverlap_","overlap_length2","char1","char2","nonAlphaNumeric1","nonAlphaNumeric2","whitespace1","whitespace2","lineBreak1","lineBreak2","blankLine1","blankLine2","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","diff_cleanupSemanticScore_","score","pre_ins","pre_del","post_ins","post_del","Diff_EditCost","last_chars1","last_chars2","loc","pattern_amp","pattern_lt","pattern_gt","pattern_para","op","levenshtein","insertions","deletions","encodeURI","diffsLength","param","decodeURI","ex","isNaN","match_bitap_","match_alphabet_","accuracy","e","proximity","score_threshold","best_loc","match_bitapScore_","matchmask","bin_max","bin_min","bin_mid","rd","charMatch","last_rd","patch","padding","Match_MaxBits","prefix","suffix","opt_b","opt_c","diff_text1","patches","patchDiffLength","char_count1","char_count2","prepatch_text","postpatch_text","diff_type","diff_text","patchesCopy","patchCopy","patch_deepCopy","nullPadding","patch_addPadding","results","expected_loc","end_loc","start_loc","match_main","diff_text2","diff_levenshtein","mod","diff_xIndex","paddingLength","extraLength","patch_size","bigpatch","start1","start2","precontext","postcontext","textline","textPointer","patchHeader","sign","length1","coords1","length2","coords2","TEXT_DIFF","DEFAULT_MIN_LENGTH","cachedDiffPatch","getDiffMatchPatch","required","diff","txt1","txt2","_patch","_error","diffFilter$3","minLength","diffMatchPatch$$1","patchFilter$3","textDeltaReverse","l","lines","lineTmp","headerRegex","reverseFilter$3","DiffPatcher","_processor","left","right","processor","reverse","isArray$3","getObjectKeys","names","trimUnderscore","arrayKeyToSortNumber","arrayKeyComparer","key1","key2","BaseFormatter","finalize","_buffer","deltaType","_ref","buffer","leftKey","movedFrom","isLast","leftValue","getDeltaType","typeFormattterNotFound","typeFormattter","arrayKeys","moveDestinations","includeMoveDestinations","lineOutput","pieces","location","chr","pieceIndex","piecesLength","piece","pieceOutput","base","HtmlFormatter","_BaseFormatter","htmlEscape","parseTextDiff","nodeClass","adjustArrows","replacements","nodeArg","getElementText","innerText","eachChildren","_ref2","el","query","elems","eachByQuery","_ref3","parentNode","arrowParent","svg","destination","container","destinationElem","distance","curve","showUnchanged","show","delay","classes","showing","hiding","visible","hidden","list","setTimeout","intervalId","setInterval","clearInterval","hideUnchanged","defaultInstance","format","AnnotatedFormatter","levels","indentLevel","htmlNote","wrapPropertyName","deltaAnnotations","added","formatLegend","modified","deleted","moved","textdiff","formatAnyChange","annotator","defaultInstance$1","annotated","format$1","OPERATIONS","remove","move","JSONFormatter","currentPath","toPath","sortBy","compareByIndexDesc","indexA","indexB","lastA","lastB","opsByDescendingOrder","removeOps","splitA","splitB","partitionOps","initArr","position","acc","isMoveOp","isRemoveOp","_ref4","reorderOps","_partitionOps","_partitionOps2","moveOps","removedOps","restOps","removeOpsReverse","defaultInstance$2","format$2","log","jsonpatch","_len","arguments","args","_key","colors","chalkColor","movedestination","unchanged","textDiffLine","ConsoleFormatter","indentPad","_len2","_key2","color","defaultInstance$3","format$3","console$1","log$1","defaultInstance$4","factory","diffPatcher","arrays","textDiff","inputA","inputB","addedProperties","addPropertiesToTransaction","reduce","buildSelection","selection","pad","num","formatTimestamp","date","getHours","getMinutes","getSeconds","getMilliseconds","regexp","highlightHtmlString","stateHistory","shownHistoryGroups","latestEntry","appendNewHistoryEntry","stateBeforeDispatch","entryMap","prevGroup","newEntry","oldEntry","serializer","fromSchema","domFragment","serializeFragment","selectedElementsAsHtml","push","outerHTML","nextSibling","prevState","contentDiff","selectionDiff","random","time","timeStr","selectionHtml","createHistoryEntry","topEntryId","isGroup","newGroup","entryIds","expanded","resetHistory","defaultProperties","resolvedPosProperties","resolvedPosSubProperties","createSelection","createFullSelection","includes","additionalProperties","subKey","createNode","collapsed","getValueType","parentId","circularOfId","recurseObjectProperties","ensureNotCollapsed","treeMap","oldTreeMap","iteratedValues","recomputeExpandNode","opts","_a","oldNode","existingNodeWithValue","shouldRecurseChildren","mappedChildren","getChildren","idx","showLogButton","showCopyButton","treeStore","propsStore","rootElementStore","$","hasChildren","valueComponent","$props","navigator","$rootElementStore","theme","recursionOpts","valueFormatter","rootElement","defaultRecursionOpts","maxDepth","omitKeys","stopCircularRecursion","shouldExpandNode","initialProps","setProps","formatValue","customFormat","createPropsStore","createRootElementStore","defaultRootNode","tree","getNode","toggleCollapse","updatedNode","expandNodeChildren","newTreeMap","previouslyIterated","nodeWithUpdatedChildren","expandAllNodesToNode","updated","recurseNodeUpwards","createTreeStore","newRecursionOpts","recomputeTree","rootNode","updates","to_null_out","accounted_for","formatDocNodeValue","storedMarks","$head","$anchor","activeMarks","mapSelectionDeltaChildren","_val","_parent","mapDocDeltaChildren","transformed","listItems","onSelect","subEntry","getValueString","delete","DiffValue","mapChildren","nodeColors","buildColors","safeIndex","total","quotient","floor","calculateSafeIndex","class","handleSnapDoubleclick","snap","handleClickView","handleRestoreClick","handleExportClick","handleClickDelete","toggleViewSnapshot","important","snapshotName","now","fileinput","resetDispatch","subscribeToDispatchTransaction","oldDispatchFn","someProp","dispatch","bind","unsubscribeDispatchTransaction","removeCallback","DEVTOOLS_CLASS_NAME","createOrFindPlace","place","querySelector","body","appendChild","removeDevTools","comp","DevTools","editorView","oldDestroyFn","$destroy"],"mappings":"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","file":"static/js/main.05f23826.chunk.js","sourcesContent":["import React from 'react'\nimport { NavLink } from 'react-router-dom'\nimport styled from 'styled-components'\n\nimport { RouteComponentProps } from 'react-router'\n\ninterface IProps extends RouteComponentProps<{}> {\n  className?: string\n}\n\nexport function NavBar(props: IProps) {\n  const { className } = props\n  return (\n    <Container className={className}>\n      <Nav>\n        <Link to=\"/\" exact activeClassName=\"current\">Front page</Link>\n        <Link to=\"/dev-tools\" exact activeClassName=\"current\">Dev tools</Link>\n      </Nav>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n  background: var(--color-primary);\n  box-shadow: 0 0 2px 2px rgba(0,0,0,0.18);\n  padding: 1rem;\n`\nconst Nav = styled.nav`\n  align-items: center;\n  color: #fff;\n  display: flex;\n`\nconst Link = styled(NavLink)`\n  box-sizing: border-box;\n  color: #fff;\n  cursor: pointer;\n  font-size: 1rem;\n  padding: 0.5rem 1rem;\n  text-decoration: none;\n  transition: 0.2s hover;\n  &:hover {\n    text-decoration: underline;\n  }\n  &.current {\n    font-weight: 600;\n  }\n`\n","import * as React from 'react'\nimport { Route, RouteProps, RouteComponentProps } from 'react-router'\nimport styled from 'styled-components'\n\nimport { NavBar } from './NavBar'\n\ntype ReactComponent = React.ComponentClass<any> | React.StatelessComponent<any>\n\ninterface IWrappedRoute extends RouteProps {\n  component: ReactComponent\n}\n\nconst renderNoMainContainerWrapper = (Component: ReactComponent) => (props: RouteComponentProps<any>) =>\n  <MainWrapper>\n    <NavBar {...props}/>\n    <Component {...props}/>\n  </MainWrapper>\n\nconst renderWrapper = (Component: ReactComponent) => (props: RouteComponentProps<any>) =>\n  <MainWrapper>\n    <NavBar {...props}/>\n    <MainContainer>\n      <Component {...props}/>\n    </MainContainer>\n  </MainWrapper>\n\nexport const NoMainContainerRoute = ({ component, ...rest } : IWrappedRoute) =>\n  <Route {...rest} render={renderNoMainContainerWrapper(component)}/>\n\nexport const WrappedRoute = ({ component, ...rest } : IWrappedRoute) =>\n  <Route {...rest} render={renderWrapper(component)}/>\n\nconst MainWrapper = styled.div`\n  min-height: 100vh;\n`\nconst MainContainer = styled.main`\n  margin: 40px auto 0 auto;\n  max-width: 680px;\n  padding-bottom: 20px;\n  @media only screen and (max-width: 720px) {\n    margin: 40px 20px 0 20px;\n    padding-bottom: 20px;\n  }\n`\n","import { Schema } from 'prosemirror-model'\nimport { ExampleSchema, Nodes, Marks } from './schema-types'\n\nexport const schema: ExampleSchema = new Schema<Nodes, Marks>({\n  nodes: {\n    // :: NodeSpec The top level document node.\n    doc: {\n      content: 'block+',\n    },\n\n    // :: NodeSpec A plain paragraph textblock. Represented in the DOM\n    // as a `<p>` element.\n    paragraph: {\n      content: 'inline*',\n      group: 'block',\n      parseDOM: [{ tag: 'p' }],\n      toDOM() {\n        return ['p', 0]\n      },\n    },\n\n    // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.\n    blockquote: {\n      content: 'block+',\n      group: 'block',\n      defining: true,\n      parseDOM: [{ tag: 'blockquote' }],\n      toDOM() {\n        return ['blockquote', 0]\n      },\n    },\n\n    // :: NodeSpec A horizontal rule (`<hr>`).\n    horizontal_rule: {\n      group: 'block',\n      parseDOM: [{ tag: 'hr' }],\n      toDOM() {\n        return ['hr']\n      },\n    },\n\n    // :: NodeSpec A heading textblock, with a `level` attribute that\n    // should hold the number 1 to 6. Parsed and serialized as `<h1>` to\n    // `<h6>` elements.\n    heading: {\n      attrs: { level: { default: 1 } },\n      content: 'inline*',\n      group: 'block',\n      defining: true,\n      parseDOM: [\n        { tag: 'h1', attrs: { level: 1 } },\n        { tag: 'h2', attrs: { level: 2 } },\n        { tag: 'h3', attrs: { level: 3 } },\n        { tag: 'h4', attrs: { level: 4 } },\n        { tag: 'h5', attrs: { level: 5 } },\n        { tag: 'h6', attrs: { level: 6 } },\n      ],\n      toDOM(node) {\n        return ['h' + node.attrs.level, 0]\n      },\n    },\n\n    // :: NodeSpec A code listing. Disallows marks or non-text inline\n    // nodes by default. Represented as a `<pre>` element with a\n    // `<code>` element inside of it.\n    code_block: {\n      content: 'text*',\n      marks: '',\n      group: 'block',\n      code: true,\n      defining: true,\n      parseDOM: [{ tag: 'pre', preserveWhitespace: 'full' }],\n      toDOM() {\n        return ['pre', ['code', 0]]\n      },\n    },\n\n    // :: NodeSpec The text node.\n    text: {\n      group: 'inline',\n    },\n\n    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,\n    // `alt`, and `href` attributes. The latter two default to the empty\n    // string.\n    image: {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: { default: null },\n        title: { default: null },\n      },\n      group: 'inline',\n      draggable: true,\n      parseDOM: [\n        {\n          tag: 'img[src]',\n          getAttrs(p) {\n            const dom = p as HTMLElement\n            return {\n              src: dom.getAttribute('src'),\n              title: dom.getAttribute('title'),\n              alt: dom.getAttribute('alt'),\n            }\n          },\n        },\n      ],\n      toDOM(node) {\n        const { src, alt, title } = node.attrs\n        return ['img', { src, alt, title }]\n      },\n    },\n\n    // :: NodeSpec A hard line break, represented in the DOM as `<br>`.\n    hard_break: {\n      inline: true,\n      group: 'inline',\n      selectable: false,\n      parseDOM: [{ tag: 'br' }],\n      toDOM() {\n        return ['br']\n      },\n    },\n  },\n  marks: {\n    // :: MarkSpec A link. Has `href` and `title` attributes. `title`\n    // defaults to the empty string. Rendered and parsed as an `<a>`\n    // element.\n    link: {\n      attrs: {\n        href: {},\n        title: { default: null },\n      },\n      inclusive: false,\n      parseDOM: [\n        {\n          tag: 'a[href]',\n          getAttrs(p) {\n            const dom = p as HTMLElement\n            return {\n              href: dom.getAttribute('href'),\n              title: dom.getAttribute('title'),\n            }\n          },\n        },\n      ],\n      toDOM(node) {\n        const { href, title } = node.attrs\n        return ['a', { href, title }, 0]\n      },\n    },\n\n    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.\n    // Has parse rules that also match `<i>` and `font-style: italic`.\n    italic: {\n      parseDOM: [{ tag: 'i' }, { tag: 'em' }, { style: 'font-style=italic' }],\n      toDOM() {\n        return ['em', 0]\n      },\n    },\n\n    // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules\n    // also match `<b>` and `font-weight: bold`.\n    bold: {\n      parseDOM: [\n        { tag: 'strong' },\n        // This works around a Google Docs misbehavior where\n        // pasted content will be inexplicably wrapped in `<b>`\n        // tags with a font-weight normal.\n        {\n          tag: 'b',\n          getAttrs: (p) => {\n            const node = p as HTMLElement\n            return node.style.fontWeight !== 'normal' && null\n          },\n        },\n        {\n          style: 'font-weight',\n          getAttrs: (p) => {\n            const value = p as string\n            return /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n          },\n        },\n      ],\n      toDOM() {\n        return ['strong', 0]\n      },\n    },\n\n    // :: MarkSpec Code font mark. Represented as a `<code>` element.\n    code: {\n      parseDOM: [{ tag: 'code' }],\n      toDOM() {\n        return ['code', 0]\n      },\n    },\n  },\n})\n","import { DecorationSet } from 'prosemirror-view'\nimport { Transaction } from 'prosemirror-state'\nimport { Node as PMNode, NodeType } from 'prosemirror-model'\n\nexport type Operation = 'insert' | 'replace' | 'delete'\n\nexport class DummyClass {\n  values: any[] = [{ 1: [1,2,3]}, {a: 'hello'}, 1]\n}\nexport interface TrackedNodes {\n  tr: Transaction\n  changedNodesMap: Map<PMNode, { pos: number; operation: Operation }>\n  changedNodesTypesSet: Set<NodeType>\n}\nexport interface PluginState {\n  decorationSet: DecorationSet\n  exampleMap: Map<any, any>\n  exampleSet: Set<HTMLElement>\n  exampleClasses: DummyClass[]\n  trackedTrs: TrackedNodes[]\n  joined: TrackedNodes\n}\n","import { Plugin, PluginKey } from 'prosemirror-state'\nimport { DecorationSet } from 'prosemirror-view'\n\nimport { ExampleSchema } from '../schema-types'\n\nimport { findAddedOrRemovedNodes } from './findChangedNodes'\n\nimport { DummyClass } from './types'\nimport type { TrackedNodes, PluginState } from './types'\n\nexport const examplePluginKey = new PluginKey<PluginState, ExampleSchema>('example-plugin')\n\nfunction joinStates(s1: TrackedNodes, s2: TrackedNodes) {\n  const changedNodesMap = new Map(s1.changedNodesMap.entries())\n  s2.changedNodesMap.forEach((val, key) => changedNodesMap.set(key, val))\n  const changedNodesTypesSet = new Set(s1.changedNodesTypesSet.values())\n  s2.changedNodesTypesSet.forEach((val) => changedNodesTypesSet.add(val))\n  return {\n    tr: s2.tr,\n    changedNodesMap,\n    changedNodesTypesSet,\n  }\n}\n\nexport const examplePlugin = () =>\n  new Plugin({\n    key: examplePluginKey,\n    state: {\n      init(config, instance): PluginState {\n        return {\n          decorationSet: DecorationSet.empty,\n          // @ts-ignore\n          exampleMap: new Map([['a', 1], ['b', { 'x': [1,2] }]]),\n          exampleSet: new Set([document.createElement('div'), document.createElement('span')]),\n          exampleClasses: [new DummyClass(), new DummyClass()],\n          trackedTrs: [],\n          joined: {\n            tr: instance.tr,\n            changedNodesMap: new Map(),\n            changedNodesTypesSet: new Set(),\n          },\n        }\n      },\n      apply(tr, value, oldState, newState): PluginState {\n        const state = findAddedOrRemovedNodes(tr, oldState.doc)\n        if (tr.getMeta('appendedTransaction')) {\n          return {\n            ...value,\n            trackedTrs: [...value.trackedTrs, state],\n            joined: joinStates(value.joined, state),\n          }\n        }\n        return {\n          ...value,\n          trackedTrs: [state],\n          joined: state,\n        }\n      },\n    },\n    props: {\n      decorations(state) {\n        return this.getState(state).decorationSet\n      },\n    },\n  })\n","import { Transaction } from 'prosemirror-state'\nimport { Node as PMNode, NodeType, Slice } from 'prosemirror-model'\nimport { Step } from 'prosemirror-transform'\n\nimport type { Operation, TrackedNodes } from './types'\n\nexport const findAddedOrRemovedNodes = (\n  tr: Transaction,\n  oldDoc: PMNode\n): TrackedNodes => {\n  const nodesMap: Map<PMNode, { pos: number; operation: Operation }> = new Map()\n  const typesSet: Set<NodeType> = new Set()\n  const steps = (tr.steps || []) as (Step & {\n    from: number\n    to: number\n    slice: Slice\n  })[]\n  steps.forEach((step) => {\n    const { to, from, slice } = step\n    const sliceSize = slice.size || 0\n    const isInsert = from === to\n    const isReplace = !isInsert && sliceSize !== 0\n    const isDelete = !isInsert && sliceSize === 0\n    const operation = isInsert ? 'insert' : isReplace ? 'replace' : 'delete'\n    if (isReplace || isDelete) {\n      // go through the nodes inside from to\n      oldDoc.nodesBetween(from, to, (n, pos) => {\n        if (!nodesMap.has(n)) {\n          nodesMap.set(n, { pos, operation })\n          typesSet.add(n.type)\n          return true\n        }\n      })\n    }\n    if (isInsert || isReplace) {\n      // go through the nodes inside slice\n      slice.content.descendants((n, pos) => {\n        nodesMap.set(n, { pos, operation })\n        typesSet.add(n.type)\n      })\n    }\n  })\n  return {\n    tr,\n    changedNodesMap: nodesMap,\n    changedNodesTypesSet: typesSet,\n  }\n}\n","import React, { useLayoutEffect, useRef } from 'react'\nimport { EditorView } from 'prosemirror-view'\nimport { EditorState, Transaction } from 'prosemirror-state'\nimport { exampleSetup } from 'prosemirror-example-setup'\n\nimport { schema } from './schema'\nimport { examplePlugin } from './example-plugin'\n\nimport './editor.css'\nimport './prosemirror-example-setup.css'\nimport './menu.css'\n\ninterface EditorProps {\n  className?: string\n  onEditorReady?: (view: EditorView) => void\n  onEdit?: (state: EditorState) => void\n}\n\nexport function PMEditor(props: EditorProps) {\n  const { className = '' } = props\n  const editorViewRef = useRef(null)\n  const editorRef = useRef<EditorView | null>(null)\n\n  useLayoutEffect(() => {\n    const state = createEditorState()\n    const editorViewDOM = editorViewRef.current\n    if (editorViewDOM) {\n      editorRef.current = createEditorView(editorViewDOM, state)\n      props.onEditorReady && props?.onEditorReady(editorRef.current)\n    }\n    return () => {\n      editorRef.current?.destroy()\n    }\n  // eslint-disable-next-line\n  }, [])\n\n  function createEditorState() {\n    return EditorState.create({\n      schema,\n      plugins: exampleSetup({ schema }).concat(examplePlugin()),\n    })\n  }\n\n  function createEditorView(element: HTMLDivElement, state: EditorState) {\n    const view = new EditorView({ mount: element }, {\n      state,\n      dispatchTransaction,\n    })\n    return view\n  }\n\n  function dispatchTransaction(transaction: Transaction) {\n    if (!editorRef.current) {\n      return\n    }\n    const editorState = editorRef.current.state.apply(transaction)\n    editorRef.current.updateState(editorState)\n    if (props.onEdit) {\n      props.onEdit(editorState)\n    }\n  }\n\n  return (\n    <div id=\"example-editor\" ref={editorViewRef} className={className}/>\n  )\n}\n","import React, { useMemo } from 'react'\nimport debounce from 'lodash.debounce'\n\nimport { EditorView } from 'prosemirror-view'\nimport { EditorState } from 'prosemirror-state'\nimport { applyDevTools as applyDevToolkit } from 'prosemirror-dev-toolkit'\nimport { applyDevTools } from 'prosemirror-dev-tools'\n\nimport { PMEditor } from 'pm/PMEditor'\n\nclass EditorStore {\n\n  view?: EditorView\n  currentEditorState?: {[key: string]: any}\n  localStorageKey: string\n\n  constructor(key: string) {\n    this.localStorageKey = key\n    if (typeof window !== 'undefined') {\n      const existing = localStorage.getItem(this.localStorageKey)\n      if (existing && existing !== null && existing.length > 0) {\n        let stored = JSON.parse(existing)\n        this.currentEditorState = stored\n      }\n    }\n  }\n\n  setEditorView = (view: EditorView) => {\n    this.view = view\n    if (this.currentEditorState) {\n      const state = EditorState.fromJSON(\n        {\n          schema: this.view.state.schema,\n          plugins: this.view.state.plugins,\n        },\n        this.currentEditorState\n      )\n      this.view.updateState(state)\n    }\n  }\n\n  syncCurrentEditorState = () => {\n    const newState = this.view!.state.toJSON()\n    localStorage.setItem(this.localStorageKey, JSON.stringify(newState))\n  }\n}\n\ninterface Props {\n  useDevTools?: boolean\n}\n\nexport function Editor(props: Props) {\n  const { useDevTools } = props\n  const editorStore = useMemo(() => new EditorStore(useDevTools ? 'dev-tools' : 'dev-toolkit'), [useDevTools])\n  const debouncedSync = useMemo(() => debounce(editorStore.syncCurrentEditorState, 250), [editorStore.syncCurrentEditorState])\n\n  function handleEdit() {\n    debouncedSync()\n  }\n  function handleEditorReady(view: EditorView) {\n    editorStore.setEditorView(view)\n    if (useDevTools) {\n      applyDevTools(view)\n    } else {\n      applyDevToolkit(view, {\n        devToolsExpanded: true,\n        buttonPosition: 'bottom-left',\n      })\n    }\n  }\n  return (\n    <PMEditor\n      onEdit={handleEdit}\n      onEditorReady={handleEditorReady}\n    />\n  )\n}\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport { Editor } from '../components/Editor'\n\nexport function FrontPage() {\n  return (\n    <Container>\n      <header>\n        <h1><a href=\"https://github.com/TeemuKoivisto/prosemirror-dev-toolkit\">prosemirror-dev-toolkit</a></h1>\n        <p>Github repo</p>\n        <p>An example React app with ProseMirror editor that uses dev-toolkit.</p>\n      </header>\n      <Editor/>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n\n`\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport { Editor } from '../components/Editor'\n\nexport function DevToolsPage() {\n  return (\n    <Container>\n      <header>\n        <h1><a href=\"https://github.com/d4rkr00t/prosemirror-dev-tools\">Original prosemirror-dev-tools</a></h1>\n        <p><a href=\"https://github.com/d4rkr00t/prosemirror-dev-tools\">Github repo</a></p>\n      </header>\n      <Editor useDevTools/>\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n\n`\n","import * as React from 'react'\nimport { BrowserRouter, Redirect, Switch } from 'react-router-dom'\n\nimport { WrappedRoute } from './components/WrappedRoute'\n\nimport { FrontPage } from './pages/FrontPage'\nimport { DevToolsPage } from './pages/DevToolsPage'\n\nexport const Routes = () => (\n  <BrowserRouter basename={process.env.PUBLIC_URL}>\n    <Switch>\n      <WrappedRoute exact path=\"/\" component={FrontPage}/>\n      <WrappedRoute exact path=\"/dev-tools\" component={DevToolsPage}/>\n      <Redirect to=\"/\" />\n    </Switch>\n  </BrowserRouter>\n)\n","import * as React from 'react'\nimport { render } from 'react-dom'\n\nimport { Routes } from './routes'\n\nimport './index.css'\n\nrender(\n  <Routes />,\n  document.getElementById('root')\n)\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.0' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","import _typeof from \"@babel/runtime/helpers/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import { EditorView } from 'prosemirror-view'\nimport type { Node as PMNode } from 'prosemirror-model'\nimport { getContext as getCtx, setContext as setCtx } from 'svelte'\n\nimport { buildColors } from './tabs/structure/colors'\n\nexport type Contexts = {\n  'editor-view': {\n    view: EditorView\n  }\n  'doc-view': {\n    selected: {\n      type: string\n      start: number\n      end: number\n    }\n    colors: ReturnType<typeof buildColors>\n    handleNodeClick: (n: PMNode) => void\n  }\n}\n\nexport const setContext = <K extends keyof Contexts & string>(ctx: K, val: Contexts[K]) =>\n  setCtx(ctx, val)\n\nexport const getContext = <K extends keyof Contexts & string>(ctx: K) => getCtx(ctx) as Contexts[K]\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","<script lang=\"ts\">\n  import type { ButtonPosition } from '../types'\n\n  export let buttonPosition: ButtonPosition\n</script>\n\n<button class={`floating-btn ${buttonPosition}`} on:click>\n  <svg\n    width=\"530\"\n    height=\"530\"\n    viewBox=\"0 0 530 530\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n  >\n    <title>prosemirror</title>\n    <desc>Created using Figma</desc>\n    <use xlink:href=\"#a\" transform=\"matrix(2 0 0 2 118 116)\" fill=\"#FFF\" />\n    <use xlink:href=\"#b\" transform=\"rotate(16 59.054 420.192) scale(2)\" fill=\"#FFF\" />\n    <use xlink:href=\"#c\" transform=\"matrix(2 0 0 2 154.024 141.58)\" fill=\"#363755\" />\n    <use xlink:href=\"#d\" transform=\"matrix(2 0 0 2 220 334.8)\" fill=\"#FFF\" />\n    <use xlink:href=\"#e\" transform=\"matrix(2 0 0 2 218.826 262.052)\" fill=\"#363755\" />\n    <use xlink:href=\"#f\" transform=\"matrix(2 0 0 2 197.108 184.998)\" fill=\"#FFF\" />\n    <use xlink:href=\"#g\" transform=\"matrix(2 0 0 2 221.8 216)\" fill=\"#363755\" />\n    <defs>\n      <path\n        id=\"a\"\n        d=\"M73.5 0C32.859 0 0 32.859 0 73.5S32.859 147 73.5 147 147 114.141 147 73.5 114.069 0 73.5\n        0z\"\n      />\n      <path\n        id=\"b\"\n        d=\"M193.601 107.116c0-13.376 8.238-23.91\n        20.619-31.153-2.244-7.447-5.19-14.6-8.824-21.32-13.886\n        3.633-25.12-1.799-34.568-11.26-9.449-9.437-12.344-20.672-8.709-34.571A111.362 111.362 0 0 0\n        140.799 0c-7.243 12.37-20.339 20.594-33.689 20.594-13.363\n        0-26.446-8.225-33.701-20.594A110.888 110.888 0 0 0 52.1 8.812c3.634 13.9.753 25.134-8.721\n        34.57-9.436 9.462-20.67 14.894-34.569 11.26A112.178 112.178 0 0 0 0 75.963c12.369 7.243\n        20.593 17.777 20.593 31.153 0 13.352-8.224 26.448-20.593 33.704a113.338 113.338 0 0 0 8.811\n        21.321c13.899-3.634 25.133-.752 34.569 8.697 9.448 9.462 12.355 20.696 8.721 34.57a112.653\n        112.653 0 0 0 21.32 8.837c7.243-12.407 20.338-20.619 33.702-20.619 13.35 0 26.446 8.225\n        33.701 20.619a114.22 114.22 0 0 0 21.32-8.837c-3.634-13.874-.752-25.108 8.709-34.57\n        9.449-9.437 20.683-14.869 34.569-11.26a112.343 112.343 0 0 0\n        8.823-21.321c-12.406-7.256-20.644-17.789-20.644-31.141zm-86.491 46.57c-25.732\n        0-46.58-20.849-46.58-46.57 0-25.733 20.86-46.595 46.58-46.595 25.732 0 46.567 20.875 46.567\n        46.595 0 25.734-20.835 46.57-46.567 46.57z\"\n      />\n      <path\n        id=\"c\"\n        d=\"M98.088 49.91c-6.9 83.9 10.8 103.401 10.8 103.401s-55.1\n        5.499-82.7-13.401c-30.5-20.9-26-67.5-25.9-94.6.1-28.4 25.6-45.8 49.9-45.3 29.1.5 50.2 21.6\n        47.9 49.9z\"\n      />\n      <path\n        id=\"d\"\n        d=\"M.1.1c12.2 33.3 22.5 42.7 40 55.2 25.3 18 36.6 17.5 76.3 41C78.1 60.3 30.8 45.7 0 0l.1.1z\"\n      />\n      <path\n        id=\"e\"\n        d=\"M.687 36.474c3 13.3 17.9 29.9 30.4 41.6 24.8 23.2 42 22.4 86\n        54.7-18.2-51.8-18.8-62-43.5-106.1-24.7-44-67.6-20.3-67.6-20.3s-8.4 16.6-5.3 29.9v.2z\"\n      />\n      <path\n        id=\"f\"\n        d=\"M38.346 11.5s-4-11.6-18-11.5c-30 .2-28.8 52.1 16.9 52 39.6-.1 39.2-49.4\n        16.1-49.6-10.2-.2-15 9.1-15 9.1z\"\n      />\n      <path\n        id=\"g\"\n        d=\"M26.5 15c10.8 0 2 14.9-.6 20.9-1.8-8.4-10.2-20.9.6-20.9zM10.2.1C4.6.1 0 4.6 0 10.3c0 5.6\n        4.5 10.2 10.2 10.2 5.6 0 10.2-4.5 10.2-10.2C20.4 4.7 15.9.1 10.2.1zM40.7 0c-4.8 0-8.8\n        4.5-8.8 10.2 0 5.6 3.9 10.2 8.8 10.2 4.8 0 8.8-4.5 8.8-10.2C49.5 4.6 45.6 0 40.7 0z\"\n      />\n    </defs>\n  </svg>\n</button>\n\n<style lang=\"scss\">\n  .floating-btn {\n    background: var(--color-blue-bg);\n    border: 0;\n    border-radius: 50%;\n    box-shadow: 0 0 30px rgba($color-black, 0.3);\n    cursor: pointer;\n    position: fixed;\n    padding: 6px;\n    transition: opacity 0.3s;\n    -webkit-transition: opacity 0.3s;\n    z-index: 99999;\n  }\n  .floating-btn.bottom-right {\n    bottom: 16px;\n    right: 16px;\n  }\n  .floating-btn.bottom-left {\n    bottom: 16px;\n    left: 16px;\n  }\n  .floating-btn.top-right {\n    top: 16px;\n    right: 16px;\n  }\n  .floating-btn.top-left {\n    top: 16px;\n    left: 16px;\n  }\n  .floating-btn:hover {\n    opacity: 0.7;\n  }\n  .floating-btn > svg {\n    display: block;\n    width: 34px;\n    height: 34px;\n    position: relative;\n  }\n</style>\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import type { EditorView } from 'prosemirror-view'\nimport type { EditorState } from 'prosemirror-state'\nimport { get, writable } from 'svelte/store'\n\nimport type { Snapshot } from '$typings/snapshots'\nimport { Schema } from 'prosemirror-model'\n\nconst SNAPSHOTS_KEY = '__prosemirror-dev-toolkit__snapshots'\n\nexport const snapshots = writable<Snapshot[]>([])\nexport const selectedSnapshot = writable<Snapshot | undefined>()\nexport const previousEditorState = writable<EditorState | undefined>()\n\nconst persisted = typeof window !== 'undefined' ? localStorage.getItem(SNAPSHOTS_KEY) : null\nif (persisted && persisted.length > 0) {\n  try {\n    const parsed = JSON.parse(persisted)\n    snapshots.set(parsed)\n  } catch (err) {\n    console.error('Corrupted snapshots values in localStorage', err)\n  }\n}\n\nsnapshots.subscribe(val => {\n  if (typeof window !== 'undefined') {\n    localStorage.setItem(SNAPSHOTS_KEY, JSON.stringify(val))\n  }\n})\n\nfunction setEditorDoc(view: EditorView, doc: { [key: string]: any }) {\n  // Hack to use EditorState.create without explicitly calling EditorState, thus\n  // avoiding having to include it as a dependency\n  const newState = Object.getPrototypeOf(view.state).constructor.create({\n    schema: view.state.schema,\n    plugins: view.state.plugins,\n    doc: view.state.schema.nodeFromJSON(doc)\n  })\n  view.updateState(newState)\n}\n\nexport function saveSnapshot(snapshotName: string, doc: { [key: string]: any }) {\n  const snap: Snapshot = {\n    name: snapshotName,\n    timestamp: Date.now(),\n    doc\n  }\n  snapshots.update(val => [snap, ...val])\n}\n\nexport function importSnapshot(\n  snapshotName: string,\n  json: { [key: string]: unknown },\n  schema: Schema\n) {\n  const doc = schema.nodeFromJSON(json)\n  const snap: Snapshot = {\n    name: snapshotName,\n    timestamp: Date.now(),\n    doc: doc.toJSON()\n  }\n  snapshots.update(val => [snap, ...val])\n}\n\nexport function updateSnapshot(snapshot: Snapshot) {\n  snapshots.update(val =>\n    val.map(s => {\n      if (s.timestamp === snapshot.timestamp) {\n        return snapshot\n      }\n      return s\n    })\n  )\n}\n\nexport function toggleViewSnapshot(view: EditorView, snap?: Snapshot) {\n  if (snap) {\n    const prevState = get(previousEditorState)\n    if (!prevState) previousEditorState.set(view.state)\n    setEditorDoc(view, snap.doc)\n  } else {\n    const prevState = get(previousEditorState)\n    if (!prevState) {\n      console.error('No previous state to restore!')\n    } else {\n      view.updateState(prevState)\n    }\n    previousEditorState.set(undefined)\n  }\n  selectedSnapshot.set(snap)\n}\n\nexport function restoreSnapshot(view: EditorView, snap: Snapshot) {\n  setEditorDoc(view, snap.doc)\n  previousEditorState.set(undefined)\n  selectedSnapshot.set(undefined)\n}\n\nexport function exportSnapshot(snapshot: Snapshot) {\n  const a = document.createElement('a')\n  const file = new Blob([JSON.stringify(snapshot.doc)], { type: 'application/json' })\n  a.href = URL.createObjectURL(file)\n  a.download = `${snapshot.name}.json`\n  a.click()\n}\n\nexport function deleteSnapshot(snapshot: Snapshot) {\n  snapshots.update(val => val.filter(s => s.timestamp !== snapshot.timestamp))\n  const selected = get(selectedSnapshot)\n  if (selected?.timestamp === snapshot.timestamp) {\n    selectedSnapshot.set(undefined)\n  }\n}\n","<script lang=\"ts\">\n  export let active: string, onClickTab: (tab: string) => void\n</script>\n\n<ul class=\"tabs-menu\">\n  <li>\n    <button class:active={active === 'state'} on:click={() => onClickTab('state')}>STATE</button>\n  </li>\n  <li>\n    <button class:active={active === 'history'} on:click={() => onClickTab('history')}\n      >HISTORY</button\n    >\n  </li>\n  <li>\n    <button class:active={active === 'plugins'} on:click={() => onClickTab('plugins')}\n      >PLUGINS</button\n    >\n  </li>\n  <li>\n    <button class:active={active === 'schema'} on:click={() => onClickTab('schema')}>SCHEMA</button>\n  </li>\n  <li>\n    <button class:active={active === 'structure'} on:click={() => onClickTab('structure')}\n      >STRUCTURE</button\n    >\n  </li>\n  <li>\n    <button class:active={active === 'snapshots'} on:click={() => onClickTab('snapshots')}\n      >SNAPSHOTS</button\n    >\n  </li>\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    display: flex;\n    list-style: none;\n    margin: 0;\n    overflow-x: scroll;\n    padding: 0;\n  }\n  button {\n    background: transparent;\n    border: 0;\n    border-bottom: 2px solid transparent;\n    color: var(--color-white);\n    cursor: pointer;\n    height: 100%;\n    padding: 1em;\n    &:hover {\n      background: rgba($color-white, 0.05);\n    }\n    &.active {\n      border-bottom: 2px solid var(--color-red-light);\n    }\n  }\n</style>\n","import OrderedMap from 'orderedmap';\n\nfunction findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      { return a.childCount == b.childCount ? null : pos }\n\n    var childA = a.child(i), childB = b.child(i);\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) { return pos }\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++)\n        { pos++; }\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) { return inner }\n    }\n    pos += childA.nodeSize;\n  }\n}\n\nfunction findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      { return iA == iB ? null : {a: posA, b: posB} }\n\n    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size; posB -= size;\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--;\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) { return inner }\n    }\n    posA -= size; posB -= size;\n  }\n}\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nvar Fragment = function Fragment(content, size) {\n  this.content = content;\n  // :: number\n  // The size of the fragment, which is the total of the size of its\n  // content nodes.\n  this.size = size || 0;\n  if (size == null) { for (var i = 0; i < content.length; i++)\n    { this.size += content[i].nodeSize; } }\n};\n\nvar prototypeAccessors = { firstChild: { configurable: true },lastChild: { configurable: true },childCount: { configurable: true } };\n\n// :: (number, number, (node: Node, start: number, parent: Node, index: number)  ?bool, ?number)\n// Invoke a callback for all descendant nodes between the given two\n// positions (relative to start of this fragment). Doesn't descend\n// into a node when the callback returns `false`.\nFragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {\n    if ( nodeStart === void 0 ) nodeStart = 0;\n\n  for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n      var start = pos + 1;\n      child.nodesBetween(Math.max(0, from - start),\n                         Math.min(child.content.size, to - start),\n                         f, nodeStart + start);\n    }\n    pos = end;\n  }\n};\n\n// :: ((node: Node, pos: number, parent: Node)  ?bool)\n// Call the given callback for every descendant node. The callback\n// may return `false` to prevent traversal of a given node's children.\nFragment.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.size, f);\n};\n\n// :: (number, number, ?string, ?string | ?(leafNode: Node) -> string)  string\n// Extract the text between `from` and `to`. See the same method on\n// [`Node`](#model.Node.textBetween).\nFragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  var text = \"\", separated = true;\n  this.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += typeof leafText === 'function' ? leafText(node): leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text\n};\n\n// :: (Fragment)  Fragment\n// Create a new fragment containing the combined content of this\n// fragment and the other.\nFragment.prototype.append = function append (other) {\n  if (!other.size) { return this }\n  if (!this.size) { return other }\n  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n  if (last.isText && last.sameMarkup(first)) {\n    content[content.length - 1] = last.withText(last.text + first.text);\n    i = 1;\n  }\n  for (; i < other.content.length; i++) { content.push(other.content[i]); }\n  return new Fragment(content, this.size + other.size)\n};\n\n// :: (number, ?number)  Fragment\n// Cut out the sub-fragment between the two given positions.\nFragment.prototype.cut = function cut (from, to) {\n  if (to == null) { to = this.size; }\n  if (from == 0 && to == this.size) { return this }\n  var result = [], size = 0;\n  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from) {\n      if (pos < from || end > to) {\n        if (child.isText)\n          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }\n        else\n          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }\n      }\n      result.push(child);\n      size += child.nodeSize;\n    }\n    pos = end;\n  } }\n  return new Fragment(result, size)\n};\n\nFragment.prototype.cutByIndex = function cutByIndex (from, to) {\n  if (from == to) { return Fragment.empty }\n  if (from == 0 && to == this.content.length) { return this }\n  return new Fragment(this.content.slice(from, to))\n};\n\n// :: (number, Node)  Fragment\n// Create a new fragment in which the node at the given index is\n// replaced by the given node.\nFragment.prototype.replaceChild = function replaceChild (index, node) {\n  var current = this.content[index];\n  if (current == node) { return this }\n  var copy = this.content.slice();\n  var size = this.size + node.nodeSize - current.nodeSize;\n  copy[index] = node;\n  return new Fragment(copy, size)\n};\n\n// : (Node)  Fragment\n// Create a new fragment by prepending the given node to this\n// fragment.\nFragment.prototype.addToStart = function addToStart (node) {\n  return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n};\n\n// : (Node)  Fragment\n// Create a new fragment by appending the given node to this\n// fragment.\nFragment.prototype.addToEnd = function addToEnd (node) {\n  return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n};\n\n// :: (Fragment)  bool\n// Compare this fragment to another one.\nFragment.prototype.eq = function eq (other) {\n  if (this.content.length != other.content.length) { return false }\n  for (var i = 0; i < this.content.length; i++)\n    { if (!this.content[i].eq(other.content[i])) { return false } }\n  return true\n};\n\n// :: ?Node\n// The first child of the fragment, or `null` if it is empty.\nprototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };\n\n// :: ?Node\n// The last child of the fragment, or `null` if it is empty.\nprototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };\n\n// :: number\n// The number of child nodes in this fragment.\nprototypeAccessors.childCount.get = function () { return this.content.length };\n\n// :: (number)  Node\n// Get the child node at the given index. Raise an error when the\n// index is out of range.\nFragment.prototype.child = function child (index) {\n  var found = this.content[index];\n  if (!found) { throw new RangeError(\"Index \" + index + \" out of range for \" + this) }\n  return found\n};\n\n// :: (number)  ?Node\n// Get the child node at the given index, if it exists.\nFragment.prototype.maybeChild = function maybeChild (index) {\n  return this.content[index]\n};\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nFragment.prototype.forEach = function forEach (f) {\n  for (var i = 0, p = 0; i < this.content.length; i++) {\n    var child = this.content[i];\n    f(child, p, i);\n    p += child.nodeSize;\n  }\n};\n\n// :: (Fragment)  ?number\n// Find the first position at which this fragment and another\n// fragment differ, or `null` if they are the same.\nFragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {\n    if ( pos === void 0 ) pos = 0;\n\n  return findDiffStart(this, other, pos)\n};\n\n// :: (Fragment)  ?{a: number, b: number}\n// Find the first position, searching from the end, at which this\n// fragment and the given fragment differ, or `null` if they are the\n// same. Since this position will not be the same in both nodes, an\n// object with two separate positions is returned.\nFragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {\n    if ( pos === void 0 ) pos = this.size;\n    if ( otherPos === void 0 ) otherPos = other.size;\n\n  return findDiffEnd(this, other, pos, otherPos)\n};\n\n// : (number, ?number)  {index: number, offset: number}\n// Find the index and inner offset corresponding to a given relative\n// position in this fragment. The result object will be reused\n// (overwritten) the next time the function is called. (Not public.)\nFragment.prototype.findIndex = function findIndex (pos, round) {\n    if ( round === void 0 ) round = -1;\n\n  if (pos == 0) { return retIndex(0, pos) }\n  if (pos == this.size) { return retIndex(this.content.length, pos) }\n  if (pos > this.size || pos < 0) { throw new RangeError((\"Position \" + pos + \" outside of fragment (\" + (this) + \")\")) }\n  for (var i = 0, curPos = 0;; i++) {\n    var cur = this.child(i), end = curPos + cur.nodeSize;\n    if (end >= pos) {\n      if (end == pos || round > 0) { return retIndex(i + 1, end) }\n      return retIndex(i, curPos)\n    }\n    curPos = end;\n  }\n};\n\n// :: ()  string\n// Return a debugging string that describes this fragment.\nFragment.prototype.toString = function toString () { return \"<\" + this.toStringInner() + \">\" };\n\nFragment.prototype.toStringInner = function toStringInner () { return this.content.join(\", \") };\n\n// :: ()  ?Object\n// Create a JSON-serializeable representation of this fragment.\nFragment.prototype.toJSON = function toJSON () {\n  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null\n};\n\n// :: (Schema, ?Object)  Fragment\n// Deserialize a fragment from its JSON representation.\nFragment.fromJSON = function fromJSON (schema, value) {\n  if (!value) { return Fragment.empty }\n  if (!Array.isArray(value)) { throw new RangeError(\"Invalid input for Fragment.fromJSON\") }\n  return new Fragment(value.map(schema.nodeFromJSON))\n};\n\n// :: ([Node])  Fragment\n// Build a fragment from an array of nodes. Ensures that adjacent\n// text nodes with the same marks are joined together.\nFragment.fromArray = function fromArray (array) {\n  if (!array.length) { return Fragment.empty }\n  var joined, size = 0;\n  for (var i = 0; i < array.length; i++) {\n    var node = array[i];\n    size += node.nodeSize;\n    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n      if (!joined) { joined = array.slice(0, i); }\n      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n    } else if (joined) {\n      joined.push(node);\n    }\n  }\n  return new Fragment(joined || array, size)\n};\n\n// :: (?union<Fragment, Node, [Node]>)  Fragment\n// Create a fragment from something that can be interpreted as a set\n// of nodes. For `null`, it returns the empty fragment. For a\n// fragment, the fragment itself. For a node or array of nodes, a\n// fragment containing those nodes.\nFragment.from = function from (nodes) {\n  if (!nodes) { return Fragment.empty }\n  if (nodes instanceof Fragment) { return nodes }\n  if (Array.isArray(nodes)) { return this.fromArray(nodes) }\n  if (nodes.attrs) { return new Fragment([nodes], nodes.nodeSize) }\n  throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                       (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n};\n\nObject.defineProperties( Fragment.prototype, prototypeAccessors );\n\nvar found = {index: 0, offset: 0};\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0);\n\nfunction compareDeep(a, b) {\n  if (a === b) { return true }\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) { return false }\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) { return false }\n  if (array) {\n    if (a.length != b.length) { return false }\n    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }\n  } else {\n    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }\n    for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  }\n  return true\n}\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nvar Mark = function Mark(type, attrs) {\n  // :: MarkType\n  // The type of this mark.\n  this.type = type;\n  // :: Object\n  // The attributes associated with this mark.\n  this.attrs = attrs;\n};\n\n// :: ([Mark])  [Mark]\n// Given a set of marks, create a new set which contains this one as\n// well, in the right position. If this mark is already in the set,\n// the set itself is returned. If any marks that are set to be\n// [exclusive](#model.MarkSpec.excludes) with this mark are present,\n// those are replaced by this one.\nMark.prototype.addToSet = function addToSet (set) {\n  var copy, placed = false;\n  for (var i = 0; i < set.length; i++) {\n    var other = set[i];\n    if (this.eq(other)) { return set }\n    if (this.type.excludes(other.type)) {\n      if (!copy) { copy = set.slice(0, i); }\n    } else if (other.type.excludes(this.type)) {\n      return set\n    } else {\n      if (!placed && other.type.rank > this.type.rank) {\n        if (!copy) { copy = set.slice(0, i); }\n        copy.push(this);\n        placed = true;\n      }\n      if (copy) { copy.push(other); }\n    }\n  }\n  if (!copy) { copy = set.slice(); }\n  if (!placed) { copy.push(this); }\n  return copy\n};\n\n// :: ([Mark])  [Mark]\n// Remove this mark from the given set, returning a new set. If this\n// mark is not in the set, the set itself is returned.\nMark.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i]))\n      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n  return set\n};\n\n// :: ([Mark])  bool\n// Test whether this mark is in the given set of marks.\nMark.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i])) { return true } }\n  return false\n};\n\n// :: (Mark)  bool\n// Test whether this mark has the same type and attributes as\n// another mark.\nMark.prototype.eq = function eq (other) {\n  return this == other ||\n    (this.type == other.type && compareDeep(this.attrs, other.attrs))\n};\n\n// :: ()  Object\n// Convert this mark to a JSON-serializeable representation.\nMark.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  return obj\n};\n\n// :: (Schema, Object)  Mark\nMark.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Mark.fromJSON\") }\n  var type = schema.marks[json.type];\n  if (!type) { throw new RangeError((\"There is no mark type \" + (json.type) + \" in this schema\")) }\n  return type.create(json.attrs)\n};\n\n// :: ([Mark], [Mark])  bool\n// Test whether two sets of marks are identical.\nMark.sameSet = function sameSet (a, b) {\n  if (a == b) { return true }\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++)\n    { if (!a[i].eq(b[i])) { return false } }\n  return true\n};\n\n// :: (?union<Mark, [Mark]>)  [Mark]\n// Create a properly sorted mark set from null, a single mark, or an\n// unsorted array of marks.\nMark.setFrom = function setFrom (marks) {\n  if (!marks || marks.length == 0) { return Mark.none }\n  if (marks instanceof Mark) { return [marks] }\n  var copy = marks.slice();\n  copy.sort(function (a, b) { return a.type.rank - b.type.rank; });\n  return copy\n};\n\n// :: [Mark] The empty set of marks.\nMark.none = [];\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nfunction ReplaceError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = ReplaceError.prototype;\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype);\nReplaceError.prototype.constructor = ReplaceError;\nReplaceError.prototype.name = \"ReplaceError\";\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are open (cut through).\nvar Slice = function Slice(content, openStart, openEnd) {\n  // :: Fragment The slice's content.\n  this.content = content;\n  // :: number The open depth at the start.\n  this.openStart = openStart;\n  // :: number The open depth at the end.\n  this.openEnd = openEnd;\n};\n\nvar prototypeAccessors$1 = { size: { configurable: true } };\n\n// :: number\n// The size this slice would add when inserted into a document.\nprototypeAccessors$1.size.get = function () {\n  return this.content.size - this.openStart - this.openEnd\n};\n\nSlice.prototype.insertAt = function insertAt (pos, fragment) {\n  var content = insertInto(this.content, pos + this.openStart, fragment, null);\n  return content && new Slice(content, this.openStart, this.openEnd)\n};\n\nSlice.prototype.removeBetween = function removeBetween (from, to) {\n  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n};\n\n// :: (Slice)  bool\n// Tests whether this slice is equal to another slice.\nSlice.prototype.eq = function eq (other) {\n  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n};\n\nSlice.prototype.toString = function toString () {\n  return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n};\n\n// :: ()  ?Object\n// Convert a slice to a JSON-serializable representation.\nSlice.prototype.toJSON = function toJSON () {\n  if (!this.content.size) { return null }\n  var json = {content: this.content.toJSON()};\n  if (this.openStart > 0) { json.openStart = this.openStart; }\n  if (this.openEnd > 0) { json.openEnd = this.openEnd; }\n  return json\n};\n\n// :: (Schema, ?Object)  Slice\n// Deserialize a slice from its JSON representation.\nSlice.fromJSON = function fromJSON (schema, json) {\n  if (!json) { return Slice.empty }\n  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n  if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n    { throw new RangeError(\"Invalid input for Slice.fromJSON\") }\n  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n};\n\n// :: (Fragment, ?bool)  Slice\n// Create a slice from a fragment by taking the maximum possible\n// open value on both side of the fragment.\nSlice.maxOpen = function maxOpen (fragment, openIsolating) {\n    if ( openIsolating === void 0 ) openIsolating=true;\n\n  var openStart = 0, openEnd = 0;\n  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }\n  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }\n  return new Slice(fragment, openStart, openEnd)\n};\n\nObject.defineProperties( Slice.prototype, prototypeAccessors$1 );\n\nfunction removeRange(content, from, to) {\n  var ref = content.findIndex(from);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  var ref$1 = content.findIndex(to);\n  var indexTo = ref$1.index;\n  var offsetTo = ref$1.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError(\"Removing non-flat range\") }\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) { throw new RangeError(\"Removing non-flat range\") }\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var ref = content.findIndex(dist);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) { return null }\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0);\n\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    { throw new ReplaceError(\"Inserted content deeper than insertion position\") }\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    { throw new ReplaceError(\"Inconsistent open depths\") }\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth), node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    var parent = $from.parent, content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    var ref = prepareSliceForReplace(slice, $from);\n    var start = ref.start;\n    var end = ref.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    { throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name) }\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    { target[last] = child.withText(target[last].text + child.text); }\n  else\n    { target.push(child); }\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }\n  if ($end && $end.depth == depth && $end.textOffset)\n    { addNode($end.nodeBefore, target); }\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    { throw new ReplaceError(\"Invalid content for node \" + node.type.name) }\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart)\n      { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }\n    addRange($start, $end, depth, content);\n    if (openEnd)\n      { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart, parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--)\n    { node = $along.node(i).copy(Fragment.from(node)); }\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nvar ResolvedPos = function ResolvedPos(pos, path, parentOffset) {\n  // :: number The position that was resolved.\n  this.pos = pos;\n  this.path = path;\n  // :: number\n  // The number of levels the parent node is from the root. If this\n  // position points directly into the root node, it is 0. If it\n  // points into a top-level paragraph, 1, and so on.\n  this.depth = path.length / 3 - 1;\n  // :: number The offset this position has into its parent node.\n  this.parentOffset = parentOffset;\n};\n\nvar prototypeAccessors$2 = { parent: { configurable: true },doc: { configurable: true },textOffset: { configurable: true },nodeAfter: { configurable: true },nodeBefore: { configurable: true } };\n\nResolvedPos.prototype.resolveDepth = function resolveDepth (val) {\n  if (val == null) { return this.depth }\n  if (val < 0) { return this.depth + val }\n  return val\n};\n\n// :: Node\n// The parent node that the position points into. Note that even if\n// a position points into a text node, that node is not considered\n// the parenttext nodes are flat in this model, and have no content.\nprototypeAccessors$2.parent.get = function () { return this.node(this.depth) };\n\n// :: Node\n// The root node in which the position was resolved.\nprototypeAccessors$2.doc.get = function () { return this.node(0) };\n\n// :: (?number)  Node\n// The ancestor node at the given level. `p.node(p.depth)` is the\n// same as `p.parent`.\nResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };\n\n// :: (?number)  number\n// The index into the ancestor at the given level. If this points at\n// the 3rd node in the 2nd paragraph on the top level, for example,\n// `p.index(0)` is 1 and `p.index(1)` is 2.\nResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };\n\n// :: (?number)  number\n// The index pointing after this position into the ancestor at the\n// given level.\nResolvedPos.prototype.indexAfter = function indexAfter (depth) {\n  depth = this.resolveDepth(depth);\n  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n};\n\n// :: (?number)  number\n// The (absolute) position at the start of the node at the given\n// level.\nResolvedPos.prototype.start = function start (depth) {\n  depth = this.resolveDepth(depth);\n  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n};\n\n// :: (?number)  number\n// The (absolute) position at the end of the node at the given\n// level.\nResolvedPos.prototype.end = function end (depth) {\n  depth = this.resolveDepth(depth);\n  return this.start(depth) + this.node(depth).content.size\n};\n\n// :: (?number)  number\n// The (absolute) position directly before the wrapping node at the\n// given level, or, when `depth` is `this.depth + 1`, the original\n// position.\nResolvedPos.prototype.before = function before (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position before the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n};\n\n// :: (?number)  number\n// The (absolute) position directly after the wrapping node at the\n// given level, or the original position when `depth` is `this.depth + 1`.\nResolvedPos.prototype.after = function after (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position after the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n};\n\n// :: number\n// When this position points into a text node, this returns the\n// distance between the position and the start of the text node.\n// Will be zero for positions that point between nodes.\nprototypeAccessors$2.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };\n\n// :: ?Node\n// Get the node directly after the position, if any. If the position\n// points into a text node, only the part of that node after the\n// position is returned.\nprototypeAccessors$2.nodeAfter.get = function () {\n  var parent = this.parent, index = this.index(this.depth);\n  if (index == parent.childCount) { return null }\n  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n  return dOff ? parent.child(index).cut(dOff) : child\n};\n\n// :: ?Node\n// Get the node directly before the position, if any. If the\n// position points into a text node, only the part of that node\n// before the position is returned.\nprototypeAccessors$2.nodeBefore.get = function () {\n  var index = this.index(this.depth);\n  var dOff = this.pos - this.path[this.path.length - 1];\n  if (dOff) { return this.parent.child(index).cut(0, dOff) }\n  return index == 0 ? null : this.parent.child(index - 1)\n};\n\n// :: (number, ?number)  number\n// Get the position at the given index in the parent node at the\n// given depth (which defaults to `this.depth`).\nResolvedPos.prototype.posAtIndex = function posAtIndex (index, depth) {\n  depth = this.resolveDepth(depth);\n  var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n  for (var i = 0; i < index; i++) { pos += node.child(i).nodeSize; }\n  return pos\n};\n\n// :: ()  [Mark]\n// Get the marks at this position, factoring in the surrounding\n// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n// position is at the start of a non-empty node, the marks of the\n// node after it (if any) are returned.\nResolvedPos.prototype.marks = function marks () {\n  var parent = this.parent, index = this.index();\n\n  // In an empty parent, return the empty array\n  if (parent.content.size == 0) { return Mark.none }\n\n  // When inside a text node, just return the text node's marks\n  if (this.textOffset) { return parent.child(index).marks }\n\n  var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n  // If the `after` flag is true of there is no node before, make\n  // the node after this position the main reference.\n  if (!main) { var tmp = main; main = other; other = tmp; }\n\n  // Use all marks in the main node, except those that have\n  // `inclusive` set to false and are not present in the other node.\n  var marks = main.marks;\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n\n  return marks\n};\n\n// :: (ResolvedPos)  ?[Mark]\n// Get the marks after the current position, if any, except those\n// that are non-inclusive and not present at position `$end`. This\n// is mostly useful for getting the set of marks to preserve after a\n// deletion. Will return `null` if this position is at the end of\n// its parent node or its parent node isn't a textblock (in which\n// case no marks should be preserved).\nResolvedPos.prototype.marksAcross = function marksAcross ($end) {\n  var after = this.parent.maybeChild(this.index());\n  if (!after || !after.isInline) { return null }\n\n  var marks = after.marks, next = $end.parent.maybeChild($end.index());\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n  return marks\n};\n\n// :: (number)  number\n// The depth up to which this position and the given (non-resolved)\n// position share the same parent nodes.\nResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {\n  for (var depth = this.depth; depth > 0; depth--)\n    { if (this.start(depth) <= pos && this.end(depth) >= pos) { return depth } }\n  return 0\n};\n\n// :: (?ResolvedPos, ?(Node)  bool)  ?NodeRange\n// Returns a range based on the place where this position and the\n// given position diverge around block content. If both point into\n// the same textblock, for example, a range around that textblock\n// will be returned. If they point into different blocks, the range\n// around those blocks in their shared ancestor is returned. You can\n// pass in an optional predicate that will be called with a parent\n// node to see if a range into that parent is acceptable.\nResolvedPos.prototype.blockRange = function blockRange (other, pred) {\n    if ( other === void 0 ) other = this;\n\n  if (other.pos < this.pos) { return other.blockRange(this) }\n  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n    { if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n      { return new NodeRange(this, other, d) } }\n};\n\n// :: (ResolvedPos)  bool\n// Query whether the given position shares the same parent node.\nResolvedPos.prototype.sameParent = function sameParent (other) {\n  return this.pos - this.parentOffset == other.pos - other.parentOffset\n};\n\n// :: (ResolvedPos)  ResolvedPos\n// Return the greater of this and the given position.\nResolvedPos.prototype.max = function max (other) {\n  return other.pos > this.pos ? other : this\n};\n\n// :: (ResolvedPos)  ResolvedPos\n// Return the smaller of this and the given position.\nResolvedPos.prototype.min = function min (other) {\n  return other.pos < this.pos ? other : this\n};\n\nResolvedPos.prototype.toString = function toString () {\n  var str = \"\";\n  for (var i = 1; i <= this.depth; i++)\n    { str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1); }\n  return str + \":\" + this.parentOffset\n};\n\nResolvedPos.resolve = function resolve (doc, pos) {\n  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError(\"Position \" + pos + \" out of range\") }\n  var path = [];\n  var start = 0, parentOffset = pos;\n  for (var node = doc;;) {\n    var ref = node.content.findIndex(parentOffset);\n      var index = ref.index;\n      var offset = ref.offset;\n    var rem = parentOffset - offset;\n    path.push(node, index, start + offset);\n    if (!rem) { break }\n    node = node.child(index);\n    if (node.isText) { break }\n    parentOffset = rem - 1;\n    start += offset + 1;\n  }\n  return new ResolvedPos(pos, path, parentOffset)\n};\n\nResolvedPos.resolveCached = function resolveCached (doc, pos) {\n  for (var i = 0; i < resolveCache.length; i++) {\n    var cached = resolveCache[i];\n    if (cached.pos == pos && cached.doc == doc) { return cached }\n  }\n  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n  return result\n};\n\nObject.defineProperties( ResolvedPos.prototype, prototypeAccessors$2 );\n\nvar resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nvar NodeRange = function NodeRange($from, $to, depth) {\n  // :: ResolvedPos A resolved position along the start of the\n  // content. May have a `depth` greater than this object's `depth`\n  // property, since these are the positions that were used to\n  // compute the range, not re-resolved positions directly at its\n  // boundaries.\n  this.$from = $from;\n  // :: ResolvedPos A position along the end of the content. See\n  // caveat for [`$from`](#model.NodeRange.$from).\n  this.$to = $to;\n  // :: number The depth of the node that this range points into.\n  this.depth = depth;\n};\n\nvar prototypeAccessors$1$1 = { start: { configurable: true },end: { configurable: true },parent: { configurable: true },startIndex: { configurable: true },endIndex: { configurable: true } };\n\n// :: number The position at the start of the range.\nprototypeAccessors$1$1.start.get = function () { return this.$from.before(this.depth + 1) };\n// :: number The position at the end of the range.\nprototypeAccessors$1$1.end.get = function () { return this.$to.after(this.depth + 1) };\n\n// :: Node The parent node that the range points into.\nprototypeAccessors$1$1.parent.get = function () { return this.$from.node(this.depth) };\n// :: number The start index of the range in the parent node.\nprototypeAccessors$1$1.startIndex.get = function () { return this.$from.index(this.depth) };\n// :: number The end index of the range in the parent node.\nprototypeAccessors$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };\n\nObject.defineProperties( NodeRange.prototype, prototypeAccessors$1$1 );\n\nvar emptyAttrs = Object.create(null);\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nvar Node = function Node(type, attrs, content, marks) {\n  // :: NodeType\n  // The type of node that this is.\n  this.type = type;\n\n  // :: Object\n  // An object mapping attribute names to values. The kind of\n  // attributes allowed and required are\n  // [determined](#model.NodeSpec.attrs) by the node type.\n  this.attrs = attrs;\n\n  // :: Fragment\n  // A container holding the node's children.\n  this.content = content || Fragment.empty;\n\n  // :: [Mark]\n  // The marks (things like whether it is emphasized or part of a\n  // link) applied to this node.\n  this.marks = marks || Mark.none;\n};\n\nvar prototypeAccessors$3 = { nodeSize: { configurable: true },childCount: { configurable: true },textContent: { configurable: true },firstChild: { configurable: true },lastChild: { configurable: true },isBlock: { configurable: true },isTextblock: { configurable: true },inlineContent: { configurable: true },isInline: { configurable: true },isText: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };\n\n// text:: ?string\n// For text nodes, this contains the node's text content.\n\n// :: number\n// The size of this node, as defined by the integer-based [indexing\n// scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n// amount of characters. For other leaf nodes, it is one. For\n// non-leaf nodes, it is the size of the content plus two (the start\n// and end token).\nprototypeAccessors$3.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };\n\n// :: number\n// The number of children that the node has.\nprototypeAccessors$3.childCount.get = function () { return this.content.childCount };\n\n// :: (number)  Node\n// Get the child node at the given index. Raises an error when the\n// index is out of range.\nNode.prototype.child = function child (index) { return this.content.child(index) };\n\n// :: (number)  ?Node\n// Get the child node at the given index, if it exists.\nNode.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nNode.prototype.forEach = function forEach (f) { this.content.forEach(f); };\n\n// :: (number, number, (node: Node, pos: number, parent: Node, index: number)  ?bool, ?number)\n// Invoke a callback for all descendant nodes recursively between\n// the given two positions that are relative to start of this node's\n// content. The callback is invoked with the node, its\n// parent-relative position, its parent node, and its child index.\n// When the callback returns false for a given node, that node's\n// children will not be recursed over. The last parameter can be\n// used to specify a starting position to count from.\nNode.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {\n    if ( startPos === void 0 ) startPos = 0;\n\n  this.content.nodesBetween(from, to, f, startPos, this);\n};\n\n// :: ((node: Node, pos: number, parent: Node)  ?bool)\n// Call the given callback for every descendant node. Doesn't\n// descend into a node when the callback returns `false`.\nNode.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.content.size, f);\n};\n\n// :: string\n// Concatenates all the text nodes found in this fragment and its\n// children.\nprototypeAccessors$3.textContent.get = function () { return this.textBetween(0, this.content.size, \"\") };\n\n// :: (number, number, ?string, ?string | ?(leafNode: Node) -> string)  string\n// Get all text between positions `from` and `to`. When\n// `blockSeparator` is given, it will be inserted whenever a new\n// block node is started. When `leafText` is given, it'll be\n// inserted for every non-text leaf node encountered.\nNode.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  return this.content.textBetween(from, to, blockSeparator, leafText)\n};\n\n// :: ?Node\n// Returns this node's first child, or `null` if there are no\n// children.\nprototypeAccessors$3.firstChild.get = function () { return this.content.firstChild };\n\n// :: ?Node\n// Returns this node's last child, or `null` if there are no\n// children.\nprototypeAccessors$3.lastChild.get = function () { return this.content.lastChild };\n\n// :: (Node)  bool\n// Test whether two nodes represent the same piece of document.\nNode.prototype.eq = function eq (other) {\n  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n};\n\n// :: (Node)  bool\n// Compare the markup (type, attributes, and marks) of this node to\n// those of another. Returns `true` if both have the same markup.\nNode.prototype.sameMarkup = function sameMarkup (other) {\n  return this.hasMarkup(other.type, other.attrs, other.marks)\n};\n\n// :: (NodeType, ?Object, ?[Mark])  bool\n// Check whether this node's markup correspond to the given type,\n// attributes, and marks.\nNode.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {\n  return this.type == type &&\n    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n    Mark.sameSet(this.marks, marks || Mark.none)\n};\n\n// :: (?Fragment)  Node\n// Create a new node with the same markup as this node, containing\n// the given content (or empty, if no content is given).\nNode.prototype.copy = function copy (content) {\n    if ( content === void 0 ) content = null;\n\n  if (content == this.content) { return this }\n  return new this.constructor(this.type, this.attrs, content, this.marks)\n};\n\n// :: ([Mark])  Node\n// Create a copy of this node, with the given set of marks instead\n// of the node's own marks.\nNode.prototype.mark = function mark (marks) {\n  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n};\n\n// :: (number, ?number)  Node\n// Create a copy of this node with only the content between the\n// given positions. If `to` is not given, it defaults to the end of\n// the node.\nNode.prototype.cut = function cut (from, to) {\n  if (from == 0 && to == this.content.size) { return this }\n  return this.copy(this.content.cut(from, to))\n};\n\n// :: (number, ?number)  Slice\n// Cut out the part of the document between the given positions, and\n// return it as a `Slice` object.\nNode.prototype.slice = function slice (from, to, includeParents) {\n    if ( to === void 0 ) to = this.content.size;\n    if ( includeParents === void 0 ) includeParents = false;\n\n  if (from == to) { return Slice.empty }\n\n  var $from = this.resolve(from), $to = this.resolve(to);\n  var depth = includeParents ? 0 : $from.sharedDepth(to);\n  var start = $from.start(depth), node = $from.node(depth);\n  var content = node.content.cut($from.pos - start, $to.pos - start);\n  return new Slice(content, $from.depth - depth, $to.depth - depth)\n};\n\n// :: (number, number, Slice)  Node\n// Replace the part of the document between the given positions with\n// the given slice. The slice must 'fit', meaning its open sides\n// must be able to connect to the surrounding content, and its\n// content nodes must be valid children for the node they are placed\n// into. If any of this is violated, an error of type\n// [`ReplaceError`](#model.ReplaceError) is thrown.\nNode.prototype.replace = function replace$1 (from, to, slice) {\n  return replace(this.resolve(from), this.resolve(to), slice)\n};\n\n// :: (number)  ?Node\n// Find the node directly after the given position.\nNode.prototype.nodeAt = function nodeAt (pos) {\n  for (var node = this;;) {\n    var ref = node.content.findIndex(pos);\n      var index = ref.index;\n      var offset = ref.offset;\n    node = node.maybeChild(index);\n    if (!node) { return null }\n    if (offset == pos || node.isText) { return node }\n    pos -= offset + 1;\n  }\n};\n\n// :: (number)  {node: ?Node, index: number, offset: number}\n// Find the (direct) child node after the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childAfter = function childAfter (pos) {\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  return {node: this.content.maybeChild(index), index: index, offset: offset}\n};\n\n// :: (number)  {node: ?Node, index: number, offset: number}\n// Find the (direct) child node before the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childBefore = function childBefore (pos) {\n  if (pos == 0) { return {node: null, index: 0, offset: 0} }\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }\n  var node = this.content.child(index - 1);\n  return {node: node, index: index - 1, offset: offset - node.nodeSize}\n};\n\n// :: (number)  ResolvedPos\n// Resolve the given position in the document, returning an\n// [object](#model.ResolvedPos) with information about its context.\nNode.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };\n\nNode.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };\n\n// :: (number, number, union<Mark, MarkType>)  bool\n// Test whether a given mark or mark type occurs in this document\n// between the two given positions.\nNode.prototype.rangeHasMark = function rangeHasMark (from, to, type) {\n  var found = false;\n  if (to > from) { this.nodesBetween(from, to, function (node) {\n    if (type.isInSet(node.marks)) { found = true; }\n    return !found\n  }); }\n  return found\n};\n\n// :: bool\n// True when this is a block (non-inline node)\nprototypeAccessors$3.isBlock.get = function () { return this.type.isBlock };\n\n// :: bool\n// True when this is a textblock node, a block node with inline\n// content.\nprototypeAccessors$3.isTextblock.get = function () { return this.type.isTextblock };\n\n// :: bool\n// True when this node allows inline content.\nprototypeAccessors$3.inlineContent.get = function () { return this.type.inlineContent };\n\n// :: bool\n// True when this is an inline node (a text node or a node that can\n// appear among text).\nprototypeAccessors$3.isInline.get = function () { return this.type.isInline };\n\n// :: bool\n// True when this is a text node.\nprototypeAccessors$3.isText.get = function () { return this.type.isText };\n\n// :: bool\n// True when this is a leaf node.\nprototypeAccessors$3.isLeaf.get = function () { return this.type.isLeaf };\n\n// :: bool\n// True when this is an atom, i.e. when it does not have directly\n// editable content. This is usually the same as `isLeaf`, but can\n// be configured with the [`atom` property](#model.NodeSpec.atom) on\n// a node's spec (typically used when the node is displayed as an\n// uneditable [node view](#view.NodeView)).\nprototypeAccessors$3.isAtom.get = function () { return this.type.isAtom };\n\n// :: ()  string\n// Return a string representation of this node for debugging\n// purposes.\nNode.prototype.toString = function toString () {\n  if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n  var name = this.type.name;\n  if (this.content.size)\n    { name += \"(\" + this.content.toStringInner() + \")\"; }\n  return wrapMarks(this.marks, name)\n};\n\n// :: (number)  ContentMatch\n// Get the content match in this node at the given index.\nNode.prototype.contentMatchAt = function contentMatchAt (index) {\n  var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n  if (!match) { throw new Error(\"Called contentMatchAt on a node with invalid content\") }\n  return match\n};\n\n// :: (number, number, ?Fragment, ?number, ?number)  bool\n// Test whether replacing the range between `from` and `to` (by\n// child index) with the given replacement fragment (which defaults\n// to the empty fragment) would leave the node's content valid. You\n// can optionally pass `start` and `end` indices into the\n// replacement fragment.\nNode.prototype.canReplace = function canReplace (from, to, replacement, start, end) {\n    if ( replacement === void 0 ) replacement = Fragment.empty;\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = replacement.childCount;\n\n  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n  var two = one && one.matchFragment(this.content, to);\n  if (!two || !two.validEnd) { return false }\n  for (var i = start; i < end; i++) { if (!this.type.allowsMarks(replacement.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (number, number, NodeType, ?[Mark])  bool\n// Test whether replacing the range `from` to `to` (by index) with a\n// node of the given type would leave the node's content valid.\nNode.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {\n  if (marks && !this.type.allowsMarks(marks)) { return false }\n  var start = this.contentMatchAt(from).matchType(type);\n  var end = start && start.matchFragment(this.content, to);\n  return end ? end.validEnd : false\n};\n\n// :: (Node)  bool\n// Test whether the given node's content could be appended to this\n// node. If that node is empty, this will only return true if there\n// is at least one node type that can appear in both nodes (to avoid\n// merging completely incompatible nodes).\nNode.prototype.canAppend = function canAppend (other) {\n  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }\n  else { return this.type.compatibleContent(other.type) }\n};\n\n// :: ()\n// Check whether this node and its descendants conform to the\n// schema, and raise error when they do not.\nNode.prototype.check = function check () {\n  if (!this.type.validContent(this.content))\n    { throw new RangeError((\"Invalid content for node \" + (this.type.name) + \": \" + (this.content.toString().slice(0, 50)))) }\n  var copy = Mark.none;\n  for (var i = 0; i < this.marks.length; i++) { copy = this.marks[i].addToSet(copy); }\n  if (!Mark.sameSet(copy, this.marks))\n    { throw new RangeError((\"Invalid collection of marks for node \" + (this.type.name) + \": \" + (this.marks.map(function (m) { return m.type.name; })))) }\n  this.content.forEach(function (node) { return node.check(); });\n};\n\n// :: ()  Object\n// Return a JSON-serializeable representation of this node.\nNode.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  if (this.content.size)\n    { obj.content = this.content.toJSON(); }\n  if (this.marks.length)\n    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }\n  return obj\n};\n\n// :: (Schema, Object)  Node\n// Deserialize a node from its JSON representation.\nNode.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Node.fromJSON\") }\n  var marks = null;\n  if (json.marks) {\n    if (!Array.isArray(json.marks)) { throw new RangeError(\"Invalid mark data for Node.fromJSON\") }\n    marks = json.marks.map(schema.markFromJSON);\n  }\n  if (json.type == \"text\") {\n    if (typeof json.text != \"string\") { throw new RangeError(\"Invalid text node in JSON\") }\n    return schema.text(json.text, marks)\n  }\n  var content = Fragment.fromJSON(schema, json.content);\n  return schema.nodeType(json.type).create(json.attrs, content, marks)\n};\n\nObject.defineProperties( Node.prototype, prototypeAccessors$3 );\n\nvar TextNode = /*@__PURE__*/(function (Node) {\n  function TextNode(type, attrs, content, marks) {\n    Node.call(this, type, attrs, null, marks);\n\n    if (!content) { throw new RangeError(\"Empty text nodes are not allowed\") }\n\n    this.text = content;\n  }\n\n  if ( Node ) TextNode.__proto__ = Node;\n  TextNode.prototype = Object.create( Node && Node.prototype );\n  TextNode.prototype.constructor = TextNode;\n\n  var prototypeAccessors$1 = { textContent: { configurable: true },nodeSize: { configurable: true } };\n\n  TextNode.prototype.toString = function toString () {\n    if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  };\n\n  prototypeAccessors$1.textContent.get = function () { return this.text };\n\n  TextNode.prototype.textBetween = function textBetween (from, to) { return this.text.slice(from, to) };\n\n  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };\n\n  TextNode.prototype.mark = function mark (marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  };\n\n  TextNode.prototype.withText = function withText (text) {\n    if (text == this.text) { return this }\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  };\n\n  TextNode.prototype.cut = function cut (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.text.length;\n\n    if (from == 0 && to == this.text.length) { return this }\n    return this.withText(this.text.slice(from, to))\n  };\n\n  TextNode.prototype.eq = function eq (other) {\n    return this.sameMarkup(other) && this.text == other.text\n  };\n\n  TextNode.prototype.toJSON = function toJSON () {\n    var base = Node.prototype.toJSON.call(this);\n    base.text = this.text;\n    return base\n  };\n\n  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );\n\n  return TextNode;\n}(Node));\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--)\n    { str = marks[i].type.name + \"(\" + str + \")\"; }\n  return str\n}\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nvar ContentMatch = function ContentMatch(validEnd) {\n  // :: bool\n  // True when this match state represents a valid end of the node.\n  this.validEnd = validEnd;\n  this.next = [];\n  this.wrapCache = [];\n};\n\nvar prototypeAccessors$4 = { inlineContent: { configurable: true },defaultType: { configurable: true },edgeCount: { configurable: true } };\n\nContentMatch.parse = function parse (string, nodeTypes) {\n  var stream = new TokenStream(string, nodeTypes);\n  if (stream.next == null) { return ContentMatch.empty }\n  var expr = parseExpr(stream);\n  if (stream.next) { stream.err(\"Unexpected trailing text\"); }\n  var match = dfa(nfa(expr));\n  checkForDeadEnds(match, stream);\n  return match\n};\n\n// :: (NodeType)  ?ContentMatch\n// Match a node type, returning a match after that node if\n// successful.\nContentMatch.prototype.matchType = function matchType (type) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { if (this.next[i] == type) { return this.next[i + 1] } }\n  return null\n};\n\n// :: (Fragment, ?number, ?number)  ?ContentMatch\n// Try to match a fragment. Returns the resulting match when\n// successful.\nContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = frag.childCount;\n\n  var cur = this;\n  for (var i = start; cur && i < end; i++)\n    { cur = cur.matchType(frag.child(i).type); }\n  return cur\n};\n\nprototypeAccessors$4.inlineContent.get = function () {\n  var first = this.next[0];\n  return first ? first.isInline : false\n};\n\n// :: ?NodeType\n// Get the first matching node type at this match position that can\n// be generated.\nprototypeAccessors$4.defaultType.get = function () {\n  for (var i = 0; i < this.next.length; i += 2) {\n    var type = this.next[i];\n    if (!(type.isText || type.hasRequiredAttrs())) { return type }\n  }\n};\n\nContentMatch.prototype.compatible = function compatible (other) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { for (var j = 0; j < other.next.length; j += 2)\n      { if (this.next[i] == other.next[j]) { return true } } }\n  return false\n};\n\n// :: (Fragment, bool, ?number)  ?Fragment\n// Try to match the given fragment, and if that fails, see if it can\n// be made to match by inserting nodes in front of it. When\n// successful, return a fragment of inserted nodes (which may be\n// empty if nothing had to be inserted). When `toEnd` is true, only\n// return a fragment if the resulting match goes to the end of the\n// content expression.\nContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {\n    if ( toEnd === void 0 ) toEnd = false;\n    if ( startIndex === void 0 ) startIndex = 0;\n\n  var seen = [this];\n  function search(match, types) {\n    var finished = match.matchFragment(after, startIndex);\n    if (finished && (!toEnd || finished.validEnd))\n      { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i], next = match.next[i + 1];\n      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n        seen.push(next);\n        var found = search(next, types.concat(type));\n        if (found) { return found }\n      }\n    }\n  }\n\n  return search(this, [])\n};\n\n// :: (NodeType)  ?[NodeType]\n// Find a set of wrapping node types that would allow a node of the\n// given type to appear at this position. The result may be empty\n// (when it fits directly) and will be null when no such wrapping\n// exists.\nContentMatch.prototype.findWrapping = function findWrapping (target) {\n  for (var i = 0; i < this.wrapCache.length; i += 2)\n    { if (this.wrapCache[i] == target) { return this.wrapCache[i + 1] } }\n  var computed = this.computeWrapping(target);\n  this.wrapCache.push(target, computed);\n  return computed\n};\n\nContentMatch.prototype.computeWrapping = function computeWrapping (target) {\n  var seen = Object.create(null), active = [{match: this, type: null, via: null}];\n  while (active.length) {\n    var current = active.shift(), match = current.match;\n    if (match.matchType(target)) {\n      var result = [];\n      for (var obj = current; obj.type; obj = obj.via)\n        { result.push(obj.type); }\n      return result.reverse()\n    }\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i];\n      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n        active.push({match: type.contentMatch, type: type, via: current});\n        seen[type.name] = true;\n      }\n    }\n  }\n};\n\n// :: number\n// The number of outgoing edges this node has in the finite\n// automaton that describes the content expression.\nprototypeAccessors$4.edgeCount.get = function () {\n  return this.next.length >> 1\n};\n\n// :: (number)  {type: NodeType, next: ContentMatch}\n// Get the _n_th outgoing edge from this node in the finite\n// automaton that describes the content expression.\nContentMatch.prototype.edge = function edge (n) {\n  var i = n << 1;\n  if (i >= this.next.length) { throw new RangeError((\"There's no \" + n + \"th edge in this content match\")) }\n  return {type: this.next[i], next: this.next[i + 1]}\n};\n\nContentMatch.prototype.toString = function toString () {\n  var seen = [];\n  function scan(m) {\n    seen.push(m);\n    for (var i = 1; i < m.next.length; i += 2)\n      { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }\n  }\n  scan(this);\n  return seen.map(function (m, i) {\n    var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)\n      { out += (i$1 ? \", \" : \"\") + m.next[i$1].name + \"->\" + seen.indexOf(m.next[i$1 + 1]); }\n    return out\n  }).join(\"\\n\")\n};\n\nObject.defineProperties( ContentMatch.prototype, prototypeAccessors$4 );\n\nContentMatch.empty = new ContentMatch(true);\n\nvar TokenStream = function TokenStream(string, nodeTypes) {\n  this.string = string;\n  this.nodeTypes = nodeTypes;\n  this.inline = null;\n  this.pos = 0;\n  this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n  if (this.tokens[this.tokens.length - 1] == \"\") { this.tokens.pop(); }\n  if (this.tokens[0] == \"\") { this.tokens.shift(); }\n};\n\nvar prototypeAccessors$1$2 = { next: { configurable: true } };\n\nprototypeAccessors$1$2.next.get = function () { return this.tokens[this.pos] };\n\nTokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };\n\nTokenStream.prototype.err = function err (str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") };\n\nObject.defineProperties( TokenStream.prototype, prototypeAccessors$1$2 );\n\nfunction parseExpr(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSeq(stream)); }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n}\n\nfunction parseExprSeq(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSubscript(stream)); }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs: exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n  for (;;) {\n    if (stream.eat(\"+\"))\n      { expr = {type: \"plus\", expr: expr}; }\n    else if (stream.eat(\"*\"))\n      { expr = {type: \"star\", expr: expr}; }\n    else if (stream.eat(\"?\"))\n      { expr = {type: \"opt\", expr: expr}; }\n    else if (stream.eat(\"{\"))\n      { expr = parseExprRange(stream, expr); }\n    else { break }\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) { stream.err(\"Expected number, got '\" + stream.next + \"'\"); }\n  var result = Number(stream.next);\n  stream.pos++;\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream), max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") { max = parseNum(stream); }\n    else { max = -1; }\n  }\n  if (!stream.eat(\"}\")) { stream.err(\"Unclosed braced range\"); }\n  return {type: \"range\", min: min, max: max, expr: expr}\n}\n\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes, type = types[name];\n  if (type) { return [type] }\n  var result = [];\n  for (var typeName in types) {\n    var type$1 = types[typeName];\n    if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }\n  }\n  if (result.length == 0) { stream.err(\"No node type or group '\" + name + \"' found\"); }\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) { stream.err(\"Missing closing paren\"); }\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) { stream.inline = type.isInline; }\n      else if (stream.inline != type.isInline) { stream.err(\"Mixing inline and block content\"); }\n      return {type: \"name\", value: type}\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object)  [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    var edge = {term: term, to: to};\n    nfa[from].push(edge);\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) { return next }\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      var loop$1 = node();\n      connect(compile(expr.expr, from), loop$1);\n      connect(compile(expr.expr, loop$1), loop$1);\n      return [edge(loop$1)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      var cur = from;\n      for (var i$1 = 0; i$1 < expr.min; i$1++) {\n        var next$1 = node();\n        connect(compile(expr.expr, cur), next$1);\n        cur = next$1;\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {\n          var next$2 = node();\n          edge(cur, next$2);\n          connect(compile(expr.expr, cur), next$2);\n          cur = next$2;\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp)\n\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }\n    result.push(node);\n    for (var i = 0; i < edges.length; i++) {\n      var ref = edges[i];\n      var term = ref.term;\n      var to = ref.to;\n      if (!term && result.indexOf(to) == -1) { scan(to); }\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]])  ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (ref) {\n        var term = ref.term;\n        var to = ref.to;\n\n        if (!term) { return }\n        var known = out.indexOf(term), set = known > -1 && out[known + 1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) { out.push(term, set = []); }\n          if (set.indexOf(node) == -1) { set.push(node); }\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n    for (var i = 0; i < out.length; i += 2) {\n      var states$1 = out[i + 1].sort(cmp);\n      state.next.push(out[i], labeled[states$1.join(\",\")] || explore(states$1));\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i], dead = !state.validEnd, nodes = [];\n    for (var j = 0; j < state.next.length; j += 2) {\n      var node = state.next[j], next = state.next[j + 1];\n      nodes.push(node.name);\n      if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }\n      if (work.indexOf(next) == -1) { work.push(next); }\n    }\n    if (dead) { stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\"); }\n  }\n}\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) { return null }\n    defaults[attrName] = attr.default;\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  var built = Object.create(null);\n  for (var name in attrs) {\n    var given = value && value[name];\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) { given = attr.default; }\n      else { throw new RangeError(\"No value supplied for attribute \" + name) }\n    }\n    built[name] = given;\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null);\n  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nvar NodeType = function NodeType(name, schema, spec) {\n  // :: string\n  // The name the node type has in this schema.\n  this.name = name;\n\n  // :: Schema\n  // A link back to the `Schema` the node type belongs to.\n  this.schema = schema;\n\n  // :: NodeSpec\n  // The spec that this type is based on\n  this.spec = spec;\n\n  this.groups = spec.group ? spec.group.split(\" \") : [];\n  this.attrs = initAttrs(spec.attrs);\n\n  this.defaultAttrs = defaultAttrs(this.attrs);\n\n  // :: ContentMatch\n  // The starting match of the node type's content expression.\n  this.contentMatch = null;\n\n  // : ?[MarkType]\n  // The set of marks allowed in this node. `null` means all marks\n  // are allowed.\n  this.markSet = null;\n\n  // :: bool\n  // True if this node type has inline content.\n  this.inlineContent = null;\n\n  // :: bool\n  // True if this is a block type\n  this.isBlock = !(spec.inline || name == \"text\");\n\n  // :: bool\n  // True if this is the text node type.\n  this.isText = name == \"text\";\n};\n\nvar prototypeAccessors$5 = { isInline: { configurable: true },isTextblock: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };\n\n// :: bool\n// True if this is an inline type.\nprototypeAccessors$5.isInline.get = function () { return !this.isBlock };\n\n// :: bool\n// True if this is a textblock type, a block that contains inline\n// content.\nprototypeAccessors$5.isTextblock.get = function () { return this.isBlock && this.inlineContent };\n\n// :: bool\n// True for node types that allow no content.\nprototypeAccessors$5.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };\n\n// :: bool\n// True when this node is an atom, i.e. when it does not have\n// directly editable content.\nprototypeAccessors$5.isAtom.get = function () { return this.isLeaf || this.spec.atom };\n\n// :: ()  bool\n// Tells you whether this node type has any required attributes.\nNodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs () {\n  for (var n in this.attrs) { if (this.attrs[n].isRequired) { return true } }\n  return false\n};\n\nNodeType.prototype.compatibleContent = function compatibleContent (other) {\n  return this == other || this.contentMatch.compatible(other.contentMatch)\n};\n\nNodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {\n  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }\n  else { return computeAttrs(this.attrs, attrs) }\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node\n// Create a `Node` of this type. The given attributes are\n// checked and defaulted (you can pass `null` to use the type's\n// defaults entirely, if no required attributes exist). `content`\n// may be a `Fragment`, a node, an array of nodes, or\n// `null`. Similarly `marks` may be `null` to default to the empty\n// set of marks.\nNodeType.prototype.create = function create (attrs, content, marks) {\n  if (this.isText) { throw new Error(\"NodeType.create can't construct text nodes\") }\n  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node\n// Like [`create`](#model.NodeType.create), but check the given content\n// against the node type's content restrictions, and throw an error\n// if it doesn't match.\nNodeType.prototype.createChecked = function createChecked (attrs, content, marks) {\n  content = Fragment.from(content);\n  if (!this.validContent(content))\n    { throw new RangeError(\"Invalid content for node \" + this.name) }\n  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  ?Node\n// Like [`create`](#model.NodeType.create), but see if it is necessary to\n// add nodes to the start or end of the given fragment to make it\n// fit the node. If no fitting wrapping can be found, return null.\n// Note that, due to the fact that required nodes can always be\n// created, this will always succeed if you pass null or\n// `Fragment.empty` as content.\nNodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {\n  attrs = this.computeAttrs(attrs);\n  content = Fragment.from(content);\n  if (content.size) {\n    var before = this.contentMatch.fillBefore(content);\n    if (!before) { return null }\n    content = before.append(content);\n  }\n  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);\n  if (!after) { return null }\n  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n};\n\n// :: (Fragment)  bool\n// Returns true if the given fragment is valid content for this node\n// type with the given attributes.\nNodeType.prototype.validContent = function validContent (content) {\n  var result = this.contentMatch.matchFragment(content);\n  if (!result || !result.validEnd) { return false }\n  for (var i = 0; i < content.childCount; i++)\n    { if (!this.allowsMarks(content.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (MarkType)  bool\n// Check whether the given mark type is allowed in this node.\nNodeType.prototype.allowsMarkType = function allowsMarkType (markType) {\n  return this.markSet == null || this.markSet.indexOf(markType) > -1\n};\n\n// :: ([Mark])  bool\n// Test whether the given set of marks are allowed in this node.\nNodeType.prototype.allowsMarks = function allowsMarks (marks) {\n  if (this.markSet == null) { return true }\n  for (var i = 0; i < marks.length; i++) { if (!this.allowsMarkType(marks[i].type)) { return false } }\n  return true\n};\n\n// :: ([Mark])  [Mark]\n// Removes the marks that are not allowed in this node from the given set.\nNodeType.prototype.allowedMarks = function allowedMarks (marks) {\n  if (this.markSet == null) { return marks }\n  var copy;\n  for (var i = 0; i < marks.length; i++) {\n    if (!this.allowsMarkType(marks[i].type)) {\n      if (!copy) { copy = marks.slice(0, i); }\n    } else if (copy) {\n      copy.push(marks[i]);\n    }\n  }\n  return !copy ? marks : copy.length ? copy : Mark.empty\n};\n\nNodeType.compile = function compile (nodes, schema) {\n  var result = Object.create(null);\n  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });\n\n  var topType = schema.spec.topNode || \"doc\";\n  if (!result[topType]) { throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\") }\n  if (!result.text) { throw new RangeError(\"Every schema needs a 'text' type\") }\n  for (var _ in result.text.attrs) { throw new RangeError(\"The text node type should not have attributes\") }\n\n  return result\n};\n\nObject.defineProperties( NodeType.prototype, prototypeAccessors$5 );\n\n// Attribute descriptors\n\nvar Attribute = function Attribute(options) {\n  this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n  this.default = options.default;\n};\n\nvar prototypeAccessors$1$3 = { isRequired: { configurable: true } };\n\nprototypeAccessors$1$3.isRequired.get = function () {\n  return !this.hasDefault\n};\n\nObject.defineProperties( Attribute.prototype, prototypeAccessors$1$3 );\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nvar MarkType = function MarkType(name, rank, schema, spec) {\n  // :: string\n  // The name of the mark type.\n  this.name = name;\n\n  // :: Schema\n  // The schema that this mark type instance is part of.\n  this.schema = schema;\n\n  // :: MarkSpec\n  // The spec on which the type is based.\n  this.spec = spec;\n\n  this.attrs = initAttrs(spec.attrs);\n\n  this.rank = rank;\n  this.excluded = null;\n  var defaults = defaultAttrs(this.attrs);\n  this.instance = defaults && new Mark(this, defaults);\n};\n\n// :: (?Object)  Mark\n// Create a mark of this type. `attrs` may be `null` or an object\n// containing only some of the mark's attributes. The others, if\n// they have defaults, will be added.\nMarkType.prototype.create = function create (attrs) {\n  if (!attrs && this.instance) { return this.instance }\n  return new Mark(this, computeAttrs(this.attrs, attrs))\n};\n\nMarkType.compile = function compile (marks, schema) {\n  var result = Object.create(null), rank = 0;\n  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });\n  return result\n};\n\n// :: ([Mark])  [Mark]\n// When there is a mark of this type in the given set, a new set\n// without it is returned. Otherwise, the input set is returned.\nMarkType.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++) { if (set[i].type == this) {\n    set = set.slice(0, i).concat(set.slice(i + 1));\n    i--;\n  } }\n  return set\n};\n\n// :: ([Mark])  ?Mark\n// Tests whether there is a mark of this type in the given set.\nMarkType.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (set[i].type == this) { return set[i] } }\n};\n\n// :: (MarkType)  bool\n// Queries whether a given mark type is\n// [excluded](#model.MarkSpec.excludes) by this one.\nMarkType.prototype.excludes = function excludes (other) {\n  return this.excluded.indexOf(other) > -1\n};\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significantit\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node)  DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (hole) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool)  DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nvar Schema = function Schema(spec) {\n  // :: SchemaSpec\n  // The [spec](#model.SchemaSpec) on which the schema is based,\n  // with the added guarantee that its `nodes` and `marks`\n  // properties are\n  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n  // (not raw objects).\n  this.spec = {};\n  for (var prop in spec) { this.spec[prop] = spec[prop]; }\n  this.spec.nodes = OrderedMap.from(spec.nodes);\n  this.spec.marks = OrderedMap.from(spec.marks);\n\n  // :: Object<NodeType>\n  // An object mapping the schema's node names to node type objects.\n  this.nodes = NodeType.compile(this.spec.nodes, this);\n\n  // :: Object<MarkType>\n  // A map from mark names to mark type objects.\n  this.marks = MarkType.compile(this.spec.marks, this);\n\n  var contentExprCache = Object.create(null);\n  for (var prop$1 in this.nodes) {\n    if (prop$1 in this.marks)\n      { throw new RangeError(prop$1 + \" can not be both a node and a mark\") }\n    var type = this.nodes[prop$1], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n    type.contentMatch = contentExprCache[contentExpr] ||\n      (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n    type.inlineContent = type.contentMatch.inlineContent;\n    type.markSet = markExpr == \"_\" ? null :\n      markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n      markExpr == \"\" || !type.inlineContent ? [] : null;\n  }\n  for (var prop$2 in this.marks) {\n    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;\n    type$1.excluded = excl == null ? [type$1] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n  }\n\n  this.nodeFromJSON = this.nodeFromJSON.bind(this);\n  this.markFromJSON = this.markFromJSON.bind(this);\n\n  // :: NodeType\n  // The type of the [default top node](#model.SchemaSpec.topNode)\n  // for this schema.\n  this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n\n  // :: Object\n  // An object for storing whatever values modules may want to\n  // compute and cache per schema. (If you want to store something\n  // in it, try to use property names unlikely to clash.)\n  this.cached = Object.create(null);\n  this.cached.wrappings = Object.create(null);\n};\n\n// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node\n// Create a node in this schema. The `type` may be a string or a\n// `NodeType` instance. Attributes will be extended\n// with defaults, `content` may be a `Fragment`,\n// `null`, a `Node`, or an array of nodes.\nSchema.prototype.node = function node (type, attrs, content, marks) {\n  if (typeof type == \"string\")\n    { type = this.nodeType(type); }\n  else if (!(type instanceof NodeType))\n    { throw new RangeError(\"Invalid node type: \" + type) }\n  else if (type.schema != this)\n    { throw new RangeError(\"Node type from different schema used (\" + type.name + \")\") }\n\n  return type.createChecked(attrs, content, marks)\n};\n\n// :: (string, ?[Mark])  Node\n// Create a text node in the schema. Empty text nodes are not\n// allowed.\nSchema.prototype.text = function text (text$1, marks) {\n  var type = this.nodes.text;\n  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))\n};\n\n// :: (union<string, MarkType>, ?Object)  Mark\n// Create a mark with the given type and attributes.\nSchema.prototype.mark = function mark (type, attrs) {\n  if (typeof type == \"string\") { type = this.marks[type]; }\n  return type.create(attrs)\n};\n\n// :: (Object)  Node\n// Deserialize a node from its JSON representation. This method is\n// bound.\nSchema.prototype.nodeFromJSON = function nodeFromJSON (json) {\n  return Node.fromJSON(this, json)\n};\n\n// :: (Object)  Mark\n// Deserialize a mark from its JSON representation. This method is\n// bound.\nSchema.prototype.markFromJSON = function markFromJSON (json) {\n  return Mark.fromJSON(this, json)\n};\n\nSchema.prototype.nodeType = function nodeType (name) {\n  var found = this.nodes[name];\n  if (!found) { throw new RangeError(\"Unknown node type: \" + name) }\n  return found\n};\n\nfunction gatherMarks(schema, marks) {\n  var found = [];\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i], mark = schema.marks[name], ok = mark;\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var mark$1 = schema.marks[prop];\n        if (name == \"_\" || (mark$1.spec.group && mark$1.spec.group.split(\" \").indexOf(name) > -1))\n          { found.push(ok = mark$1); }\n      }\n    }\n    if (!ok) { throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\") }\n  }\n  return found\n}\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schemawhen directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   contextthe parent nodes into which the content is being\n//   parsedmatches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a sectiona double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>)  ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node)  dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema)  Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nvar DOMParser = function DOMParser(schema, rules) {\n  var this$1 = this;\n\n  // :: Schema\n  // The schema into which the parser parses.\n  this.schema = schema;\n  // :: [ParseRule]\n  // The set of [parse rules](#model.ParseRule) that the parser\n  // uses, in order of precedence.\n  this.rules = rules;\n  this.tags = [];\n  this.styles = [];\n\n  rules.forEach(function (rule) {\n    if (rule.tag) { this$1.tags.push(rule); }\n    else if (rule.style) { this$1.styles.push(rule); }\n  });\n\n  // Only normalize list elements when lists in the schema can't directly contain themselves\n  this.normalizeLists = !this.tags.some(function (r) {\n    if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) { return false }\n    var node = schema.nodes[r.node];\n    return node.contentMatch.matchType(node)\n  });\n};\n\n// :: (dom.Node, ?ParseOptions)  Node\n// Parse a document from the content of a DOM node.\nDOMParser.prototype.parse = function parse (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, false);\n  context.addAll(dom, null, options.from, options.to);\n  return context.finish()\n};\n\n// :: (dom.Node, ?ParseOptions)  Slice\n// Parses the content of the given DOM node, like\n// [`parse`](#model.DOMParser.parse), and takes the same set of\n// options. But unlike that method, which produces a whole node,\n// this one returns a slice that is open at the sides, meaning that\n// the schema constraints aren't applied to the start of nodes to\n// the left of the input and the end of nodes at the end.\nDOMParser.prototype.parseSlice = function parseSlice (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, true);\n  context.addAll(dom, null, options.from, options.to);\n  return Slice.maxOpen(context.finish())\n};\n\nDOMParser.prototype.matchTag = function matchTag (dom, context, after) {\n  for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n    var rule = this.tags[i];\n    if (matches(dom, rule.tag) &&\n        (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n        (!rule.context || context.matchesContext(rule.context))) {\n      if (rule.getAttrs) {\n        var result = rule.getAttrs(dom);\n        if (result === false) { continue }\n        rule.attrs = result;\n      }\n      return rule\n    }\n  }\n};\n\nDOMParser.prototype.matchStyle = function matchStyle (prop, value, context, after) {\n  for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n    var rule = this.styles[i];\n    if (rule.style.indexOf(prop) != 0 ||\n        rule.context && !context.matchesContext(rule.context) ||\n        // Test that the style string either precisely matches the prop,\n        // or has an '=' sign after the prop, followed by the given\n        // value.\n        rule.style.length > prop.length &&\n        (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n      { continue }\n    if (rule.getAttrs) {\n      var result = rule.getAttrs(value);\n      if (result === false) { continue }\n      rule.attrs = result;\n    }\n    return rule\n  }\n};\n\n// : (Schema)  [ParseRule]\nDOMParser.schemaRules = function schemaRules (schema) {\n  var result = [];\n  function insert(rule) {\n    var priority = rule.priority == null ? 50 : rule.priority, i = 0;\n    for (; i < result.length; i++) {\n      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n      if (nextPriority < priority) { break }\n    }\n    result.splice(i, 0, rule);\n  }\n\n  var loop = function ( name ) {\n    var rules = schema.marks[name].spec.parseDOM;\n    if (rules) { rules.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.mark = name;\n    }); }\n  };\n\n    for (var name in schema.marks) loop( name );\n  var loop$1 = function ( name ) {\n    var rules$1 = schema.nodes[name$1].spec.parseDOM;\n    if (rules$1) { rules$1.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.node = name$1;\n    }); }\n  };\n\n    for (var name$1 in schema.nodes) loop$1();\n  return result\n};\n\n// :: (Schema)  DOMParser\n// Construct a DOM parser using the parsing rules listed in a\n// schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n// [priority](#model.ParseRule.priority).\nDOMParser.fromSchema = function fromSchema (schema) {\n  return schema.cached.domParser ||\n    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n};\n\n// : Object<bool> The block-level tags in HTML5\nvar blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\n\n// : Object<bool> The tags that we normally ignore.\nvar ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n};\n\n// : Object<bool> List tags.\nvar listTags = {ol: true, ul: true};\n\n// Using a bitfield for node context options\nvar OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n}\n\nvar NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {\n  this.type = type;\n  this.attrs = attrs;\n  this.solid = solid;\n  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  this.options = options;\n  this.content = [];\n  // Marks applied to this node itself\n  this.marks = marks;\n  // Marks applied to its children\n  this.activeMarks = Mark.none;\n  // Marks that can't apply here, but will be used in children if possible\n  this.pendingMarks = pendingMarks;\n  // Nested Marks with same type\n  this.stashMarks = [];\n};\n\nNodeContext.prototype.findWrapping = function findWrapping (node) {\n  if (!this.match) {\n    if (!this.type) { return [] }\n    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n    if (fill) {\n      this.match = this.type.contentMatch.matchFragment(fill);\n    } else {\n      var start = this.type.contentMatch, wrap;\n      if (wrap = start.findWrapping(node.type)) {\n        this.match = start;\n        return wrap\n      } else {\n        return null\n      }\n    }\n  }\n  return this.match.findWrapping(node.type)\n};\n\nNodeContext.prototype.finish = function finish (openEnd) {\n  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n    var last = this.content[this.content.length - 1], m;\n    if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n      if (last.text.length == m[0].length) { this.content.pop(); }\n      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }\n    }\n  }\n  var content = Fragment.from(this.content);\n  if (!openEnd && this.match)\n    { content = content.append(this.match.fillBefore(Fragment.empty, true)); }\n  return this.type ? this.type.create(this.attrs, content, this.marks) : content\n};\n\nNodeContext.prototype.popFromStashMark = function popFromStashMark (mark) {\n  for (var i = this.stashMarks.length - 1; i >= 0; i--)\n    { if (mark.eq(this.stashMarks[i])) { return this.stashMarks.splice(i, 1)[0] } }\n};\n\nNodeContext.prototype.applyPending = function applyPending (nextType) {\n  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n    var mark = pending[i];\n    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n        !mark.isInSet(this.activeMarks)) {\n      this.activeMarks = mark.addToSet(this.activeMarks);\n      this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n    }\n  }\n};\n\nNodeContext.prototype.inlineContext = function inlineContext (node) {\n  if (this.type) { return this.type.inlineContent }\n  if (this.content.length) { return this.content[0].isInline }\n  return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())\n};\n\nvar ParseContext = function ParseContext(parser, options, open) {\n  // : DOMParser The parser we are using.\n  this.parser = parser;\n  // : Object The options passed to this parse.\n  this.options = options;\n  this.isOpen = open;\n  var topNode = options.topNode, topContext;\n  var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);\n  if (topNode)\n    { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                 options.topMatch || topNode.type.contentMatch, topOptions); }\n  else if (open)\n    { topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions); }\n  else\n    { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions); }\n  this.nodes = [topContext];\n  // : [Mark] The current set of marks\n  this.open = 0;\n  this.find = options.findPositions;\n  this.needsBlock = false;\n};\n\nvar prototypeAccessors$6 = { top: { configurable: true },currentPos: { configurable: true } };\n\nprototypeAccessors$6.top.get = function () {\n  return this.nodes[this.open]\n};\n\n// : (dom.Node)\n// Add a DOM node to the content. Text is inserted as text node,\n// otherwise, the node is passed to `addElement` or, if it has a\n// `style` attribute, `addElementWithStyles`.\nParseContext.prototype.addDOM = function addDOM (dom) {\n  if (dom.nodeType == 3) {\n    this.addTextNode(dom);\n  } else if (dom.nodeType == 1) {\n    var style = dom.getAttribute(\"style\");\n    var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;\n    if (marks != null) { for (var i = 0; i < marks.length; i++) { this.addPendingMark(marks[i]); } }\n    this.addElement(dom);\n    if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this.removePendingMark(marks[i$1], top); } }\n  }\n};\n\nParseContext.prototype.addTextNode = function addTextNode (dom) {\n  var value = dom.nodeValue;\n  var top = this.top;\n  if (top.options & OPT_PRESERVE_WS_FULL ||\n      top.inlineContext(dom) ||\n      /[^ \\t\\r\\n\\u000c]/.test(value)) {\n    if (!(top.options & OPT_PRESERVE_WS)) {\n      value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n      // If this starts with whitespace, and there is no node before it, or\n      // a hard break, or a text node that ends with whitespace, strip the\n      // leading space.\n      if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n        var nodeBefore = top.content[top.content.length - 1];\n        var domNodeBefore = dom.previousSibling;\n        if (!nodeBefore ||\n            (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n            (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n          { value = value.slice(1); }\n      }\n    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n      value = value.replace(/\\r?\\n|\\r/g, \" \");\n    } else {\n      value = value.replace(/\\r\\n?/g, \"\\n\");\n    }\n    if (value) { this.insertNode(this.parser.schema.text(value)); }\n    this.findInText(dom);\n  } else {\n    this.findInside(dom);\n  }\n};\n\n// : (dom.Element, ?ParseRule)\n// Try to find a handler for the given tag and use that to parse. If\n// none is found, the element's content nodes are added directly.\nParseContext.prototype.addElement = function addElement (dom, matchAfter) {\n  var name = dom.nodeName.toLowerCase(), ruleID;\n  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) { normalizeList(dom); }\n  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n      (ruleID = this.parser.matchTag(dom, this, matchAfter));\n  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n    this.findInside(dom);\n    this.ignoreFallback(dom);\n  } else if (!rule || rule.skip || rule.closeParent) {\n    if (rule && rule.closeParent) { this.open = Math.max(0, this.open - 1); }\n    else if (rule && rule.skip.nodeType) { dom = rule.skip; }\n    var sync, top = this.top, oldNeedsBlock = this.needsBlock;\n    if (blockTags.hasOwnProperty(name)) {\n      sync = true;\n      if (!top.type) { this.needsBlock = true; }\n    } else if (!dom.firstChild) {\n      this.leafFallback(dom);\n      return\n    }\n    this.addAll(dom);\n    if (sync) { this.sync(top); }\n    this.needsBlock = oldNeedsBlock;\n  } else {\n    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);\n  }\n};\n\n// Called for leaf DOM nodes that would otherwise be ignored\nParseContext.prototype.leafFallback = function leafFallback (dom) {\n  if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n    { this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\")); }\n};\n\n// Called for ignored nodes\nParseContext.prototype.ignoreFallback = function ignoreFallback (dom) {\n  // Ignored BR nodes should at least create an inline context\n  if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n    { this.findPlace(this.parser.schema.text(\"-\")); }\n};\n\n// Run any style parser associated with the node's styles. Either\n// return an array of marks, or null to indicate some of the styles\n// had a rule with `ignore` set.\nParseContext.prototype.readStyles = function readStyles (styles) {\n  var marks = Mark.none;\n  style: for (var i = 0; i < styles.length; i += 2) {\n    for (var after = null;;) {\n      var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n      if (!rule) { continue style }\n      if (rule.ignore) { return null }\n      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n      if (rule.consuming === false) { after = rule; }\n      else { break }\n    }\n  }\n  return marks\n};\n\n// : (dom.Element, ParseRule)  bool\n// Look up a handler for the given node. If none are found, return\n// false. Otherwise, apply it, use its return value to drive the way\n// the node's content is wrapped, and return true.\nParseContext.prototype.addElementByRule = function addElementByRule (dom, rule, continueAfter) {\n    var this$1 = this;\n\n  var sync, nodeType, markType, mark;\n  if (rule.node) {\n    nodeType = this.parser.schema.nodes[rule.node];\n    if (!nodeType.isLeaf) {\n      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);\n    } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n      this.leafFallback(dom);\n    }\n  } else {\n    markType = this.parser.schema.marks[rule.mark];\n    mark = markType.create(rule.attrs);\n    this.addPendingMark(mark);\n  }\n  var startIn = this.top;\n\n  if (nodeType && nodeType.isLeaf) {\n    this.findInside(dom);\n  } else if (continueAfter) {\n    this.addElement(dom, continueAfter);\n  } else if (rule.getContent) {\n    this.findInside(dom);\n    rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1.insertNode(node); });\n  } else {\n    var contentDOM = rule.contentElement;\n    if (typeof contentDOM == \"string\") { contentDOM = dom.querySelector(contentDOM); }\n    else if (typeof contentDOM == \"function\") { contentDOM = contentDOM(dom); }\n    if (!contentDOM) { contentDOM = dom; }\n    this.findAround(dom, contentDOM, true);\n    this.addAll(contentDOM, sync);\n  }\n  if (sync) { this.sync(startIn); this.open--; }\n  if (mark) { this.removePendingMark(mark, startIn); }\n};\n\n// : (dom.Node, ?NodeBuilder, ?number, ?number)\n// Add all child nodes between `startIndex` and `endIndex` (or the\n// whole node, if not given). If `sync` is passed, use it to\n// synchronize after every block element.\nParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {\n  var index = startIndex || 0;\n  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n           end = endIndex == null ? null : parent.childNodes[endIndex];\n       dom != end; dom = dom.nextSibling, ++index) {\n    this.findAtPoint(parent, index);\n    this.addDOM(dom);\n    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n      { this.sync(sync); }\n  }\n  this.findAtPoint(parent, index);\n};\n\n// Try to find a way to fit the given node type into the current\n// context. May add intermediate wrappers and/or leave non-solid\n// nodes that we're in.\nParseContext.prototype.findPlace = function findPlace (node) {\n  var route, sync;\n  for (var depth = this.open; depth >= 0; depth--) {\n    var cx = this.nodes[depth];\n    var found = cx.findWrapping(node);\n    if (found && (!route || route.length > found.length)) {\n      route = found;\n      sync = cx;\n      if (!found.length) { break }\n    }\n    if (cx.solid) { break }\n  }\n  if (!route) { return false }\n  this.sync(sync);\n  for (var i = 0; i < route.length; i++)\n    { this.enterInner(route[i], null, false); }\n  return true\n};\n\n// : (Node)  ?Node\n// Try to insert the given node, adjusting the context when needed.\nParseContext.prototype.insertNode = function insertNode (node) {\n  if (node.isInline && this.needsBlock && !this.top.type) {\n    var block = this.textblockFromContext();\n    if (block) { this.enterInner(block); }\n  }\n  if (this.findPlace(node)) {\n    this.closeExtra();\n    var top = this.top;\n    top.applyPending(node.type);\n    if (top.match) { top.match = top.match.matchType(node.type); }\n    var marks = top.activeMarks;\n    for (var i = 0; i < node.marks.length; i++)\n      { if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n        { marks = node.marks[i].addToSet(marks); } }\n    top.content.push(node.mark(marks));\n    return true\n  }\n  return false\n};\n\n// : (NodeType, ?Object)  bool\n// Try to start a node of the given type, adjusting the context when\n// necessary.\nParseContext.prototype.enter = function enter (type, attrs, preserveWS) {\n  var ok = this.findPlace(type.create(attrs));\n  if (ok) { this.enterInner(type, attrs, true, preserveWS); }\n  return ok\n};\n\n// Open a node of the given type\nParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {\n  this.closeExtra();\n  var top = this.top;\n  top.applyPending(type);\n  top.match = top.match && top.match.matchType(type, attrs);\n  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);\n  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }\n  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n  this.open++;\n};\n\n// Make sure all nodes above this.open are finished and added to\n// their parents\nParseContext.prototype.closeExtra = function closeExtra (openEnd) {\n  var i = this.nodes.length - 1;\n  if (i > this.open) {\n    for (; i > this.open; i--) { this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd)); }\n    this.nodes.length = this.open + 1;\n  }\n};\n\nParseContext.prototype.finish = function finish () {\n  this.open = 0;\n  this.closeExtra(this.isOpen);\n  return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n};\n\nParseContext.prototype.sync = function sync (to) {\n  for (var i = this.open; i >= 0; i--) { if (this.nodes[i] == to) {\n    this.open = i;\n    return\n  } }\n};\n\nprototypeAccessors$6.currentPos.get = function () {\n  this.closeExtra();\n  var pos = 0;\n  for (var i = this.open; i >= 0; i--) {\n    var content = this.nodes[i].content;\n    for (var j = content.length - 1; j >= 0; j--)\n      { pos += content[j].nodeSize; }\n    if (i) { pos++; }\n  }\n  return pos\n};\n\nParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == parent && this.find[i].offset == offset)\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findInside = function findInside (parent) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findAround = function findAround (parent, content, before) {\n  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n      var pos = content.compareDocumentPosition(this.find[i].node);\n      if (pos & (before ? 2 : 4))\n        { this.find[i].pos = this.currentPos; }\n    }\n  } }\n};\n\nParseContext.prototype.findInText = function findInText (textNode) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == textNode)\n      { this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset); }\n  } }\n};\n\n// : (string)  bool\n// Determines whether the given [context\n// string](#ParseRule.context) matches this context.\nParseContext.prototype.matchesContext = function matchesContext (context) {\n    var this$1 = this;\n\n  if (context.indexOf(\"|\") > -1)\n    { return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this) }\n\n  var parts = context.split(\"/\");\n  var option = this.options.context;\n  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n  var match = function (i, depth) {\n    for (; i >= 0; i--) {\n      var part = parts[i];\n      if (part == \"\") {\n        if (i == parts.length - 1 || i == 0) { continue }\n        for (; depth >= minDepth; depth--)\n          { if (match(i - 1, depth)) { return true } }\n        return false\n      } else {\n        var next = depth > 0 || (depth == 0 && useRoot) ? this$1.nodes[depth].type\n            : option && depth >= minDepth ? option.node(depth - minDepth).type\n            : null;\n        if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n          { return false }\n        depth--;\n      }\n    }\n    return true\n  };\n  return match(parts.length - 1, this.open)\n};\n\nParseContext.prototype.textblockFromContext = function textblockFromContext () {\n  var $context = this.options.context;\n  if ($context) { for (var d = $context.depth; d >= 0; d--) {\n    var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n    if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }\n  } }\n  for (var name in this.parser.schema.nodes) {\n    var type = this.parser.schema.nodes[name];\n    if (type.isTextblock && type.defaultAttrs) { return type }\n  }\n};\n\nParseContext.prototype.addPendingMark = function addPendingMark (mark) {\n  var found = findSameMarkInSet(mark, this.top.pendingMarks);\n  if (found) { this.top.stashMarks.push(found); }\n  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n};\n\nParseContext.prototype.removePendingMark = function removePendingMark (mark, upto) {\n  for (var depth = this.open; depth >= 0; depth--) {\n    var level = this.nodes[depth];\n    var found = level.pendingMarks.lastIndexOf(mark);\n    if (found > -1) {\n      level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n    } else {\n      level.activeMarks = mark.removeFromSet(level.activeMarks);\n      var stashMark = level.popFromStashMark(mark);\n      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n        { level.activeMarks = stashMark.addToSet(level.activeMarks); }\n    }\n    if (level == upto) { break }\n  }\n};\n\nObject.defineProperties( ParseContext.prototype, prototypeAccessors$6 );\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string)  [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = [];\n  while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }\n  return result\n}\n\nfunction copy(obj) {\n  var copy = {};\n  for (var prop in obj) { copy[prop] = obj[prop]; }\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n  var loop = function ( name ) {\n    var parent = nodes[name];\n    if (!parent.allowsMarkType(markType)) { return }\n    var seen = [], scan = function (match) {\n      seen.push(match);\n      for (var i = 0; i < match.edgeCount; i++) {\n        var ref = match.edge(i);\n        var type = ref.type;\n        var next = ref.next;\n        if (type == nodeType) { return true }\n        if (seen.indexOf(next) < 0 && scan(next)) { return true }\n      }\n    };\n    if (scan(parent.contentMatch)) { return { v: true } }\n  };\n\n  for (var name in nodes) {\n    var returned = loop( name );\n\n    if ( returned ) return returned.v;\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (var i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) { return set[i] }\n  }\n}\n\n// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a stringthe name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced hole) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nvar DOMSerializer = function DOMSerializer(nodes, marks) {\n  // :: Object<(node: Node)  DOMOutputSpec>\n  // The node serialization functions.\n  this.nodes = nodes || {};\n  // :: Object<?(mark: Mark, inline: bool)  DOMOutputSpec>\n  // The mark serialization functions.\n  this.marks = marks || {};\n};\n\n// :: (Fragment, ?Object)  dom.DocumentFragment\n// Serialize the content of this fragment to a DOM fragment. When\n// not in the browser, the `document` option, containing a DOM\n// document, should be passed so that the serializer can create\n// nodes.\nDOMSerializer.prototype.serializeFragment = function serializeFragment (fragment, options, target) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n  if (!target) { target = doc(options).createDocumentFragment(); }\n\n  var top = target, active = null;\n  fragment.forEach(function (node) {\n    if (active || node.marks.length) {\n      if (!active) { active = []; }\n      var keep = 0, rendered = 0;\n      while (keep < active.length && rendered < node.marks.length) {\n        var next = node.marks[rendered];\n        if (!this$1.marks[next.type.name]) { rendered++; continue }\n        if (!next.eq(active[keep]) || next.type.spec.spanning === false) { break }\n        keep += 2; rendered++;\n      }\n      while (keep < active.length) {\n        top = active.pop();\n        active.pop();\n      }\n      while (rendered < node.marks.length) {\n        var add = node.marks[rendered++];\n        var markDOM = this$1.serializeMark(add, node.isInline, options);\n        if (markDOM) {\n          active.push(add, top);\n          top.appendChild(markDOM.dom);\n          top = markDOM.contentDOM || markDOM.dom;\n        }\n      }\n    }\n    top.appendChild(this$1.serializeNodeInner(node, options));\n  });\n\n  return target\n};\n\nDOMSerializer.prototype.serializeNodeInner = function serializeNodeInner (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var ref =\n      DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n    var dom = ref.dom;\n    var contentDOM = ref.contentDOM;\n  if (contentDOM) {\n    if (node.isLeaf)\n      { throw new RangeError(\"Content hole not allowed in a leaf node spec\") }\n    if (options.onContent)\n      { options.onContent(node, contentDOM, options); }\n    else\n      { this.serializeFragment(node.content, options, contentDOM); }\n  }\n  return dom\n};\n\n// :: (Node, ?Object)  dom.Node\n// Serialize this node to a DOM node. This can be useful when you\n// need to serialize a part of a document, as opposed to the whole\n// document. To serialize a whole document, use\n// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n// its [content](#model.Node.content).\nDOMSerializer.prototype.serializeNode = function serializeNode (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var dom = this.serializeNodeInner(node, options);\n  for (var i = node.marks.length - 1; i >= 0; i--) {\n    var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n    if (wrap) {\n(wrap.contentDOM || wrap.dom).appendChild(dom);\n      dom = wrap.dom;\n    }\n  }\n  return dom\n};\n\nDOMSerializer.prototype.serializeMark = function serializeMark (mark, inline, options) {\n    if ( options === void 0 ) options = {};\n\n  var toDOM = this.marks[mark.type.name];\n  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n};\n\n// :: (dom.Document, DOMOutputSpec)  {dom: dom.Node, contentDOM: ?dom.Node}\n// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n// the spec has a hole (zero) in it, `contentDOM` will point at the\n// node with the hole.\nDOMSerializer.renderSpec = function renderSpec (doc, structure, xmlNS) {\n    if ( xmlNS === void 0 ) xmlNS = null;\n\n  if (typeof structure == \"string\")\n    { return {dom: doc.createTextNode(structure)} }\n  if (structure.nodeType != null)\n    { return {dom: structure} }\n  if (structure.dom && structure.dom.nodeType != null)\n    { return structure }\n  var tagName = structure[0], space = tagName.indexOf(\" \");\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n  var contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n  var attrs = structure[1], start = 1;\n  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n    for (var name in attrs) { if (attrs[name] != null) {\n      var space$1 = name.indexOf(\" \");\n      if (space$1 > 0) { dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]); }\n      else { dom.setAttribute(name, attrs[name]); }\n    } }\n  }\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start)\n        { throw new RangeError(\"Content hole must be the only child of its parent node\") }\n      return {dom: dom, contentDOM: dom}\n    } else {\n      var ref = DOMSerializer.renderSpec(doc, child, xmlNS);\n        var inner = ref.dom;\n        var innerContent = ref.contentDOM;\n      dom.appendChild(inner);\n      if (innerContent) {\n        if (contentDOM) { throw new RangeError(\"Multiple content holes\") }\n        contentDOM = innerContent;\n      }\n    }\n  }\n  return {dom: dom, contentDOM: contentDOM}\n};\n\n// :: (Schema)  DOMSerializer\n// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n// properties in a schema's node and mark specs.\nDOMSerializer.fromSchema = function fromSchema (schema) {\n  return schema.cached.domSerializer ||\n    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n};\n\n// : (Schema)  Object<(node: Node)  DOMOutputSpec>\n// Gather the serializers in a schema's node specs into an object.\n// This can be useful as a base to build a custom serializer from.\nDOMSerializer.nodesFromSchema = function nodesFromSchema (schema) {\n  var result = gatherToDOM(schema.nodes);\n  if (!result.text) { result.text = function (node) { return node.text; }; }\n  return result\n};\n\n// : (Schema)  Object<(mark: Mark)  DOMOutputSpec>\n// Gather the serializers in a schema's mark specs into an object.\nDOMSerializer.marksFromSchema = function marksFromSchema (schema) {\n  return gatherToDOM(schema.marks)\n};\n\nfunction gatherToDOM(obj) {\n  var result = {};\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n    if (toDOM) { result[name] = toDOM; }\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n\nexport { ContentMatch, DOMParser, DOMSerializer, Fragment, Mark, MarkType, Node, NodeRange, NodeType, ReplaceError, ResolvedPos, Schema, Slice };\n//# sourceMappingURL=index.es.js.map\n","/*\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <elfz@laacz.lv>\n    http://jsbeautifier.org/\n\n\n  You are free to use this in any way you want, in case you find this useful or working for you.\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_size (default 4)           indentation size,\n    indent_char (default space)       character to indent with,\n    max_char (default 70)            -  maximum amount of characters per line,\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_size': 2,\n      'indent_char': ' ',\n      'max_char': 78,\n      'brace_style': 'expand',\n      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u']\n    });\n*/\n\nfunction style_html(html_source, options) {\n//Wrapper function to invoke all the necessary constructors and deal with the output.\n\n  var multi_parser,\n      indent_size,\n      indent_character,\n      max_char,\n      brace_style,\n      unformatted;\n\n  options = options || {};\n  indent_size = options.indent_size || 4;\n  indent_character = options.indent_char || ' ';\n  brace_style = options.brace_style || 'collapse';\n  max_char = options.max_char == 0 ? Infinity : options.max_char || 70;\n  unformatted = options.unformatted || ['a', 'span', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n\n  function Parser() {\n\n    this.pos = 0; //Parser position\n    this.token = '';\n    this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT\n    this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values\n      parent: 'parent1',\n      parentcount: 1,\n      parent1: ''\n    };\n    this.tag_type = '';\n    this.token_text = this.last_token = this.last_text = this.token_type = '';\n\n    this.Utils = { //Uilities made available to the various functions\n      whitespace: \"\\n\\r\\t \".split(''),\n      single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML\n      extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them\n      in_array: function (what, arr) {\n        for (var i=0; i<arr.length; i++) {\n          if (what === arr[i]) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }\n\n    this.get_content = function () { //function to capture regular content between tags\n\n      var input_char = '',\n          content = [],\n          space = false; //if a space is needed\n\n      while (this.input.charAt(this.pos) !== '<') {\n        if (this.pos >= this.input.length) {\n          return content.length?content.join(''):['', 'TK_EOF'];\n        }\n\n        input_char = this.input.charAt(this.pos);\n        this.pos++;\n        this.line_char_count++;\n\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n          if (content.length) {\n            space = true;\n          }\n          this.line_char_count--;\n          continue; //don't want to insert unnecessary space\n        }\n        else if (space) {\n          if (this.line_char_count >= this.max_char) { //insert a line when the max_char is reached\n            content.push('\\n');\n            for (var i=0; i<this.indent_level; i++) {\n              content.push(this.indent_string);\n            }\n            this.line_char_count = 0;\n          }\n          else{\n            content.push(' ');\n            this.line_char_count++;\n          }\n          space = false;\n        }\n        content.push(input_char); //letter at-a-time (or string) inserted to an array\n      }\n      return content.length?content.join(''):'';\n    }\n\n    this.get_contents_to = function (name) { //get the full content of a script or style to pass to js_beautify\n      if (this.pos == this.input.length) {\n        return ['', 'TK_EOF'];\n      }\n      var input_char = '';\n      var content = '';\n      var reg_match = new RegExp('\\<\\/' + name + '\\\\s*\\>', 'igm');\n      reg_match.lastIndex = this.pos;\n      var reg_array = reg_match.exec(this.input);\n      var end_script = reg_array?reg_array.index:this.input.length; //absolute end of script\n      if(this.pos < end_script) { //get everything in between the script tags\n        content = this.input.substring(this.pos, end_script);\n        this.pos = end_script;\n      }\n      return content;\n    }\n\n    this.record_tag = function (tag){ //function to record a tag and its parent in this.tags Object\n      if (this.tags[tag + 'count']) { //check for the existence of this tag type\n        this.tags[tag + 'count']++;\n        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n      }\n      else { //otherwise initialize this tag type\n        this.tags[tag + 'count'] = 1;\n        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n      }\n      this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)\n      this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')\n    }\n\n    this.retrieve_tag = function (tag) { //function to retrieve the opening tag to the corresponding closer\n      if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it\n        var temp_parent = this.tags.parent; //check to see if it's a closable tag.\n        while (temp_parent) { //till we reach '' (the initial value);\n          if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it\n            break;\n          }\n          temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree\n        }\n        if (temp_parent) { //if we caught something\n          this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly\n          this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent\n        }\n        delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...\n        delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself\n        if (this.tags[tag + 'count'] == 1) {\n          delete this.tags[tag + 'count'];\n        }\n        else {\n          this.tags[tag + 'count']--;\n        }\n      }\n    }\n\n    this.get_tag = function () { //function to get a full tag and parse its type\n      var input_char = '',\n          content = [],\n          space = false,\n          tag_start, tag_end;\n\n      do {\n        if (this.pos >= this.input.length) {\n          return content.length?content.join(''):['', 'TK_EOF'];\n        }\n\n        input_char = this.input.charAt(this.pos);\n        this.pos++;\n        this.line_char_count++;\n\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space\n          space = true;\n          this.line_char_count--;\n          continue;\n        }\n\n        if (input_char === \"'\" || input_char === '\"') {\n          if (!content[1] || content[1] !== '!') { //if we're in a comment strings don't get treated specially\n            input_char += this.get_unformatted(input_char);\n            space = true;\n          }\n        }\n\n        if (input_char === '=') { //no space before =\n          space = false;\n        }\n\n        if (content.length && content[content.length-1] !== '=' && input_char !== '>'\n            && space) { //no space after = or before >\n          if (this.line_char_count >= this.max_char) {\n            this.print_newline(false, content);\n            this.line_char_count = 0;\n          }\n          else {\n            content.push(' ');\n            this.line_char_count++;\n          }\n          space = false;\n        }\n        if (input_char === '<') {\n            tag_start = this.pos - 1;\n        }\n        content.push(input_char); //inserts character at-a-time (or string)\n      } while (input_char !== '>');\n\n      var tag_complete = content.join('');\n      var tag_index;\n      if (tag_complete.indexOf(' ') != -1) { //if there's whitespace, thats where the tag name ends\n        tag_index = tag_complete.indexOf(' ');\n      }\n      else { //otherwise go with the tag ending\n        tag_index = tag_complete.indexOf('>');\n      }\n      var tag_check = tag_complete.substring(1, tag_index).toLowerCase();\n      if (tag_complete.charAt(tag_complete.length-2) === '/' ||\n          this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)\n        this.tag_type = 'SINGLE';\n      }\n      else if (tag_check === 'script') { //for later script handling\n        this.record_tag(tag_check);\n        this.tag_type = 'SCRIPT';\n      }\n      else if (tag_check === 'style') { //for future style handling (for now it justs uses get_content)\n        this.record_tag(tag_check);\n        this.tag_type = 'STYLE';\n      }\n      else if (this.Utils.in_array(tag_check, unformatted)) { // do not reformat the \"unformatted\" tags\n        var comment = this.get_unformatted('</'+tag_check+'>', tag_complete); //...delegate to get_unformatted function\n        content.push(comment);\n        // Preserve collapsed whitespace either before or after this tag.\n        if (tag_start > 0 && this.Utils.in_array(this.input.charAt(tag_start - 1), this.Utils.whitespace)){\n            content.splice(0, 0, this.input.charAt(tag_start - 1));\n        }\n        tag_end = this.pos - 1;\n        if (this.Utils.in_array(this.input.charAt(tag_end + 1), this.Utils.whitespace)){\n            content.push(this.input.charAt(tag_end + 1));\n        }\n        this.tag_type = 'SINGLE';\n      }\n      else if (tag_check.charAt(0) === '!') { //peek for <!-- comment\n        if (tag_check.indexOf('[if') != -1) { //peek for <!--[if conditional comment\n          if (tag_complete.indexOf('!IE') != -1) { //this type needs a closing --> so...\n            var comment = this.get_unformatted('-->', tag_complete); //...delegate to get_unformatted\n            content.push(comment);\n          }\n          this.tag_type = 'START';\n        }\n        else if (tag_check.indexOf('[endif') != -1) {//peek for <!--[endif end conditional comment\n          this.tag_type = 'END';\n          this.unindent();\n        }\n        else if (tag_check.indexOf('[cdata[') != -1) { //if it's a <[cdata[ comment...\n          var comment = this.get_unformatted(']]>', tag_complete); //...delegate to get_unformatted function\n          content.push(comment);\n          this.tag_type = 'SINGLE'; //<![CDATA[ comments are treated like single tags\n        }\n        else {\n          var comment = this.get_unformatted('-->', tag_complete);\n          content.push(comment);\n          this.tag_type = 'SINGLE';\n        }\n      }\n      else {\n        if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending\n          this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors\n          this.tag_type = 'END';\n        }\n        else { //otherwise it's a start-tag\n          this.record_tag(tag_check); //push it on the tag stack\n          this.tag_type = 'START';\n        }\n        if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line\n          this.print_newline(true, this.output);\n        }\n      }\n      return content.join(''); //returns fully formatted tag\n    }\n\n    this.get_unformatted = function (delimiter, orig_tag) { //function to return unformatted content in its entirety\n\n      if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) != -1) {\n        return '';\n      }\n      var input_char = '';\n      var content = '';\n      var space = true;\n      do {\n\n        if (this.pos >= this.input.length) {\n          return content;\n        }\n\n        input_char = this.input.charAt(this.pos);\n        this.pos++\n\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n          if (!space) {\n            this.line_char_count--;\n            continue;\n          }\n          if (input_char === '\\n' || input_char === '\\r') {\n            content += '\\n';\n            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'\n            for (var i=0; i<this.indent_level; i++) {\n              content += this.indent_string;\n            }\n            space = false; //...and make sure other indentation is erased\n            */\n            this.line_char_count = 0;\n            continue;\n          }\n        }\n        content += input_char;\n        this.line_char_count++;\n        space = true;\n\n\n      } while (content.toLowerCase().indexOf(delimiter) == -1);\n      return content;\n    }\n\n    this.get_token = function () { //initial handler for token-retrieval\n      var token;\n\n      if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript\n       var type = this.last_token.substr(7)\n       token = this.get_contents_to(type);\n        if (typeof token !== 'string') {\n          return token;\n        }\n        return [token, 'TK_' + type];\n      }\n      if (this.current_mode === 'CONTENT') {\n        token = this.get_content();\n        if (typeof token !== 'string') {\n          return token;\n        }\n        else {\n          return [token, 'TK_CONTENT'];\n        }\n      }\n\n      if (this.current_mode === 'TAG') {\n        token = this.get_tag();\n        if (typeof token !== 'string') {\n          return token;\n        }\n        else {\n          var tag_name_type = 'TK_TAG_' + this.tag_type;\n          return [token, tag_name_type];\n        }\n      }\n    }\n\n    this.get_full_indent = function (level) {\n      level = this.indent_level + level || 0;\n      if (level < 1)\n        return '';\n\n      return Array(level + 1).join(this.indent_string);\n    }\n\n\n    this.printer = function (js_source, indent_character, indent_size, max_char, brace_style) { //handles input/output and some other printing functions\n\n      this.input = js_source || ''; //gets the input for the Parser\n      this.output = [];\n      this.indent_character = indent_character;\n      this.indent_string = '';\n      this.indent_size = indent_size;\n      this.brace_style = brace_style;\n      this.indent_level = 0;\n      this.max_char = max_char;\n      this.line_char_count = 0; //count to see if max_char was exceeded\n\n      for (var i=0; i<this.indent_size; i++) {\n        this.indent_string += this.indent_character;\n      }\n\n      this.print_newline = function (ignore, arr) {\n        this.line_char_count = 0;\n        if (!arr || !arr.length) {\n          return;\n        }\n        if (!ignore) { //we might want the extra line\n          while (this.Utils.in_array(arr[arr.length-1], this.Utils.whitespace)) {\n            arr.pop();\n          }\n        }\n        arr.push('\\n');\n        for (var i=0; i<this.indent_level; i++) {\n          arr.push(this.indent_string);\n        }\n      }\n\n      this.print_token = function (text) {\n        this.output.push(text);\n      }\n\n      this.indent = function () {\n        this.indent_level++;\n      }\n\n      this.unindent = function () {\n        if (this.indent_level > 0) {\n          this.indent_level--;\n        }\n      }\n    }\n    return this;\n  }\n\n  /*_____________________--------------------_____________________*/\n\n  multi_parser = new Parser(); //wrapping functions Parser\n  multi_parser.printer(html_source, indent_character, indent_size, max_char, brace_style); //initialize starting values\n\n  while (true) {\n      var t = multi_parser.get_token();\n      multi_parser.token_text = t[0];\n      multi_parser.token_type = t[1];\n\n    if (multi_parser.token_type === 'TK_EOF') {\n      break;\n    }\n\n    switch (multi_parser.token_type) {\n      case 'TK_TAG_START':\n        multi_parser.print_newline(false, multi_parser.output);\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.indent();\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_TAG_STYLE':\n      case 'TK_TAG_SCRIPT':\n        multi_parser.print_newline(false, multi_parser.output);\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_TAG_END':\n        //Print new line only if the tag has no content and has child\n        if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {\n            var tag_name = multi_parser.token_text.match(/\\w+/)[0];\n            var tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length -1].match(/<\\s*(\\w+)/);\n            if (tag_extracted_from_last_output === null || tag_extracted_from_last_output[1] !== tag_name)\n                multi_parser.print_newline(true, multi_parser.output);\n        }\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_TAG_SINGLE':\n        // Don't add a newline before elements that should remain unformatted.\n        var tag_check = multi_parser.token_text.match(/^\\s*<([a-z]+)/i);\n        if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)){\n            multi_parser.print_newline(false, multi_parser.output);\n        }\n        multi_parser.print_token(multi_parser.token_text);\n        multi_parser.current_mode = 'CONTENT';\n        break;\n      case 'TK_CONTENT':\n        if (multi_parser.token_text !== '') {\n          multi_parser.print_token(multi_parser.token_text);\n        }\n        multi_parser.current_mode = 'TAG';\n        break;\n      case 'TK_STYLE':\n      case 'TK_SCRIPT':\n        if (multi_parser.token_text !== '') {\n          multi_parser.output.push('\\n');\n          var text = multi_parser.token_text;\n          if (multi_parser.token_type == 'TK_SCRIPT') {\n            var _beautifier = typeof js_beautify == 'function' && js_beautify;\n          } else if (multi_parser.token_type == 'TK_STYLE') {\n            var _beautifier = typeof css_beautify == 'function' && css_beautify;\n          }\n\n          if (options.indent_scripts == \"keep\") {\n            var script_indent_level = 0;\n          } else if (options.indent_scripts == \"separate\") {\n            var script_indent_level = -multi_parser.indent_level;\n          } else {\n            var script_indent_level = 1;\n          }\n\n          var indentation = multi_parser.get_full_indent(script_indent_level);\n          if (_beautifier) {\n            // call the Beautifier if avaliable\n            text = _beautifier(text.replace(/^\\s*/, indentation), options);\n          } else {\n            // simply indent the string otherwise\n            var white = text.match(/^\\s*/)[0];\n            var _level = white.match(/[^\\n\\r]*$/)[0].split(multi_parser.indent_string).length - 1;\n            var reindent = multi_parser.get_full_indent(script_indent_level -_level);\n            text = text.replace(/^\\s*/, indentation)\n                   .replace(/\\r\\n|\\r|\\n/g, '\\n' + reindent)\n                   .replace(/\\s*$/, '');\n          }\n          if (text) {\n            multi_parser.print_token(text);\n            multi_parser.print_newline(true, multi_parser.output);\n          }\n        }\n        multi_parser.current_mode = 'TAG';\n        break;\n    }\n    multi_parser.last_token = multi_parser.token_type;\n    multi_parser.last_text = multi_parser.token_text;\n  }\n  return multi_parser.output.join('');\n}\n\nmodule.exports = {\n  prettyPrint: style_html\n};","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('./empty')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', './empty'], factory) :\n\t(factory((global.jsondiffpatch = {}),global.chalk));\n}(this, (function (exports,chalk) { 'use strict';\n\nchalk = chalk && chalk.hasOwnProperty('default') ? chalk['default'] : chalk;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar Processor = function () {\n  function Processor(options) {\n    classCallCheck(this, Processor);\n\n    this.selfOptions = options || {};\n    this.pipes = {};\n  }\n\n  createClass(Processor, [{\n    key: 'options',\n    value: function options(_options) {\n      if (_options) {\n        this.selfOptions = _options;\n      }\n      return this.selfOptions;\n    }\n  }, {\n    key: 'pipe',\n    value: function pipe(name, pipeArg) {\n      var pipe = pipeArg;\n      if (typeof name === 'string') {\n        if (typeof pipe === 'undefined') {\n          return this.pipes[name];\n        } else {\n          this.pipes[name] = pipe;\n        }\n      }\n      if (name && name.name) {\n        pipe = name;\n        if (pipe.processor === this) {\n          return pipe;\n        }\n        this.pipes[pipe.name] = pipe;\n      }\n      pipe.processor = this;\n      return pipe;\n    }\n  }, {\n    key: 'process',\n    value: function process(input, pipe) {\n      var context = input;\n      context.options = this.options();\n      var nextPipe = pipe || input.pipe || 'default';\n      var lastPipe = void 0;\n      var lastContext = void 0;\n      while (nextPipe) {\n        if (typeof context.nextAfterChildren !== 'undefined') {\n          // children processed and coming back to parent\n          context.next = context.nextAfterChildren;\n          context.nextAfterChildren = null;\n        }\n\n        if (typeof nextPipe === 'string') {\n          nextPipe = this.pipe(nextPipe);\n        }\n        nextPipe.process(context);\n        lastContext = context;\n        lastPipe = nextPipe;\n        nextPipe = null;\n        if (context) {\n          if (context.next) {\n            context = context.next;\n            nextPipe = lastContext.nextPipe || context.pipe || lastPipe;\n          }\n        }\n      }\n      return context.hasResult ? context.result : undefined;\n    }\n  }]);\n  return Processor;\n}();\n\nvar Pipe = function () {\n  function Pipe(name) {\n    classCallCheck(this, Pipe);\n\n    this.name = name;\n    this.filters = [];\n  }\n\n  createClass(Pipe, [{\n    key: 'process',\n    value: function process(input) {\n      if (!this.processor) {\n        throw new Error('add this pipe to a processor before using it');\n      }\n      var debug = this.debug;\n      var length = this.filters.length;\n      var context = input;\n      for (var index = 0; index < length; index++) {\n        var filter = this.filters[index];\n        if (debug) {\n          this.log('filter: ' + filter.filterName);\n        }\n        filter(context);\n        if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) === 'object' && context.exiting) {\n          context.exiting = false;\n          break;\n        }\n      }\n      if (!context.next && this.resultCheck) {\n        this.resultCheck(context);\n      }\n    }\n  }, {\n    key: 'log',\n    value: function log(msg) {\n      console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);\n    }\n  }, {\n    key: 'append',\n    value: function append() {\n      var _filters;\n\n      (_filters = this.filters).push.apply(_filters, arguments);\n      return this;\n    }\n  }, {\n    key: 'prepend',\n    value: function prepend() {\n      var _filters2;\n\n      (_filters2 = this.filters).unshift.apply(_filters2, arguments);\n      return this;\n    }\n  }, {\n    key: 'indexOf',\n    value: function indexOf(filterName) {\n      if (!filterName) {\n        throw new Error('a filter name is required');\n      }\n      for (var index = 0; index < this.filters.length; index++) {\n        var filter = this.filters[index];\n        if (filter.filterName === filterName) {\n          return index;\n        }\n      }\n      throw new Error('filter not found: ' + filterName);\n    }\n  }, {\n    key: 'list',\n    value: function list() {\n      return this.filters.map(function (f) {\n        return f.filterName;\n      });\n    }\n  }, {\n    key: 'after',\n    value: function after(filterName) {\n      var index = this.indexOf(filterName);\n      var params = Array.prototype.slice.call(arguments, 1);\n      if (!params.length) {\n        throw new Error('a filter is required');\n      }\n      params.unshift(index + 1, 0);\n      Array.prototype.splice.apply(this.filters, params);\n      return this;\n    }\n  }, {\n    key: 'before',\n    value: function before(filterName) {\n      var index = this.indexOf(filterName);\n      var params = Array.prototype.slice.call(arguments, 1);\n      if (!params.length) {\n        throw new Error('a filter is required');\n      }\n      params.unshift(index, 0);\n      Array.prototype.splice.apply(this.filters, params);\n      return this;\n    }\n  }, {\n    key: 'replace',\n    value: function replace(filterName) {\n      var index = this.indexOf(filterName);\n      var params = Array.prototype.slice.call(arguments, 1);\n      if (!params.length) {\n        throw new Error('a filter is required');\n      }\n      params.unshift(index, 1);\n      Array.prototype.splice.apply(this.filters, params);\n      return this;\n    }\n  }, {\n    key: 'remove',\n    value: function remove(filterName) {\n      var index = this.indexOf(filterName);\n      this.filters.splice(index, 1);\n      return this;\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.filters.length = 0;\n      return this;\n    }\n  }, {\n    key: 'shouldHaveResult',\n    value: function shouldHaveResult(should) {\n      if (should === false) {\n        this.resultCheck = null;\n        return;\n      }\n      if (this.resultCheck) {\n        return;\n      }\n      var pipe = this;\n      this.resultCheck = function (context) {\n        if (!context.hasResult) {\n          console.log(context);\n          var error = new Error(pipe.name + ' failed');\n          error.noResult = true;\n          throw error;\n        }\n      };\n      return this;\n    }\n  }]);\n  return Pipe;\n}();\n\nvar Context = function () {\n  function Context() {\n    classCallCheck(this, Context);\n  }\n\n  createClass(Context, [{\n    key: 'setResult',\n    value: function setResult(result) {\n      this.result = result;\n      this.hasResult = true;\n      return this;\n    }\n  }, {\n    key: 'exit',\n    value: function exit() {\n      this.exiting = true;\n      return this;\n    }\n  }, {\n    key: 'switchTo',\n    value: function switchTo(next, pipe) {\n      if (typeof next === 'string' || next instanceof Pipe) {\n        this.nextPipe = next;\n      } else {\n        this.next = next;\n        if (pipe) {\n          this.nextPipe = pipe;\n        }\n      }\n      return this;\n    }\n  }, {\n    key: 'push',\n    value: function push(child, name) {\n      child.parent = this;\n      if (typeof name !== 'undefined') {\n        child.childName = name;\n      }\n      child.root = this.root || this;\n      child.options = child.options || this.options;\n      if (!this.children) {\n        this.children = [child];\n        this.nextAfterChildren = this.next || null;\n        this.next = child;\n      } else {\n        this.children[this.children.length - 1].next = child;\n        this.children.push(child);\n      }\n      child.next = this;\n      return this;\n    }\n  }]);\n  return Context;\n}();\n\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n  return a instanceof Array;\n};\n\nfunction cloneRegExp(re) {\n  var regexMatch = /^\\/(.*)\\/([gimyu]*)$/.exec(re.toString());\n  return new RegExp(regexMatch[1], regexMatch[2]);\n}\n\nfunction clone(arg) {\n  if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) !== 'object') {\n    return arg;\n  }\n  if (arg === null) {\n    return null;\n  }\n  if (isArray(arg)) {\n    return arg.map(clone);\n  }\n  if (arg instanceof Date) {\n    return new Date(arg.getTime());\n  }\n  if (arg instanceof RegExp) {\n    return cloneRegExp(arg);\n  }\n  var cloned = {};\n  for (var name in arg) {\n    if (Object.prototype.hasOwnProperty.call(arg, name)) {\n      cloned[name] = clone(arg[name]);\n    }\n  }\n  return cloned;\n}\n\nvar DiffContext = function (_Context) {\n  inherits(DiffContext, _Context);\n\n  function DiffContext(left, right) {\n    classCallCheck(this, DiffContext);\n\n    var _this = possibleConstructorReturn(this, (DiffContext.__proto__ || Object.getPrototypeOf(DiffContext)).call(this));\n\n    _this.left = left;\n    _this.right = right;\n    _this.pipe = 'diff';\n    return _this;\n  }\n\n  createClass(DiffContext, [{\n    key: 'setResult',\n    value: function setResult(result) {\n      if (this.options.cloneDiffValues && (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {\n        var clone$$1 = typeof this.options.cloneDiffValues === 'function' ? this.options.cloneDiffValues : clone;\n        if (_typeof(result[0]) === 'object') {\n          result[0] = clone$$1(result[0]);\n        }\n        if (_typeof(result[1]) === 'object') {\n          result[1] = clone$$1(result[1]);\n        }\n      }\n      return Context.prototype.setResult.apply(this, arguments);\n    }\n  }]);\n  return DiffContext;\n}(Context);\n\nvar PatchContext = function (_Context) {\n  inherits(PatchContext, _Context);\n\n  function PatchContext(left, delta) {\n    classCallCheck(this, PatchContext);\n\n    var _this = possibleConstructorReturn(this, (PatchContext.__proto__ || Object.getPrototypeOf(PatchContext)).call(this));\n\n    _this.left = left;\n    _this.delta = delta;\n    _this.pipe = 'patch';\n    return _this;\n  }\n\n  return PatchContext;\n}(Context);\n\nvar ReverseContext = function (_Context) {\n  inherits(ReverseContext, _Context);\n\n  function ReverseContext(delta) {\n    classCallCheck(this, ReverseContext);\n\n    var _this = possibleConstructorReturn(this, (ReverseContext.__proto__ || Object.getPrototypeOf(ReverseContext)).call(this));\n\n    _this.delta = delta;\n    _this.pipe = 'reverse';\n    return _this;\n  }\n\n  return ReverseContext;\n}(Context);\n\nvar isArray$1 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n  return a instanceof Array;\n};\n\nvar diffFilter = function trivialMatchesDiffFilter(context) {\n  if (context.left === context.right) {\n    context.setResult(undefined).exit();\n    return;\n  }\n  if (typeof context.left === 'undefined') {\n    if (typeof context.right === 'function') {\n      throw new Error('functions are not supported');\n    }\n    context.setResult([context.right]).exit();\n    return;\n  }\n  if (typeof context.right === 'undefined') {\n    context.setResult([context.left, 0, 0]).exit();\n    return;\n  }\n  if (typeof context.left === 'function' || typeof context.right === 'function') {\n    throw new Error('functions are not supported');\n  }\n  context.leftType = context.left === null ? 'null' : _typeof(context.left);\n  context.rightType = context.right === null ? 'null' : _typeof(context.right);\n  if (context.leftType !== context.rightType) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  if (context.leftType === 'boolean' || context.leftType === 'number') {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  if (context.leftType === 'object') {\n    context.leftIsArray = isArray$1(context.left);\n  }\n  if (context.rightType === 'object') {\n    context.rightIsArray = isArray$1(context.right);\n  }\n  if (context.leftIsArray !== context.rightIsArray) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n\n  if (context.left instanceof RegExp) {\n    if (context.right instanceof RegExp) {\n      context.setResult([context.left.toString(), context.right.toString()]).exit();\n    } else {\n      context.setResult([context.left, context.right]).exit();\n    }\n  }\n};\ndiffFilter.filterName = 'trivial';\n\nvar patchFilter = function trivialMatchesPatchFilter(context) {\n  if (typeof context.delta === 'undefined') {\n    context.setResult(context.left).exit();\n    return;\n  }\n  context.nested = !isArray$1(context.delta);\n  if (context.nested) {\n    return;\n  }\n  if (context.delta.length === 1) {\n    context.setResult(context.delta[0]).exit();\n    return;\n  }\n  if (context.delta.length === 2) {\n    if (context.left instanceof RegExp) {\n      var regexArgs = /^\\/(.*)\\/([gimyu]+)$/.exec(context.delta[1]);\n      if (regexArgs) {\n        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();\n        return;\n      }\n    }\n    context.setResult(context.delta[1]).exit();\n    return;\n  }\n  if (context.delta.length === 3 && context.delta[2] === 0) {\n    context.setResult(undefined).exit();\n  }\n};\npatchFilter.filterName = 'trivial';\n\nvar reverseFilter = function trivialReferseFilter(context) {\n  if (typeof context.delta === 'undefined') {\n    context.setResult(context.delta).exit();\n    return;\n  }\n  context.nested = !isArray$1(context.delta);\n  if (context.nested) {\n    return;\n  }\n  if (context.delta.length === 1) {\n    context.setResult([context.delta[0], 0, 0]).exit();\n    return;\n  }\n  if (context.delta.length === 2) {\n    context.setResult([context.delta[1], context.delta[0]]).exit();\n    return;\n  }\n  if (context.delta.length === 3 && context.delta[2] === 0) {\n    context.setResult([context.delta[0]]).exit();\n  }\n};\nreverseFilter.filterName = 'trivial';\n\nfunction collectChildrenDiffFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  var length = context.children.length;\n  var child = void 0;\n  var result = context.result;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (typeof child.result === 'undefined') {\n      continue;\n    }\n    result = result || {};\n    result[child.childName] = child.result;\n  }\n  if (result && context.leftIsArray) {\n    result._t = 'a';\n  }\n  context.setResult(result).exit();\n}\ncollectChildrenDiffFilter.filterName = 'collectChildren';\n\nfunction objectsDiffFilter(context) {\n  if (context.leftIsArray || context.leftType !== 'object') {\n    return;\n  }\n\n  var name = void 0;\n  var child = void 0;\n  var propertyFilter = context.options.propertyFilter;\n  for (name in context.left) {\n    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {\n      continue;\n    }\n    if (propertyFilter && !propertyFilter(name, context)) {\n      continue;\n    }\n    child = new DiffContext(context.left[name], context.right[name]);\n    context.push(child, name);\n  }\n  for (name in context.right) {\n    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {\n      continue;\n    }\n    if (propertyFilter && !propertyFilter(name, context)) {\n      continue;\n    }\n    if (typeof context.left[name] === 'undefined') {\n      child = new DiffContext(undefined, context.right[name]);\n      context.push(child, name);\n    }\n  }\n\n  if (!context.children || context.children.length === 0) {\n    context.setResult(undefined).exit();\n    return;\n  }\n  context.exit();\n}\nobjectsDiffFilter.filterName = 'objects';\n\nvar patchFilter$1 = function nestedPatchFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var name = void 0;\n  var child = void 0;\n  for (name in context.delta) {\n    child = new PatchContext(context.left[name], context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\npatchFilter$1.filterName = 'objects';\n\nvar collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var length = context.children.length;\n  var child = void 0;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === undefined) {\n      delete context.left[child.childName];\n    } else if (context.left[child.childName] !== child.result) {\n      context.left[child.childName] = child.result;\n    }\n  }\n  context.setResult(context.left).exit();\n};\ncollectChildrenPatchFilter.filterName = 'collectChildren';\n\nvar reverseFilter$1 = function nestedReverseFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var name = void 0;\n  var child = void 0;\n  for (name in context.delta) {\n    child = new ReverseContext(context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\nreverseFilter$1.filterName = 'objects';\n\nfunction collectChildrenReverseFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var length = context.children.length;\n  var child = void 0;\n  var delta = {};\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (delta[child.childName] !== child.result) {\n      delta[child.childName] = child.result;\n    }\n  }\n  context.setResult(delta).exit();\n}\ncollectChildrenReverseFilter.filterName = 'collectChildren';\n\n/*\n\nLCS implementation that supports arrays or strings\n\nreference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n\n*/\n\nvar defaultMatch = function defaultMatch(array1, array2, index1, index2) {\n  return array1[index1] === array2[index2];\n};\n\nvar lengthMatrix = function lengthMatrix(array1, array2, match, context) {\n  var len1 = array1.length;\n  var len2 = array2.length;\n  var x = void 0,\n      y = void 0;\n\n  // initialize empty matrix of len1+1 x len2+1\n  var matrix = [len1 + 1];\n  for (x = 0; x < len1 + 1; x++) {\n    matrix[x] = [len2 + 1];\n    for (y = 0; y < len2 + 1; y++) {\n      matrix[x][y] = 0;\n    }\n  }\n  matrix.match = match;\n  // save sequence lengths for each coordinate\n  for (x = 1; x < len1 + 1; x++) {\n    for (y = 1; y < len2 + 1; y++) {\n      if (match(array1, array2, x - 1, y - 1, context)) {\n        matrix[x][y] = matrix[x - 1][y - 1] + 1;\n      } else {\n        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);\n      }\n    }\n  }\n  return matrix;\n};\n\nvar backtrack = function backtrack(matrix, array1, array2, context) {\n  var index1 = array1.length;\n  var index2 = array2.length;\n  var subsequence = {\n    sequence: [],\n    indices1: [],\n    indices2: []\n  };\n\n  while (index1 !== 0 && index2 !== 0) {\n    var sameLetter = matrix.match(array1, array2, index1 - 1, index2 - 1, context);\n    if (sameLetter) {\n      subsequence.sequence.unshift(array1[index1 - 1]);\n      subsequence.indices1.unshift(index1 - 1);\n      subsequence.indices2.unshift(index2 - 1);\n      --index1;\n      --index2;\n    } else {\n      var valueAtMatrixAbove = matrix[index1][index2 - 1];\n      var valueAtMatrixLeft = matrix[index1 - 1][index2];\n      if (valueAtMatrixAbove > valueAtMatrixLeft) {\n        --index2;\n      } else {\n        --index1;\n      }\n    }\n  }\n  return subsequence;\n};\n\nvar get$1 = function get(array1, array2, match, context) {\n  var innerContext = context || {};\n  var matrix = lengthMatrix(array1, array2, match || defaultMatch, innerContext);\n  var result = backtrack(matrix, array1, array2, innerContext);\n  if (typeof array1 === 'string' && typeof array2 === 'string') {\n    result.sequence = result.sequence.join('');\n  }\n  return result;\n};\n\nvar lcs = {\n  get: get$1\n};\n\nvar ARRAY_MOVE = 3;\n\nvar isArray$2 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n  return a instanceof Array;\n};\n\nvar arrayIndexOf = typeof Array.prototype.indexOf === 'function' ? function (array, item) {\n  return array.indexOf(item);\n} : function (array, item) {\n  var length = array.length;\n  for (var i = 0; i < length; i++) {\n    if (array[i] === item) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nfunction arraysHaveMatchByRef(array1, array2, len1, len2) {\n  for (var index1 = 0; index1 < len1; index1++) {\n    var val1 = array1[index1];\n    for (var index2 = 0; index2 < len2; index2++) {\n      var val2 = array2[index2];\n      if (index1 !== index2 && val1 === val2) {\n        return true;\n      }\n    }\n  }\n}\n\nfunction matchItems(array1, array2, index1, index2, context) {\n  var value1 = array1[index1];\n  var value2 = array2[index2];\n  if (value1 === value2) {\n    return true;\n  }\n  if ((typeof value1 === 'undefined' ? 'undefined' : _typeof(value1)) !== 'object' || (typeof value2 === 'undefined' ? 'undefined' : _typeof(value2)) !== 'object') {\n    return false;\n  }\n  var objectHash = context.objectHash;\n  if (!objectHash) {\n    // no way to match objects was provided, try match by position\n    return context.matchByPosition && index1 === index2;\n  }\n  var hash1 = void 0;\n  var hash2 = void 0;\n  if (typeof index1 === 'number') {\n    context.hashCache1 = context.hashCache1 || [];\n    hash1 = context.hashCache1[index1];\n    if (typeof hash1 === 'undefined') {\n      context.hashCache1[index1] = hash1 = objectHash(value1, index1);\n    }\n  } else {\n    hash1 = objectHash(value1);\n  }\n  if (typeof hash1 === 'undefined') {\n    return false;\n  }\n  if (typeof index2 === 'number') {\n    context.hashCache2 = context.hashCache2 || [];\n    hash2 = context.hashCache2[index2];\n    if (typeof hash2 === 'undefined') {\n      context.hashCache2[index2] = hash2 = objectHash(value2, index2);\n    }\n  } else {\n    hash2 = objectHash(value2);\n  }\n  if (typeof hash2 === 'undefined') {\n    return false;\n  }\n  return hash1 === hash2;\n}\n\nvar diffFilter$1 = function arraysDiffFilter(context) {\n  if (!context.leftIsArray) {\n    return;\n  }\n\n  var matchContext = {\n    objectHash: context.options && context.options.objectHash,\n    matchByPosition: context.options && context.options.matchByPosition\n  };\n  var commonHead = 0;\n  var commonTail = 0;\n  var index = void 0;\n  var index1 = void 0;\n  var index2 = void 0;\n  var array1 = context.left;\n  var array2 = context.right;\n  var len1 = array1.length;\n  var len2 = array2.length;\n\n  var child = void 0;\n\n  if (len1 > 0 && len2 > 0 && !matchContext.objectHash && typeof matchContext.matchByPosition !== 'boolean') {\n    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);\n  }\n\n  // separate common head\n  while (commonHead < len1 && commonHead < len2 && matchItems(array1, array2, commonHead, commonHead, matchContext)) {\n    index = commonHead;\n    child = new DiffContext(context.left[index], context.right[index]);\n    context.push(child, index);\n    commonHead++;\n  }\n  // separate common tail\n  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 && matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {\n    index1 = len1 - 1 - commonTail;\n    index2 = len2 - 1 - commonTail;\n    child = new DiffContext(context.left[index1], context.right[index2]);\n    context.push(child, index2);\n    commonTail++;\n  }\n  var result = void 0;\n  if (commonHead + commonTail === len1) {\n    if (len1 === len2) {\n      // arrays are identical\n      context.setResult(undefined).exit();\n      return;\n    }\n    // trivial case, a block (1 or more consecutive items) was added\n    result = result || {\n      _t: 'a'\n    };\n    for (index = commonHead; index < len2 - commonTail; index++) {\n      result[index] = [array2[index]];\n    }\n    context.setResult(result).exit();\n    return;\n  }\n  if (commonHead + commonTail === len2) {\n    // trivial case, a block (1 or more consecutive items) was removed\n    result = result || {\n      _t: 'a'\n    };\n    for (index = commonHead; index < len1 - commonTail; index++) {\n      result['_' + index] = [array1[index], 0, 0];\n    }\n    context.setResult(result).exit();\n    return;\n  }\n  // reset hash cache\n  delete matchContext.hashCache1;\n  delete matchContext.hashCache2;\n\n  // diff is not trivial, find the LCS (Longest Common Subsequence)\n  var trimmed1 = array1.slice(commonHead, len1 - commonTail);\n  var trimmed2 = array2.slice(commonHead, len2 - commonTail);\n  var seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext);\n  var removedItems = [];\n  result = result || {\n    _t: 'a'\n  };\n  for (index = commonHead; index < len1 - commonTail; index++) {\n    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {\n      // removed\n      result['_' + index] = [array1[index], 0, 0];\n      removedItems.push(index);\n    }\n  }\n\n  var detectMove = true;\n  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {\n    detectMove = false;\n  }\n  var includeValueOnMove = false;\n  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {\n    includeValueOnMove = true;\n  }\n\n  var removedItemsLength = removedItems.length;\n  for (index = commonHead; index < len2 - commonTail; index++) {\n    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);\n    if (indexOnArray2 < 0) {\n      // added, try to match with a removed item and register as position move\n      var isMove = false;\n      if (detectMove && removedItemsLength > 0) {\n        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {\n          index1 = removedItems[removeItemIndex1];\n          if (matchItems(trimmed1, trimmed2, index1 - commonHead, index - commonHead, matchContext)) {\n            // store position move as: [originalValue, newPosition, ARRAY_MOVE]\n            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);\n            if (!includeValueOnMove) {\n              // don't include moved value on diff, to save bytes\n              result['_' + index1][0] = '';\n            }\n\n            index2 = index;\n            child = new DiffContext(context.left[index1], context.right[index2]);\n            context.push(child, index2);\n            removedItems.splice(removeItemIndex1, 1);\n            isMove = true;\n            break;\n          }\n        }\n      }\n      if (!isMove) {\n        // added\n        result[index] = [array2[index]];\n      }\n    } else {\n      // match, do inner diff\n      index1 = seq.indices1[indexOnArray2] + commonHead;\n      index2 = seq.indices2[indexOnArray2] + commonHead;\n      child = new DiffContext(context.left[index1], context.right[index2]);\n      context.push(child, index2);\n    }\n  }\n\n  context.setResult(result).exit();\n};\ndiffFilter$1.filterName = 'arrays';\n\nvar compare = {\n  numerically: function numerically(a, b) {\n    return a - b;\n  },\n  numericallyBy: function numericallyBy(name) {\n    return function (a, b) {\n      return a[name] - b[name];\n    };\n  }\n};\n\nvar patchFilter$2 = function nestedPatchFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var index = void 0;\n  var index1 = void 0;\n\n  var delta = context.delta;\n  var array = context.left;\n\n  // first, separate removals, insertions and modifications\n  var toRemove = [];\n  var toInsert = [];\n  var toModify = [];\n  for (index in delta) {\n    if (index !== '_t') {\n      if (index[0] === '_') {\n        // removed item from original array\n        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {\n          toRemove.push(parseInt(index.slice(1), 10));\n        } else {\n          throw new Error('only removal or move can be applied at original array indices,' + (' invalid diff type: ' + delta[index][2]));\n        }\n      } else {\n        if (delta[index].length === 1) {\n          // added item at new array\n          toInsert.push({\n            index: parseInt(index, 10),\n            value: delta[index][0]\n          });\n        } else {\n          // modified item at new array\n          toModify.push({\n            index: parseInt(index, 10),\n            delta: delta[index]\n          });\n        }\n      }\n    }\n  }\n\n  // remove items, in reverse order to avoid sawing our own floor\n  toRemove = toRemove.sort(compare.numerically);\n  for (index = toRemove.length - 1; index >= 0; index--) {\n    index1 = toRemove[index];\n    var indexDiff = delta['_' + index1];\n    var removedValue = array.splice(index1, 1)[0];\n    if (indexDiff[2] === ARRAY_MOVE) {\n      // reinsert later\n      toInsert.push({\n        index: indexDiff[1],\n        value: removedValue\n      });\n    }\n  }\n\n  // insert items, in reverse order to avoid moving our own floor\n  toInsert = toInsert.sort(compare.numericallyBy('index'));\n  var toInsertLength = toInsert.length;\n  for (index = 0; index < toInsertLength; index++) {\n    var insertion = toInsert[index];\n    array.splice(insertion.index, 0, insertion.value);\n  }\n\n  // apply modifications\n  var toModifyLength = toModify.length;\n  var child = void 0;\n  if (toModifyLength > 0) {\n    for (index = 0; index < toModifyLength; index++) {\n      var modification = toModify[index];\n      child = new PatchContext(context.left[modification.index], modification.delta);\n      context.push(child, modification.index);\n    }\n  }\n\n  if (!context.children) {\n    context.setResult(context.left).exit();\n    return;\n  }\n  context.exit();\n};\npatchFilter$2.filterName = 'arrays';\n\nvar collectChildrenPatchFilter$1 = function collectChildrenPatchFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var length = context.children.length;\n  var child = void 0;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    context.left[child.childName] = child.result;\n  }\n  context.setResult(context.left).exit();\n};\ncollectChildrenPatchFilter$1.filterName = 'arraysCollectChildren';\n\nvar reverseFilter$2 = function arraysReverseFilter(context) {\n  if (!context.nested) {\n    if (context.delta[2] === ARRAY_MOVE) {\n      context.newName = '_' + context.delta[1];\n      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();\n    }\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var name = void 0;\n  var child = void 0;\n  for (name in context.delta) {\n    if (name === '_t') {\n      continue;\n    }\n    child = new ReverseContext(context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\nreverseFilter$2.filterName = 'arrays';\n\nvar reverseArrayDeltaIndex = function reverseArrayDeltaIndex(delta, index, itemDelta) {\n  if (typeof index === 'string' && index[0] === '_') {\n    return parseInt(index.substr(1), 10);\n  } else if (isArray$2(itemDelta) && itemDelta[2] === 0) {\n    return '_' + index;\n  }\n\n  var reverseIndex = +index;\n  for (var deltaIndex in delta) {\n    var deltaItem = delta[deltaIndex];\n    if (isArray$2(deltaItem)) {\n      if (deltaItem[2] === ARRAY_MOVE) {\n        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);\n        var moveToIndex = deltaItem[1];\n        if (moveToIndex === +index) {\n          return moveFromIndex;\n        }\n        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {\n          reverseIndex++;\n        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {\n          reverseIndex--;\n        }\n      } else if (deltaItem[2] === 0) {\n        var deleteIndex = parseInt(deltaIndex.substr(1), 10);\n        if (deleteIndex <= reverseIndex) {\n          reverseIndex++;\n        }\n      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {\n        reverseIndex--;\n      }\n    }\n  }\n\n  return reverseIndex;\n};\n\nfunction collectChildrenReverseFilter$1(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var length = context.children.length;\n  var child = void 0;\n  var delta = {\n    _t: 'a'\n  };\n\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    var name = child.newName;\n    if (typeof name === 'undefined') {\n      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);\n    }\n    if (delta[name] !== child.result) {\n      delta[name] = child.result;\n    }\n  }\n  context.setResult(delta).exit();\n}\ncollectChildrenReverseFilter$1.filterName = 'arraysCollectChildren';\n\nvar diffFilter$2 = function datesDiffFilter(context) {\n  if (context.left instanceof Date) {\n    if (context.right instanceof Date) {\n      if (context.left.getTime() !== context.right.getTime()) {\n        context.setResult([context.left, context.right]);\n      } else {\n        context.setResult(undefined);\n      }\n    } else {\n      context.setResult([context.left, context.right]);\n    }\n    context.exit();\n  } else if (context.right instanceof Date) {\n    context.setResult([context.left, context.right]).exit();\n  }\n};\ndiffFilter$2.filterName = 'dates';\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar diffMatchPatch = createCommonjsModule(function (module) {\n/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nfunction diff_match_patch() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n}\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/** @typedef {{0: number, 1: string}} */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n             [DIFF_EQUAL, shorttext],\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, '']);\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = a.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, a[j]);\n          }\n          pointer = pointer + a.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n      lineStart = lineEnd + 1;\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n    }\n    return chars;\n  }\n\n  var chars1 = diff_linesToCharsMunge_(text1);\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var x = 0; x < diffs.length; x++) {\n    var chars = diffs[x][1];\n    var text = [];\n    for (var y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)];\n    }\n    diffs[x][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastequality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastequality && (lastequality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastequality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastequality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastequality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastequality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastequality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastequality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_insert,\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete,\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\n                [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert +\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\n        } else {\n          diffs[diffsLength++] = [DIFF_DELETE, text];\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push([DIFF_EQUAL, suffix]);\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] = patch.diffs[y].slice();\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push([DIFF_EQUAL, nullPadding]);\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push([DIFF_EQUAL, precontext]);\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push([diff_type, diff_text]);\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push([diff_type, diff_text]);\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push([DIFF_EQUAL, postcontext]);\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push([DIFF_DELETE, line]);\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push([DIFF_INSERT, line]);\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push([DIFF_EQUAL, line]);\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emmulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indicies are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports['diff_match_patch'] = diff_match_patch;\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;\n});\n\n/* global diff_match_patch */\nvar TEXT_DIFF = 2;\nvar DEFAULT_MIN_LENGTH = 60;\nvar cachedDiffPatch = null;\n\nvar getDiffMatchPatch = function getDiffMatchPatch(required) {\n  /* jshint camelcase: false */\n\n  if (!cachedDiffPatch) {\n    var instance = void 0;\n    /* eslint-disable camelcase, new-cap */\n    if (typeof diff_match_patch !== 'undefined') {\n      // already loaded, probably a browser\n      instance = typeof diff_match_patch === 'function' ? new diff_match_patch() : new diff_match_patch.diff_match_patch();\n    } else if (diffMatchPatch) {\n      try {\n        instance = diffMatchPatch && new diffMatchPatch();\n      } catch (err) {\n        instance = null;\n      }\n    }\n    /* eslint-enable camelcase, new-cap */\n    if (!instance) {\n      if (!required) {\n        return null;\n      }\n      var error = new Error('text diff_match_patch library not found');\n      // eslint-disable-next-line camelcase\n      error.diff_match_patch_not_found = true;\n      throw error;\n    }\n    cachedDiffPatch = {\n      diff: function diff(txt1, txt2) {\n        return instance.patch_toText(instance.patch_make(txt1, txt2));\n      },\n      patch: function patch(txt1, _patch) {\n        var results = instance.patch_apply(instance.patch_fromText(_patch), txt1);\n        for (var i = 0; i < results[1].length; i++) {\n          if (!results[1][i]) {\n            var _error = new Error('text patch failed');\n            _error.textPatchFailed = true;\n          }\n        }\n        return results[0];\n      }\n    };\n  }\n  return cachedDiffPatch;\n};\n\nvar diffFilter$3 = function textsDiffFilter(context) {\n  if (context.leftType !== 'string') {\n    return;\n  }\n  var minLength = context.options && context.options.textDiff && context.options.textDiff.minLength || DEFAULT_MIN_LENGTH;\n  if (context.left.length < minLength || context.right.length < minLength) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  // large text, try to use a text-diff algorithm\n  var diffMatchPatch$$1 = getDiffMatchPatch();\n  if (!diffMatchPatch$$1) {\n    // diff-match-patch library not available,\n    // fallback to regular string replace\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  var diff = diffMatchPatch$$1.diff;\n  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();\n};\ndiffFilter$3.filterName = 'texts';\n\nvar patchFilter$3 = function textsPatchFilter(context) {\n  if (context.nested) {\n    return;\n  }\n  if (context.delta[2] !== TEXT_DIFF) {\n    return;\n  }\n\n  // text-diff, use a text-patch algorithm\n  var patch = getDiffMatchPatch(true).patch;\n  context.setResult(patch(context.left, context.delta[0])).exit();\n};\npatchFilter$3.filterName = 'texts';\n\nvar textDeltaReverse = function textDeltaReverse(delta) {\n  var i = void 0;\n  var l = void 0;\n  var lines = void 0;\n  var line = void 0;\n  var lineTmp = void 0;\n  var header = null;\n  var headerRegex = /^@@ +-(\\d+),(\\d+) +\\+(\\d+),(\\d+) +@@$/;\n  var lineHeader = void 0;\n  lines = delta.split('\\n');\n  for (i = 0, l = lines.length; i < l; i++) {\n    line = lines[i];\n    var lineStart = line.slice(0, 1);\n    if (lineStart === '@') {\n      header = headerRegex.exec(line);\n      lineHeader = i;\n\n      // fix header\n      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';\n    } else if (lineStart === '+') {\n      lines[i] = '-' + lines[i].slice(1);\n      if (lines[i - 1].slice(0, 1) === '+') {\n        // swap lines to keep default order (-+)\n        lineTmp = lines[i];\n        lines[i] = lines[i - 1];\n        lines[i - 1] = lineTmp;\n      }\n    } else if (lineStart === '-') {\n      lines[i] = '+' + lines[i].slice(1);\n    }\n  }\n  return lines.join('\\n');\n};\n\nvar reverseFilter$3 = function textsReverseFilter(context) {\n  if (context.nested) {\n    return;\n  }\n  if (context.delta[2] !== TEXT_DIFF) {\n    return;\n  }\n\n  // text-diff, use a text-diff algorithm\n  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();\n};\nreverseFilter$3.filterName = 'texts';\n\nvar DiffPatcher = function () {\n  function DiffPatcher(options) {\n    classCallCheck(this, DiffPatcher);\n\n    this.processor = new Processor(options);\n    this.processor.pipe(new Pipe('diff').append(collectChildrenDiffFilter, diffFilter, diffFilter$2, diffFilter$3, objectsDiffFilter, diffFilter$1).shouldHaveResult());\n    this.processor.pipe(new Pipe('patch').append(collectChildrenPatchFilter, collectChildrenPatchFilter$1, patchFilter, patchFilter$3, patchFilter$1, patchFilter$2).shouldHaveResult());\n    this.processor.pipe(new Pipe('reverse').append(collectChildrenReverseFilter, collectChildrenReverseFilter$1, reverseFilter, reverseFilter$3, reverseFilter$1, reverseFilter$2).shouldHaveResult());\n  }\n\n  createClass(DiffPatcher, [{\n    key: 'options',\n    value: function options() {\n      var _processor;\n\n      return (_processor = this.processor).options.apply(_processor, arguments);\n    }\n  }, {\n    key: 'diff',\n    value: function diff(left, right) {\n      return this.processor.process(new DiffContext(left, right));\n    }\n  }, {\n    key: 'patch',\n    value: function patch(left, delta) {\n      return this.processor.process(new PatchContext(left, delta));\n    }\n  }, {\n    key: 'reverse',\n    value: function reverse(delta) {\n      return this.processor.process(new ReverseContext(delta));\n    }\n  }, {\n    key: 'unpatch',\n    value: function unpatch(right, delta) {\n      return this.patch(right, this.reverse(delta));\n    }\n  }, {\n    key: 'clone',\n    value: function clone$$1(value) {\n      return clone(value);\n    }\n  }]);\n  return DiffPatcher;\n}();\n\nvar isArray$3 = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n  return a instanceof Array;\n};\n\nvar getObjectKeys = typeof Object.keys === 'function' ? function (obj) {\n  return Object.keys(obj);\n} : function (obj) {\n  var names = [];\n  for (var property in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, property)) {\n      names.push(property);\n    }\n  }\n  return names;\n};\n\nvar trimUnderscore = function trimUnderscore(str) {\n  if (str.substr(0, 1) === '_') {\n    return str.slice(1);\n  }\n  return str;\n};\n\nvar arrayKeyToSortNumber = function arrayKeyToSortNumber(key) {\n  if (key === '_t') {\n    return -1;\n  } else {\n    if (key.substr(0, 1) === '_') {\n      return parseInt(key.slice(1), 10);\n    } else {\n      return parseInt(key, 10) + 0.1;\n    }\n  }\n};\n\nvar arrayKeyComparer = function arrayKeyComparer(key1, key2) {\n  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);\n};\n\nvar BaseFormatter = function () {\n  function BaseFormatter() {\n    classCallCheck(this, BaseFormatter);\n  }\n\n  createClass(BaseFormatter, [{\n    key: 'format',\n    value: function format(delta, left) {\n      var context = {};\n      this.prepareContext(context);\n      this.recurse(context, delta, left);\n      return this.finalize(context);\n    }\n  }, {\n    key: 'prepareContext',\n    value: function prepareContext(context) {\n      context.buffer = [];\n      context.out = function () {\n        var _buffer;\n\n        (_buffer = this.buffer).push.apply(_buffer, arguments);\n      };\n    }\n  }, {\n    key: 'typeFormattterNotFound',\n    value: function typeFormattterNotFound(context, deltaType) {\n      throw new Error('cannot format delta type: ' + deltaType);\n    }\n  }, {\n    key: 'typeFormattterErrorFormatter',\n    value: function typeFormattterErrorFormatter(context, err) {\n      return err.toString();\n    }\n  }, {\n    key: 'finalize',\n    value: function finalize(_ref) {\n      var buffer = _ref.buffer;\n\n      if (isArray$3(buffer)) {\n        return buffer.join('');\n      }\n    }\n  }, {\n    key: 'recurse',\n    value: function recurse(context, delta, left, key, leftKey, movedFrom, isLast) {\n      var useMoveOriginHere = delta && movedFrom;\n      var leftValue = useMoveOriginHere ? movedFrom.value : left;\n\n      if (typeof delta === 'undefined' && typeof key === 'undefined') {\n        return undefined;\n      }\n\n      var type = this.getDeltaType(delta, movedFrom);\n      var nodeType = type === 'node' ? delta._t === 'a' ? 'array' : 'object' : '';\n\n      if (typeof key !== 'undefined') {\n        this.nodeBegin(context, key, leftKey, type, nodeType, isLast);\n      } else {\n        this.rootBegin(context, type, nodeType);\n      }\n\n      var typeFormattter = void 0;\n      try {\n        typeFormattter = this['format_' + type] || this.typeFormattterNotFound(context, type);\n        typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);\n      } catch (err) {\n        this.typeFormattterErrorFormatter(context, err, delta, leftValue, key, leftKey, movedFrom);\n        if (typeof console !== 'undefined' && console.error) {\n          console.error(err.stack);\n        }\n      }\n\n      if (typeof key !== 'undefined') {\n        this.nodeEnd(context, key, leftKey, type, nodeType, isLast);\n      } else {\n        this.rootEnd(context, type, nodeType);\n      }\n    }\n  }, {\n    key: 'formatDeltaChildren',\n    value: function formatDeltaChildren(context, delta, left) {\n      var self = this;\n      this.forEachDeltaKey(delta, left, function (key, leftKey, movedFrom, isLast) {\n        self.recurse(context, delta[key], left ? left[leftKey] : undefined, key, leftKey, movedFrom, isLast);\n      });\n    }\n  }, {\n    key: 'forEachDeltaKey',\n    value: function forEachDeltaKey(delta, left, fn) {\n      var keys = getObjectKeys(delta);\n      var arrayKeys = delta._t === 'a';\n      var moveDestinations = {};\n      var name = void 0;\n      if (typeof left !== 'undefined') {\n        for (name in left) {\n          if (Object.prototype.hasOwnProperty.call(left, name)) {\n            if (typeof delta[name] === 'undefined' && (!arrayKeys || typeof delta['_' + name] === 'undefined')) {\n              keys.push(name);\n            }\n          }\n        }\n      }\n      // look for move destinations\n      for (name in delta) {\n        if (Object.prototype.hasOwnProperty.call(delta, name)) {\n          var value = delta[name];\n          if (isArray$3(value) && value[2] === 3) {\n            moveDestinations[value[1].toString()] = {\n              key: name,\n              value: left && left[parseInt(name.substr(1))]\n            };\n            if (this.includeMoveDestinations !== false) {\n              if (typeof left === 'undefined' && typeof delta[value[1]] === 'undefined') {\n                keys.push(value[1].toString());\n              }\n            }\n          }\n        }\n      }\n      if (arrayKeys) {\n        keys.sort(arrayKeyComparer);\n      } else {\n        keys.sort();\n      }\n      for (var index = 0, length = keys.length; index < length; index++) {\n        var key = keys[index];\n        if (arrayKeys && key === '_t') {\n          continue;\n        }\n        var leftKey = arrayKeys ? typeof key === 'number' ? key : parseInt(trimUnderscore(key), 10) : key;\n        var isLast = index === length - 1;\n        fn(key, leftKey, moveDestinations[leftKey], isLast);\n      }\n    }\n  }, {\n    key: 'getDeltaType',\n    value: function getDeltaType(delta, movedFrom) {\n      if (typeof delta === 'undefined') {\n        if (typeof movedFrom !== 'undefined') {\n          return 'movedestination';\n        }\n        return 'unchanged';\n      }\n      if (isArray$3(delta)) {\n        if (delta.length === 1) {\n          return 'added';\n        }\n        if (delta.length === 2) {\n          return 'modified';\n        }\n        if (delta.length === 3 && delta[2] === 0) {\n          return 'deleted';\n        }\n        if (delta.length === 3 && delta[2] === 2) {\n          return 'textdiff';\n        }\n        if (delta.length === 3 && delta[2] === 3) {\n          return 'moved';\n        }\n      } else if ((typeof delta === 'undefined' ? 'undefined' : _typeof(delta)) === 'object') {\n        return 'node';\n      }\n      return 'unknown';\n    }\n  }, {\n    key: 'parseTextDiff',\n    value: function parseTextDiff(value) {\n      var output = [];\n      var lines = value.split('\\n@@ ');\n      for (var i = 0, l = lines.length; i < l; i++) {\n        var line = lines[i];\n        var lineOutput = {\n          pieces: []\n        };\n        var location = /^(?:@@ )?[-+]?(\\d+),(\\d+)/.exec(line).slice(1);\n        lineOutput.location = {\n          line: location[0],\n          chr: location[1]\n        };\n        var pieces = line.split('\\n').slice(1);\n        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n          var piece = pieces[pieceIndex];\n          if (!piece.length) {\n            continue;\n          }\n          var pieceOutput = {\n            type: 'context'\n          };\n          if (piece.substr(0, 1) === '+') {\n            pieceOutput.type = 'added';\n          } else if (piece.substr(0, 1) === '-') {\n            pieceOutput.type = 'deleted';\n          }\n          pieceOutput.text = piece.slice(1);\n          lineOutput.pieces.push(pieceOutput);\n        }\n        output.push(lineOutput);\n      }\n      return output;\n    }\n  }]);\n  return BaseFormatter;\n}();\n\n\n\nvar base = Object.freeze({\n\tdefault: BaseFormatter\n});\n\nvar HtmlFormatter = function (_BaseFormatter) {\n  inherits(HtmlFormatter, _BaseFormatter);\n\n  function HtmlFormatter() {\n    classCallCheck(this, HtmlFormatter);\n    return possibleConstructorReturn(this, (HtmlFormatter.__proto__ || Object.getPrototypeOf(HtmlFormatter)).apply(this, arguments));\n  }\n\n  createClass(HtmlFormatter, [{\n    key: 'typeFormattterErrorFormatter',\n    value: function typeFormattterErrorFormatter(context, err) {\n      context.out('<pre class=\"jsondiffpatch-error\">' + err + '</pre>');\n    }\n  }, {\n    key: 'formatValue',\n    value: function formatValue(context, value) {\n      context.out('<pre>' + htmlEscape(JSON.stringify(value, null, 2)) + '</pre>');\n    }\n  }, {\n    key: 'formatTextDiffString',\n    value: function formatTextDiffString(context, value) {\n      var lines = this.parseTextDiff(value);\n      context.out('<ul class=\"jsondiffpatch-textdiff\">');\n      for (var i = 0, l = lines.length; i < l; i++) {\n        var line = lines[i];\n        context.out('<li><div class=\"jsondiffpatch-textdiff-location\">' + ('<span class=\"jsondiffpatch-textdiff-line-number\">' + line.location.line + '</span><span class=\"jsondiffpatch-textdiff-char\">' + line.location.chr + '</span></div><div class=\"jsondiffpatch-textdiff-line\">'));\n        var pieces = line.pieces;\n        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n          /* global decodeURI */\n          var piece = pieces[pieceIndex];\n          context.out('<span class=\"jsondiffpatch-textdiff-' + piece.type + '\">' + htmlEscape(decodeURI(piece.text)) + '</span>');\n        }\n        context.out('</div></li>');\n      }\n      context.out('</ul>');\n    }\n  }, {\n    key: 'rootBegin',\n    value: function rootBegin(context, type, nodeType) {\n      var nodeClass = 'jsondiffpatch-' + type + (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');\n      context.out('<div class=\"jsondiffpatch-delta ' + nodeClass + '\">');\n    }\n  }, {\n    key: 'rootEnd',\n    value: function rootEnd(context) {\n      context.out('</div>' + (context.hasArrows ? '<script type=\"text/javascript\">setTimeout(' + (adjustArrows.toString() + ',10);</script>') : ''));\n    }\n  }, {\n    key: 'nodeBegin',\n    value: function nodeBegin(context, key, leftKey, type, nodeType) {\n      var nodeClass = 'jsondiffpatch-' + type + (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');\n      context.out('<li class=\"' + nodeClass + '\" data-key=\"' + leftKey + '\">' + ('<div class=\"jsondiffpatch-property-name\">' + leftKey + '</div>'));\n    }\n  }, {\n    key: 'nodeEnd',\n    value: function nodeEnd(context) {\n      context.out('</li>');\n    }\n\n    /* jshint camelcase: false */\n    /* eslint-disable camelcase */\n\n  }, {\n    key: 'format_unchanged',\n    value: function format_unchanged(context, delta, left) {\n      if (typeof left === 'undefined') {\n        return;\n      }\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatValue(context, left);\n      context.out('</div>');\n    }\n  }, {\n    key: 'format_movedestination',\n    value: function format_movedestination(context, delta, left) {\n      if (typeof left === 'undefined') {\n        return;\n      }\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatValue(context, left);\n      context.out('</div>');\n    }\n  }, {\n    key: 'format_node',\n    value: function format_node(context, delta, left) {\n      // recurse\n      var nodeType = delta._t === 'a' ? 'array' : 'object';\n      context.out('<ul class=\"jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '\">');\n      this.formatDeltaChildren(context, delta, left);\n      context.out('</ul>');\n    }\n  }, {\n    key: 'format_added',\n    value: function format_added(context, delta) {\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatValue(context, delta[0]);\n      context.out('</div>');\n    }\n  }, {\n    key: 'format_modified',\n    value: function format_modified(context, delta) {\n      context.out('<div class=\"jsondiffpatch-value jsondiffpatch-left-value\">');\n      this.formatValue(context, delta[0]);\n      context.out('</div>' + '<div class=\"jsondiffpatch-value jsondiffpatch-right-value\">');\n      this.formatValue(context, delta[1]);\n      context.out('</div>');\n    }\n  }, {\n    key: 'format_deleted',\n    value: function format_deleted(context, delta) {\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatValue(context, delta[0]);\n      context.out('</div>');\n    }\n  }, {\n    key: 'format_moved',\n    value: function format_moved(context, delta) {\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatValue(context, delta[0]);\n      context.out('</div><div class=\"jsondiffpatch-moved-destination\">' + delta[1] + '</div>');\n\n      // draw an SVG arrow from here to move destination\n      context.out(\n      /* jshint multistr: true */\n      '<div class=\"jsondiffpatch-arrow\" ' + 'style=\"position: relative; left: -34px;\">\\n          <svg width=\"30\" height=\"60\" ' + 'style=\"position: absolute; display: none;\">\\n          <defs>\\n              <marker id=\"markerArrow\" markerWidth=\"8\" markerHeight=\"8\"\\n                 refx=\"2\" refy=\"4\"\\n                     orient=\"auto\" markerUnits=\"userSpaceOnUse\">\\n                  <path d=\"M1,1 L1,7 L7,4 L1,1\" style=\"fill: #339;\" />\\n              </marker>\\n          </defs>\\n          <path d=\"M30,0 Q-10,25 26,50\"\\n            style=\"stroke: #88f; stroke-width: 2px; fill: none; ' + 'stroke-opacity: 0.5; marker-end: url(#markerArrow);\"\\n          ></path>\\n          </svg>\\n      </div>');\n      context.hasArrows = true;\n    }\n  }, {\n    key: 'format_textdiff',\n    value: function format_textdiff(context, delta) {\n      context.out('<div class=\"jsondiffpatch-value\">');\n      this.formatTextDiffString(context, delta[0]);\n      context.out('</div>');\n    }\n  }]);\n  return HtmlFormatter;\n}(BaseFormatter);\n\nfunction htmlEscape(text) {\n  var html = text;\n  var replacements = [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/'/g, '&apos;'], [/\"/g, '&quot;']];\n  for (var i = 0; i < replacements.length; i++) {\n    html = html.replace(replacements[i][0], replacements[i][1]);\n  }\n  return html;\n}\n\nvar adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {\n  var node = nodeArg || document;\n  var getElementText = function getElementText(_ref) {\n    var textContent = _ref.textContent,\n        innerText = _ref.innerText;\n    return textContent || innerText;\n  };\n  var eachByQuery = function eachByQuery(el, query, fn) {\n    var elems = el.querySelectorAll(query);\n    for (var i = 0, l = elems.length; i < l; i++) {\n      fn(elems[i]);\n    }\n  };\n  var eachChildren = function eachChildren(_ref2, fn) {\n    var children = _ref2.children;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      fn(children[i], i);\n    }\n  };\n  eachByQuery(node, '.jsondiffpatch-arrow', function (_ref3) {\n    var parentNode = _ref3.parentNode,\n        children = _ref3.children,\n        style = _ref3.style;\n\n    var arrowParent = parentNode;\n    var svg = children[0];\n    var path = svg.children[1];\n    svg.style.display = 'none';\n    var destination = getElementText(arrowParent.querySelector('.jsondiffpatch-moved-destination'));\n    var container = arrowParent.parentNode;\n    var destinationElem = void 0;\n    eachChildren(container, function (child) {\n      if (child.getAttribute('data-key') === destination) {\n        destinationElem = child;\n      }\n    });\n    if (!destinationElem) {\n      return;\n    }\n    try {\n      var distance = destinationElem.offsetTop - arrowParent.offsetTop;\n      svg.setAttribute('height', Math.abs(distance) + 6);\n      style.top = -8 + (distance > 0 ? 0 : distance) + 'px';\n      var curve = distance > 0 ? 'M30,0 Q-10,' + Math.round(distance / 2) + ' 26,' + (distance - 4) : 'M30,' + -distance + ' Q-10,' + Math.round(-distance / 2) + ' 26,4';\n      path.setAttribute('d', curve);\n      svg.style.display = '';\n    } catch (err) {}\n  });\n};\n\n/* jshint camelcase: true */\n/* eslint-enable camelcase */\n\nvar showUnchanged = function showUnchanged(show, node, delay) {\n  var el = node || document.body;\n  var prefix = 'jsondiffpatch-unchanged-';\n  var classes = {\n    showing: prefix + 'showing',\n    hiding: prefix + 'hiding',\n    visible: prefix + 'visible',\n    hidden: prefix + 'hidden'\n  };\n  var list = el.classList;\n  if (!list) {\n    return;\n  }\n  if (!delay) {\n    list.remove(classes.showing);\n    list.remove(classes.hiding);\n    list.remove(classes.visible);\n    list.remove(classes.hidden);\n    if (show === false) {\n      list.add(classes.hidden);\n    }\n    return;\n  }\n  if (show === false) {\n    list.remove(classes.showing);\n    list.add(classes.visible);\n    setTimeout(function () {\n      list.add(classes.hiding);\n    }, 10);\n  } else {\n    list.remove(classes.hiding);\n    list.add(classes.showing);\n    list.remove(classes.hidden);\n  }\n  var intervalId = setInterval(function () {\n    adjustArrows(el);\n  }, 100);\n  setTimeout(function () {\n    list.remove(classes.showing);\n    list.remove(classes.hiding);\n    if (show === false) {\n      list.add(classes.hidden);\n      list.remove(classes.visible);\n    } else {\n      list.add(classes.visible);\n      list.remove(classes.hidden);\n    }\n    setTimeout(function () {\n      list.remove(classes.visible);\n      clearInterval(intervalId);\n    }, delay + 400);\n  }, delay);\n};\n\nvar hideUnchanged = function hideUnchanged(node, delay) {\n  return showUnchanged(false, node, delay);\n};\n\nvar defaultInstance = void 0;\n\nfunction format(delta, left) {\n  if (!defaultInstance) {\n    defaultInstance = new HtmlFormatter();\n  }\n  return defaultInstance.format(delta, left);\n}\n\n\n\nvar html = Object.freeze({\n\tshowUnchanged: showUnchanged,\n\thideUnchanged: hideUnchanged,\n\tdefault: HtmlFormatter,\n\tformat: format\n});\n\nvar AnnotatedFormatter = function (_BaseFormatter) {\n  inherits(AnnotatedFormatter, _BaseFormatter);\n\n  function AnnotatedFormatter() {\n    classCallCheck(this, AnnotatedFormatter);\n\n    var _this = possibleConstructorReturn(this, (AnnotatedFormatter.__proto__ || Object.getPrototypeOf(AnnotatedFormatter)).call(this));\n\n    _this.includeMoveDestinations = false;\n    return _this;\n  }\n\n  createClass(AnnotatedFormatter, [{\n    key: 'prepareContext',\n    value: function prepareContext(context) {\n      get(AnnotatedFormatter.prototype.__proto__ || Object.getPrototypeOf(AnnotatedFormatter.prototype), 'prepareContext', this).call(this, context);\n      context.indent = function (levels) {\n        this.indentLevel = (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);\n        this.indentPad = new Array(this.indentLevel + 1).join('&nbsp;&nbsp;');\n      };\n      context.row = function (json, htmlNote) {\n        context.out('<tr><td style=\"white-space: nowrap;\">' + '<pre class=\"jsondiffpatch-annotated-indent\"' + ' style=\"display: inline-block\">');\n        context.out(context.indentPad);\n        context.out('</pre><pre style=\"display: inline-block\">');\n        context.out(json);\n        context.out('</pre></td><td class=\"jsondiffpatch-delta-note\"><div>');\n        context.out(htmlNote);\n        context.out('</div></td></tr>');\n      };\n    }\n  }, {\n    key: 'typeFormattterErrorFormatter',\n    value: function typeFormattterErrorFormatter(context, err) {\n      context.row('', '<pre class=\"jsondiffpatch-error\">' + err + '</pre>');\n    }\n  }, {\n    key: 'formatTextDiffString',\n    value: function formatTextDiffString(context, value) {\n      var lines = this.parseTextDiff(value);\n      context.out('<ul class=\"jsondiffpatch-textdiff\">');\n      for (var i = 0, l = lines.length; i < l; i++) {\n        var line = lines[i];\n        context.out('<li><div class=\"jsondiffpatch-textdiff-location\">' + ('<span class=\"jsondiffpatch-textdiff-line-number\">' + line.location.line + '</span><span class=\"jsondiffpatch-textdiff-char\">' + line.location.chr + '</span></div><div class=\"jsondiffpatch-textdiff-line\">'));\n        var pieces = line.pieces;\n        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n          var piece = pieces[pieceIndex];\n          context.out('<span class=\"jsondiffpatch-textdiff-' + piece.type + '\">' + piece.text + '</span>');\n        }\n        context.out('</div></li>');\n      }\n      context.out('</ul>');\n    }\n  }, {\n    key: 'rootBegin',\n    value: function rootBegin(context, type, nodeType) {\n      context.out('<table class=\"jsondiffpatch-annotated-delta\">');\n      if (type === 'node') {\n        context.row('{');\n        context.indent();\n      }\n      if (nodeType === 'array') {\n        context.row('\"_t\": \"a\",', 'Array delta (member names indicate array indices)');\n      }\n    }\n  }, {\n    key: 'rootEnd',\n    value: function rootEnd(context, type) {\n      if (type === 'node') {\n        context.indent(-1);\n        context.row('}');\n      }\n      context.out('</table>');\n    }\n  }, {\n    key: 'nodeBegin',\n    value: function nodeBegin(context, key, leftKey, type, nodeType) {\n      context.row('&quot;' + key + '&quot;: {');\n      if (type === 'node') {\n        context.indent();\n      }\n      if (nodeType === 'array') {\n        context.row('\"_t\": \"a\",', 'Array delta (member names indicate array indices)');\n      }\n    }\n  }, {\n    key: 'nodeEnd',\n    value: function nodeEnd(context, key, leftKey, type, nodeType, isLast) {\n      if (type === 'node') {\n        context.indent(-1);\n      }\n      context.row('}' + (isLast ? '' : ','));\n    }\n\n    /* jshint camelcase: false */\n\n    /* eslint-disable camelcase */\n\n  }, {\n    key: 'format_unchanged',\n    value: function format_unchanged() {}\n  }, {\n    key: 'format_movedestination',\n    value: function format_movedestination() {}\n  }, {\n    key: 'format_node',\n    value: function format_node(context, delta, left) {\n      // recurse\n      this.formatDeltaChildren(context, delta, left);\n    }\n  }]);\n  return AnnotatedFormatter;\n}(BaseFormatter);\n\n/* eslint-enable camelcase */\n\nvar wrapPropertyName = function wrapPropertyName(name) {\n  return '<pre style=\"display:inline-block\">&quot;' + name + '&quot;</pre>';\n};\n\nvar deltaAnnotations = {\n  added: function added(delta, left, key, leftKey) {\n    var formatLegend = ' <pre>([newValue])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return 'new value' + formatLegend;\n    }\n    if (typeof leftKey === 'number') {\n      return 'insert at index ' + leftKey + formatLegend;\n    }\n    return 'add property ' + wrapPropertyName(leftKey) + formatLegend;\n  },\n  modified: function modified(delta, left, key, leftKey) {\n    var formatLegend = ' <pre>([previousValue, newValue])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return 'modify value' + formatLegend;\n    }\n    if (typeof leftKey === 'number') {\n      return 'modify at index ' + leftKey + formatLegend;\n    }\n    return 'modify property ' + wrapPropertyName(leftKey) + formatLegend;\n  },\n  deleted: function deleted(delta, left, key, leftKey) {\n    var formatLegend = ' <pre>([previousValue, 0, 0])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return 'delete value' + formatLegend;\n    }\n    if (typeof leftKey === 'number') {\n      return 'remove index ' + leftKey + formatLegend;\n    }\n    return 'delete property ' + wrapPropertyName(leftKey) + formatLegend;\n  },\n  moved: function moved(delta, left, key, leftKey) {\n    return 'move from <span title=\"(position to remove at original state)\">' + ('index ' + leftKey + '</span> to <span title=\"(position to insert at final') + (' state)\">index ' + delta[1] + '</span>');\n  },\n  textdiff: function textdiff(delta, left, key, leftKey) {\n    var location = typeof leftKey === 'undefined' ? '' : typeof leftKey === 'number' ? ' at index ' + leftKey : ' at property ' + wrapPropertyName(leftKey);\n    return 'text diff' + location + ', format is <a href=\"https://code.google.com/' + 'p/google-diff-match-patch/wiki/Unidiff\">a variation of Unidiff</a>';\n  }\n};\n\nvar formatAnyChange = function formatAnyChange(context, delta) {\n  var deltaType = this.getDeltaType(delta);\n  var annotator = deltaAnnotations[deltaType];\n  var htmlNote = annotator && annotator.apply(annotator, Array.prototype.slice.call(arguments, 1));\n  var json = JSON.stringify(delta, null, 2);\n  if (deltaType === 'textdiff') {\n    // split text diffs lines\n    json = json.split('\\\\n').join('\\\\n\"+\\n   \"');\n  }\n  context.indent();\n  context.row(json, htmlNote);\n  context.indent(-1);\n};\n\n/* eslint-disable camelcase */\nAnnotatedFormatter.prototype.format_added = formatAnyChange;\nAnnotatedFormatter.prototype.format_modified = formatAnyChange;\nAnnotatedFormatter.prototype.format_deleted = formatAnyChange;\nAnnotatedFormatter.prototype.format_moved = formatAnyChange;\nAnnotatedFormatter.prototype.format_textdiff = formatAnyChange;\nvar defaultInstance$1 = void 0;\n\nfunction format$1(delta, left) {\n  if (!defaultInstance$1) {\n    defaultInstance$1 = new AnnotatedFormatter();\n  }\n  return defaultInstance$1.format(delta, left);\n}\n\n\n\nvar annotated = Object.freeze({\n\tdefault: AnnotatedFormatter,\n\tformat: format$1\n});\n\nvar OPERATIONS = {\n  add: 'add',\n  remove: 'remove',\n  replace: 'replace',\n  move: 'move'\n};\n\nvar JSONFormatter = function (_BaseFormatter) {\n  inherits(JSONFormatter, _BaseFormatter);\n\n  function JSONFormatter() {\n    classCallCheck(this, JSONFormatter);\n\n    var _this = possibleConstructorReturn(this, (JSONFormatter.__proto__ || Object.getPrototypeOf(JSONFormatter)).call(this));\n\n    _this.includeMoveDestinations = true;\n    return _this;\n  }\n\n  createClass(JSONFormatter, [{\n    key: 'prepareContext',\n    value: function prepareContext(context) {\n      get(JSONFormatter.prototype.__proto__ || Object.getPrototypeOf(JSONFormatter.prototype), 'prepareContext', this).call(this, context);\n      context.result = [];\n      context.path = [];\n      context.pushCurrentOp = function (obj) {\n        var op = obj.op,\n            value = obj.value;\n\n        var val = {\n          op: op,\n          path: this.currentPath()\n        };\n        if (typeof value !== 'undefined') {\n          val.value = value;\n        }\n        this.result.push(val);\n      };\n\n      context.pushMoveOp = function (to) {\n        var from = this.currentPath();\n        this.result.push({\n          op: OPERATIONS.move,\n          from: from,\n          path: this.toPath(to)\n        });\n      };\n\n      context.currentPath = function () {\n        return '/' + this.path.join('/');\n      };\n\n      context.toPath = function (toPath) {\n        var to = this.path.slice();\n        to[to.length - 1] = toPath;\n        return '/' + to.join('/');\n      };\n    }\n  }, {\n    key: 'typeFormattterErrorFormatter',\n    value: function typeFormattterErrorFormatter(context, err) {\n      context.out('[ERROR] ' + err);\n    }\n  }, {\n    key: 'rootBegin',\n    value: function rootBegin() {}\n  }, {\n    key: 'rootEnd',\n    value: function rootEnd() {}\n  }, {\n    key: 'nodeBegin',\n    value: function nodeBegin(_ref, key, leftKey) {\n      var path = _ref.path;\n\n      path.push(leftKey);\n    }\n  }, {\n    key: 'nodeEnd',\n    value: function nodeEnd(_ref2) {\n      var path = _ref2.path;\n\n      path.pop();\n    }\n\n    /* jshint camelcase: false */\n    /* eslint-disable camelcase */\n\n  }, {\n    key: 'format_unchanged',\n    value: function format_unchanged() {}\n  }, {\n    key: 'format_movedestination',\n    value: function format_movedestination() {}\n  }, {\n    key: 'format_node',\n    value: function format_node(context, delta, left) {\n      this.formatDeltaChildren(context, delta, left);\n    }\n  }, {\n    key: 'format_added',\n    value: function format_added(context, delta) {\n      context.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] });\n    }\n  }, {\n    key: 'format_modified',\n    value: function format_modified(context, delta) {\n      context.pushCurrentOp({ op: OPERATIONS.replace, value: delta[1] });\n    }\n  }, {\n    key: 'format_deleted',\n    value: function format_deleted(context) {\n      context.pushCurrentOp({ op: OPERATIONS.remove });\n    }\n  }, {\n    key: 'format_moved',\n    value: function format_moved(context, delta) {\n      var to = delta[1];\n      context.pushMoveOp(to);\n    }\n  }, {\n    key: 'format_textdiff',\n    value: function format_textdiff() {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: 'format',\n    value: function format(delta, left) {\n      var context = {};\n      this.prepareContext(context);\n      this.recurse(context, delta, left);\n      return context.result;\n    }\n  }]);\n  return JSONFormatter;\n}(BaseFormatter);\n\nvar last = function last(arr) {\n  return arr[arr.length - 1];\n};\n\nvar sortBy = function sortBy(arr, pred) {\n  arr.sort(pred);\n  return arr;\n};\n\nvar compareByIndexDesc = function compareByIndexDesc(indexA, indexB) {\n  var lastA = parseInt(indexA, 10);\n  var lastB = parseInt(indexB, 10);\n  if (!(isNaN(lastA) || isNaN(lastB))) {\n    return lastB - lastA;\n  } else {\n    return 0;\n  }\n};\n\nvar opsByDescendingOrder = function opsByDescendingOrder(removeOps) {\n  return sortBy(removeOps, function (a, b) {\n    var splitA = a.path.split('/');\n    var splitB = b.path.split('/');\n    if (splitA.length !== splitB.length) {\n      return splitA.length - splitB.length;\n    } else {\n      return compareByIndexDesc(last(splitA), last(splitB));\n    }\n  });\n};\n\nvar partitionOps = function partitionOps(arr, fns) {\n  var initArr = Array(fns.length + 1).fill().map(function () {\n    return [];\n  });\n  return arr.map(function (item) {\n    var position = fns.map(function (fn) {\n      return fn(item);\n    }).indexOf(true);\n    if (position < 0) {\n      position = fns.length;\n    }\n    return { item: item, position: position };\n  }).reduce(function (acc, item) {\n    acc[item.position].push(item.item);\n    return acc;\n  }, initArr);\n};\nvar isMoveOp = function isMoveOp(_ref3) {\n  var op = _ref3.op;\n  return op === 'move';\n};\nvar isRemoveOp = function isRemoveOp(_ref4) {\n  var op = _ref4.op;\n  return op === 'remove';\n};\n\nvar reorderOps = function reorderOps(diff) {\n  var _partitionOps = partitionOps(diff, [isMoveOp, isRemoveOp]),\n      _partitionOps2 = slicedToArray(_partitionOps, 3),\n      moveOps = _partitionOps2[0],\n      removedOps = _partitionOps2[1],\n      restOps = _partitionOps2[2];\n\n  var removeOpsReverse = opsByDescendingOrder(removedOps);\n  return [].concat(toConsumableArray(removeOpsReverse), toConsumableArray(moveOps), toConsumableArray(restOps));\n};\n\nvar defaultInstance$2 = void 0;\n\nvar format$2 = function format(delta, left) {\n  if (!defaultInstance$2) {\n    defaultInstance$2 = new JSONFormatter();\n  }\n  return reorderOps(defaultInstance$2.format(delta, left));\n};\n\nvar log = function log(delta, left) {\n  console.log(format$2(delta, left));\n};\n\n\n\nvar jsonpatch = Object.freeze({\n\tdefault: JSONFormatter,\n\tpartitionOps: partitionOps,\n\tformat: format$2,\n\tlog: log\n});\n\nfunction chalkColor(name) {\n  return chalk && chalk[name] || function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return args;\n  };\n}\n\nvar colors = {\n  added: chalkColor('green'),\n  deleted: chalkColor('red'),\n  movedestination: chalkColor('gray'),\n  moved: chalkColor('yellow'),\n  unchanged: chalkColor('gray'),\n  error: chalkColor('white.bgRed'),\n  textDiffLine: chalkColor('gray')\n};\n\nvar ConsoleFormatter = function (_BaseFormatter) {\n  inherits(ConsoleFormatter, _BaseFormatter);\n\n  function ConsoleFormatter() {\n    classCallCheck(this, ConsoleFormatter);\n\n    var _this = possibleConstructorReturn(this, (ConsoleFormatter.__proto__ || Object.getPrototypeOf(ConsoleFormatter)).call(this));\n\n    _this.includeMoveDestinations = false;\n    return _this;\n  }\n\n  createClass(ConsoleFormatter, [{\n    key: 'prepareContext',\n    value: function prepareContext(context) {\n      get(ConsoleFormatter.prototype.__proto__ || Object.getPrototypeOf(ConsoleFormatter.prototype), 'prepareContext', this).call(this, context);\n      context.indent = function (levels) {\n        this.indentLevel = (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);\n        this.indentPad = new Array(this.indentLevel + 1).join('  ');\n        this.outLine();\n      };\n      context.outLine = function () {\n        this.buffer.push('\\n' + (this.indentPad || ''));\n      };\n      context.out = function () {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        for (var i = 0, l = args.length; i < l; i++) {\n          var lines = args[i].split('\\n');\n          var text = lines.join('\\n' + (this.indentPad || ''));\n          if (this.color && this.color[0]) {\n            text = this.color[0](text);\n          }\n          this.buffer.push(text);\n        }\n      };\n      context.pushColor = function (color) {\n        this.color = this.color || [];\n        this.color.unshift(color);\n      };\n      context.popColor = function () {\n        this.color = this.color || [];\n        this.color.shift();\n      };\n    }\n  }, {\n    key: 'typeFormattterErrorFormatter',\n    value: function typeFormattterErrorFormatter(context, err) {\n      context.pushColor(colors.error);\n      context.out('[ERROR]' + err);\n      context.popColor();\n    }\n  }, {\n    key: 'formatValue',\n    value: function formatValue(context, value) {\n      context.out(JSON.stringify(value, null, 2));\n    }\n  }, {\n    key: 'formatTextDiffString',\n    value: function formatTextDiffString(context, value) {\n      var lines = this.parseTextDiff(value);\n      context.indent();\n      for (var i = 0, l = lines.length; i < l; i++) {\n        var line = lines[i];\n        context.pushColor(colors.textDiffLine);\n        context.out(line.location.line + ',' + line.location.chr + ' ');\n        context.popColor();\n        var pieces = line.pieces;\n        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n          var piece = pieces[pieceIndex];\n          context.pushColor(colors[piece.type]);\n          context.out(piece.text);\n          context.popColor();\n        }\n        if (i < l - 1) {\n          context.outLine();\n        }\n      }\n      context.indent(-1);\n    }\n  }, {\n    key: 'rootBegin',\n    value: function rootBegin(context, type, nodeType) {\n      context.pushColor(colors[type]);\n      if (type === 'node') {\n        context.out(nodeType === 'array' ? '[' : '{');\n        context.indent();\n      }\n    }\n  }, {\n    key: 'rootEnd',\n    value: function rootEnd(context, type, nodeType) {\n      if (type === 'node') {\n        context.indent(-1);\n        context.out(nodeType === 'array' ? ']' : '}');\n      }\n      context.popColor();\n    }\n  }, {\n    key: 'nodeBegin',\n    value: function nodeBegin(context, key, leftKey, type, nodeType) {\n      context.pushColor(colors[type]);\n      context.out(leftKey + ': ');\n      if (type === 'node') {\n        context.out(nodeType === 'array' ? '[' : '{');\n        context.indent();\n      }\n    }\n  }, {\n    key: 'nodeEnd',\n    value: function nodeEnd(context, key, leftKey, type, nodeType, isLast) {\n      if (type === 'node') {\n        context.indent(-1);\n        context.out(nodeType === 'array' ? ']' : '}' + (isLast ? '' : ','));\n      }\n      if (!isLast) {\n        context.outLine();\n      }\n      context.popColor();\n    }\n\n    /* jshint camelcase: false */\n    /* eslint-disable camelcase */\n\n  }, {\n    key: 'format_unchanged',\n    value: function format_unchanged(context, delta, left) {\n      if (typeof left === 'undefined') {\n        return;\n      }\n      this.formatValue(context, left);\n    }\n  }, {\n    key: 'format_movedestination',\n    value: function format_movedestination(context, delta, left) {\n      if (typeof left === 'undefined') {\n        return;\n      }\n      this.formatValue(context, left);\n    }\n  }, {\n    key: 'format_node',\n    value: function format_node(context, delta, left) {\n      // recurse\n      this.formatDeltaChildren(context, delta, left);\n    }\n  }, {\n    key: 'format_added',\n    value: function format_added(context, delta) {\n      this.formatValue(context, delta[0]);\n    }\n  }, {\n    key: 'format_modified',\n    value: function format_modified(context, delta) {\n      context.pushColor(colors.deleted);\n      this.formatValue(context, delta[0]);\n      context.popColor();\n      context.out(' => ');\n      context.pushColor(colors.added);\n      this.formatValue(context, delta[1]);\n      context.popColor();\n    }\n  }, {\n    key: 'format_deleted',\n    value: function format_deleted(context, delta) {\n      this.formatValue(context, delta[0]);\n    }\n  }, {\n    key: 'format_moved',\n    value: function format_moved(context, delta) {\n      context.out('==> ' + delta[1]);\n    }\n  }, {\n    key: 'format_textdiff',\n    value: function format_textdiff(context, delta) {\n      this.formatTextDiffString(context, delta[0]);\n    }\n  }]);\n  return ConsoleFormatter;\n}(BaseFormatter);\n\nvar defaultInstance$3 = void 0;\n\nvar format$3 = function format(delta, left) {\n  if (!defaultInstance$3) {\n    defaultInstance$3 = new ConsoleFormatter();\n  }\n  return defaultInstance$3.format(delta, left);\n};\n\nfunction log$1(delta, left) {\n  console.log(format$3(delta, left));\n}\n\n\n\nvar console$1 = Object.freeze({\n\tdefault: ConsoleFormatter,\n\tformat: format$3,\n\tlog: log$1\n});\n\n\n\nvar index = Object.freeze({\n\tbase: base,\n\thtml: html,\n\tannotated: annotated,\n\tjsonpatch: jsonpatch,\n\tconsole: console$1\n});\n\n// use as 2nd parameter for JSON.parse to revive Date instances\nfunction dateReviver(key, value) {\n  var parts = void 0;\n  if (typeof value === 'string') {\n    // eslint-disable-next-line max-len\n    parts = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d*))?(Z|([+-])(\\d{2}):(\\d{2}))$/.exec(value);\n    if (parts) {\n      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));\n    }\n  }\n  return value;\n}\n\nfunction create(options) {\n  return new DiffPatcher(options);\n}\n\nvar defaultInstance$4 = void 0;\n\nfunction diff() {\n  if (!defaultInstance$4) {\n    defaultInstance$4 = new DiffPatcher();\n  }\n  return defaultInstance$4.diff.apply(defaultInstance$4, arguments);\n}\n\nfunction patch() {\n  if (!defaultInstance$4) {\n    defaultInstance$4 = new DiffPatcher();\n  }\n  return defaultInstance$4.patch.apply(defaultInstance$4, arguments);\n}\n\nfunction unpatch() {\n  if (!defaultInstance$4) {\n    defaultInstance$4 = new DiffPatcher();\n  }\n  return defaultInstance$4.unpatch.apply(defaultInstance$4, arguments);\n}\n\nfunction reverse() {\n  if (!defaultInstance$4) {\n    defaultInstance$4 = new DiffPatcher();\n  }\n  return defaultInstance$4.reverse.apply(defaultInstance$4, arguments);\n}\n\nfunction clone$1() {\n  if (!defaultInstance$4) {\n    defaultInstance$4 = new DiffPatcher();\n  }\n  return defaultInstance$4.clone.apply(defaultInstance$4, arguments);\n}\n\nexports.DiffPatcher = DiffPatcher;\nexports.formatters = index;\nexports.console = console$1;\nexports.create = create;\nexports.dateReviver = dateReviver;\nexports.diff = diff;\nexports.patch = patch;\nexports.unpatch = unpatch;\nexports.reverse = reverse;\nexports.clone = clone$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","import { DiffPatcher } from 'jsondiffpatch'\n\nconst diffPatcher = new DiffPatcher({\n  arrays: { detectMove: false, includeValueOnMove: false },\n  textDiff: { minLength: 1 }\n})\n\nexport function diff(inputA: any, inputB: any) {\n  return diffPatcher.diff(inputA, inputB)\n}\n","import type { Transaction } from 'prosemirror-state'\n\nconst addedProperties = [\n  'docChanged',\n  'isGeneric',\n  'scrolledIntoView',\n  'selectionSet',\n  'storedMarksSet'\n]\n\nexport function addPropertiesToTransaction(tr: Transaction) {\n  return Object.keys(tr)\n    .concat(addedProperties)\n    .reduce((acc, key) => {\n      // @ts-ignore\n      acc[key] = tr[key]\n      return acc\n    }, {} as Transaction)\n}\n","import type { EditorState, Selection, Transaction } from 'prosemirror-state'\nimport { DOMSerializer } from 'prosemirror-model'\nimport { prettyPrint } from 'html'\n\nimport { diff } from './diff'\nimport { addPropertiesToTransaction } from './transaction'\nimport type { HistoryEntry } from '$typings/history'\n\nfunction buildSelection(selection: Selection) {\n  return {\n    // @ts-ignore\n    type: selection.type,\n    empty: selection.empty,\n    anchor: selection.anchor,\n    head: selection.head,\n    from: selection.from,\n    to: selection.to\n  }\n}\n\nfunction pad(num: number) {\n  return ('00' + num).slice(-2)\n}\n\nfunction pad3(num: number) {\n  return ('000' + num).slice(-3)\n}\n\nconst formatTimestamp = (timestamp: number) => {\n  const date = new Date(timestamp)\n  return [\n    pad(date.getHours()),\n    pad(date.getMinutes()),\n    pad(date.getSeconds()),\n    pad3(date.getMilliseconds())\n  ].join(':')\n}\n\nconst regexp = /(&lt;\\/?[\\w\\d\\s=\"']+&gt;)/gim\nconst highlightHtmlString = (html: string) =>\n  html\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(regexp, \"<span style='color: cadetblue;'>$&</span>\")\n\nexport function createHistoryEntry(\n  tr: Transaction,\n  state: EditorState,\n  stateBeforeDispatch: EditorState,\n  oldEntry?: HistoryEntry\n): HistoryEntry {\n  const serializer = DOMSerializer.fromSchema(state.schema)\n  const selection = state.selection\n  const domFragment = serializer.serializeFragment(selection.content().content)\n\n  const selectedElementsAsHtml = []\n  if (domFragment) {\n    let child = domFragment.firstChild as HTMLElement | null\n    while (child) {\n      selectedElementsAsHtml.push(child.outerHTML)\n      child = child.nextSibling as HTMLElement | null\n    }\n  }\n\n  // As described in stateHistory.ts the first entry is a special exception\n  const prevState = oldEntry ? oldEntry.state : stateBeforeDispatch\n  const contentDiff = diff(prevState.doc.toJSON(), state.doc.toJSON())\n  const selectionDiff = diff(buildSelection(prevState.selection), buildSelection(state.selection))\n\n  return {\n    id: Math.random().toString() + Math.random().toString(),\n    state,\n    tr: addPropertiesToTransaction(tr),\n    timestamp: tr.time,\n    timeStr: formatTimestamp(tr.time),\n    contentDiff,\n    selectionDiff,\n    selectionHtml: highlightHtmlString(\n      prettyPrint(selectedElementsAsHtml.join('\\n'), {\n        max_char: 60,\n        indent_size: 2\n      })\n    )\n  }\n}\n","import { get, writable } from 'svelte/store'\nimport { EditorState, Transaction } from 'prosemirror-state'\n\nimport { createHistoryEntry } from '../history-and-diff/createHistoryEntry'\n\nimport type { HistoryEntry, HistoryGroup } from '$typings/history'\n\nexport const stateHistory = writable<Map<string, HistoryEntry>>(new Map())\nexport const shownHistoryGroups = writable<HistoryGroup[]>([])\nexport const latestEntry = writable<HistoryEntry | undefined>(undefined)\n\nexport function appendNewHistoryEntry(\n  tr: Transaction,\n  state: EditorState,\n  stateBeforeDispatch: EditorState\n) {\n  const entryMap = get(stateHistory)\n  const prevGroup = get(shownHistoryGroups)[0]\n  const oldEntry = entryMap.get(prevGroup?.topEntryId || '')\n  // In the case of first entry there aren't oldEntries to diff against, therefore we have to use the state\n  // before the transaction. We can't use it for the next entries because it will always be one state behind,\n  // as the current state is the one _after_ the dispatch. You can observe this in the old dev-tools.\n  const newEntry = createHistoryEntry(tr, state, stateBeforeDispatch, oldEntry)\n\n  stateHistory.update(val => new Map(val.set(newEntry.id, newEntry)))\n  latestEntry.set(newEntry)\n\n  // Groups are subsequent transactions where the doc hasn't changed (eg selection was set) OR the diff was equal\n  // Haven't seen necessary to differentiate between selection-only vs equal diffs\n  const isGroup = !newEntry.contentDiff\n  if (prevGroup?.isGroup && isGroup) {\n    const newGroup = {\n      isGroup,\n      entryIds: [newEntry.id, ...prevGroup.entryIds],\n      topEntryId: newEntry.id,\n      expanded: prevGroup.expanded\n    }\n    shownHistoryGroups.update(val => [newGroup, ...val.slice(1)])\n  } else {\n    const newGroup = {\n      isGroup,\n      entryIds: [newEntry.id],\n      topEntryId: newEntry.id,\n      expanded: false\n    }\n    shownHistoryGroups.update(val => [newGroup, ...val])\n  }\n}\n\nexport function resetHistory() {\n  stateHistory.set(new Map())\n  shownHistoryGroups.set([])\n  latestEntry.set(undefined)\n}\n","import { Selection } from 'prosemirror-state'\n\nconst defaultProperties = ['jsonID', 'empty', 'anchor', 'from', 'head', 'to']\nconst resolvedPosProperties = ['$anchor', '$head', '$cursor', '$to', '$from']\nconst resolvedPosSubProperties = ['nodeAfter', 'nodeBefore', 'textOffset']\n\nexport function createSelection(selection: Selection) {\n  return defaultProperties.reduce((acc, key) => {\n    // @ts-ignore\n    acc[key] = selection[key]\n    return acc\n  }, {} as { [key: string]: any })\n}\n\nexport function createFullSelection(selection: Selection) {\n  return defaultProperties.concat(resolvedPosProperties).reduce((acc, key) => {\n    // @ts-ignore\n    let val = selection[key]\n    if (val && resolvedPosProperties.includes(key)) {\n      const additionalProperties = {}\n      resolvedPosSubProperties.forEach(subKey => {\n        // @ts-ignore\n        additionalProperties[subKey] = val[subKey]\n      })\n      val = { ...val, ...additionalProperties }\n    }\n    acc[key] = val\n    return acc\n  }, {} as { [key: string]: any })\n}\n","export function createNode(index, key, value, depth, parent) {\n    const path = parent ? [...parent.path, index] : [];\n    return {\n        id: `[${path.join(',')}]`,\n        index,\n        key,\n        value,\n        depth: depth + 1,\n        collapsed: true,\n        type: getValueType(value),\n        path,\n        parentId: parent ? parent.id : null,\n        circularOfId: null,\n        children: []\n    };\n}\nexport function getValueType(value) {\n    if (Array.isArray(value)) {\n        return 'array';\n    }\n    else if (value instanceof Map) {\n        return 'map';\n    }\n    else if (value instanceof Set) {\n        return 'set';\n    }\n    else if (value instanceof Date) {\n        return 'date';\n    }\n    else if (value === null) {\n        return 'null';\n    }\n    else {\n        return typeof value;\n    }\n}\n// From redux-dev-tools\n// case 'Object':\n//   case 'Error':\n//   case 'Array':\n//   case 'Iterable':\n//   case 'Map':\n//   case 'Set':\n//   case 'MapEntry':\n//   case 'Number':\n//     return undefined;\n//   case 'String':\n//     return raw => `\"${raw}\"`;\n//   case 'Boolean':\n//     return raw => (raw ? 'true' : 'false');\n//   case 'Date':\n//     return raw => raw.toISOString();\n//   case 'Null':\n//     return () => 'null';\n//   case 'Undefined':\n//     return () => 'undefined';\n//   case 'Function':\n//   case 'Symbol':\n// export function objType(obj: any) {\n//   const type = Object.prototype.toString.call(obj).slice(8, -1)\n//   if (type === 'Object') {\n//     if (typeof obj[Symbol.iterator] === 'function') {\n//       return 'Iterable'\n//     }\n//     return obj.constructor.name\n//   }\n//   return type\n// }\nfunction getChildren(value, type) {\n    switch (type) {\n        case 'array':\n            return value.map((v, i) => [i.toString(), v]);\n        case 'map':\n            // eslint-disable-next-line no-case-declarations\n            const entries = Array.from(value.entries());\n            return entries.map(([key, value], i) => [\n                `[map entry ${i}]`,\n                {\n                    '[key]': key,\n                    '[value]': value\n                }\n            ]);\n        case 'set':\n            return Array.from(value.values()).map((v, i) => [`[set entry ${i}]`, v]);\n        case 'object':\n            return Object.entries(value);\n        default:\n            return [];\n    }\n}\nfunction shouldRecurseChildren(node, parent, iteratedValues, opts) {\n    if (!parent) {\n        // The root node's children should always be recursed\n        return true;\n    }\n    else if (node.collapsed && (parent === null || parent === void 0 ? void 0 : parent.collapsed)) {\n        // If the node's parent is uncollapsed the node's children should still be recursed\n        // in order to compute its value properly eg \"{} 4 keys\" and to place clickable arrow caret.\n        // Only when the node is completely hidden it should not be recursed\n        return false;\n    }\n    else if (!opts.stopCircularRecursion) {\n        return true;\n    }\n    else if (opts.isCircularNode) {\n        return opts.isCircularNode(node, iteratedValues);\n    }\n    else if (node.type === 'object' || node.type === 'array') {\n        const existingNodeWithValue = iteratedValues.get(node.value);\n        if (existingNodeWithValue && node.id !== existingNodeWithValue.id) {\n            node.circularOfId = existingNodeWithValue.id;\n            return false;\n        }\n        iteratedValues.set(node.value, node);\n    }\n    return true;\n}\nexport function recurseObjectProperties(index, key, value, depth, ensureNotCollapsed, parent, treeMap, oldTreeMap, iteratedValues, recomputeExpandNode, opts) {\n    var _a;\n    if (((_a = opts.omitKeys) === null || _a === void 0 ? void 0 : _a.includes(key)) || (opts.maxDepth && depth >= opts.maxDepth)) {\n        return null;\n    }\n    const node = createNode(index, key, value, depth, parent);\n    const oldNode = oldTreeMap.get(node.id);\n    if (ensureNotCollapsed) {\n        // Used to ensure that either root node is always uncollapsed or when uncollapsing new nodes\n        // with expandNodeChildren the node children are recursed (if applicable) with mapChildren\n        node.collapsed = false;\n    }\n    else if (oldNode && !recomputeExpandNode) {\n        // Maintain the same expanded/collapsed toggle for a node in this path/id\n        // EXCEPT when the shouldExpandNode prop is changed...\n        node.collapsed = oldNode.collapsed;\n    }\n    else if (opts.shouldExpandNode) {\n        node.collapsed = !opts.shouldExpandNode(node);\n    }\n    treeMap.set(node.id, node);\n    if (shouldRecurseChildren(node, parent, iteratedValues, opts)) {\n        const mappedChildren = opts.mapChildren && opts.mapChildren(value, getValueType(value), node);\n        const children = mappedChildren !== null && mappedChildren !== void 0 ? mappedChildren : getChildren(value, getValueType(value));\n        node.children = children\n            .map(([key, val], idx) => recurseObjectProperties(idx, key, val, depth + 1, false, node, treeMap, oldTreeMap, iteratedValues, recomputeExpandNode, opts))\n            .filter(n => n !== null);\n    }\n    return node;\n}\nexport function recomputeTree(data, oldTreeMap, recursionOpts, recomputeExpandNode) {\n    const treeMap = new Map();\n    const iteratedValues = new Map();\n    const newTree = recurseObjectProperties(-1, 'root', data, -1, true, null, treeMap, oldTreeMap, iteratedValues, recomputeExpandNode, recursionOpts);\n    return { treeMap, tree: newTree, iteratedValues };\n}\n","<script >import { getContext } from 'svelte';\nexport let id;\nconst { treeStore, propsStore, rootElementStore } = getContext('svelte-tree-view');\nlet node;\n$: {\n    let found = treeStore.getNode(id);\n    // Should explode rather than have logic written around undefinedness\n    // as this component should be unmounted if it's undefined.\n    if (!found) {\n        throw Error('[svelte-tree-view] TreeViewNode.svelte received undefined node from treeMapStore whereas it should be already unmounted!');\n    }\n    node = found;\n}\n$: hasChildren = node && node.children.length > 0;\n$: props = propsStore.props;\n$: valueComponent = $props.valueComponent;\ntreeStore.treeMap.subscribe(value => {\n    const n = value.get(id);\n    if (n && node !== n) {\n        node = n;\n    }\n});\nfunction handleLogNode() {\n    // eslint-disable-next-line no-console\n    console.info('%c [svelte-tree-view]: Property added to window._node', 'color: #b8e248');\n    // eslint-disable-next-line no-console\n    console.log(node.value);\n    try {\n        if (typeof window !== 'undefined')\n            window._node = node.value;\n    }\n    catch (err) {\n        console.error('Failed to set _node, window was undefined');\n    }\n}\nfunction handleCopyNodeToClipboard() {\n    try {\n        navigator.clipboard.writeText(JSON.stringify(node.value));\n    }\n    catch (err) {\n        console.error('Copying node to clipboard failed: ', err);\n    }\n}\nfunction handleToggleCollapse() {\n    var _a;\n    if (hasChildren) {\n        treeStore.toggleCollapse(node.id);\n    }\n    else if (node.circularOfId) {\n        treeStore.expandAllNodesToNode(node.circularOfId);\n        (_a = $rootElementStore.querySelector(`li[data-tree-id=\"${node.circularOfId}\"]`)) === null || _a === void 0 ? void 0 : _a.scrollIntoView();\n    }\n}\nfunction valueComponentDefaultFormatter(val) {\n    return propsStore.formatValue(val, node);\n}\n</script>\n\n<li class=\"row\" class:collapsed={node.collapsed && hasChildren} data-tree-id={node.id}>\n  {#if hasChildren}\n    <button\n      class={`arrow-btn ${node.collapsed ? 'collapsed' : ''}`}\n      on:click={handleToggleCollapse}\n    >\n      \n    </button>\n  {/if}\n  <div\n    class=\"node-key\"\n    class:has-children={hasChildren}\n    class:p-left={!hasChildren}\n    on:click={handleToggleCollapse}\n  >\n    {node.key}:\n  </div>\n  <div\n    class=\"node-value\"\n    data-type={node.type}\n    class:expanded={!node.collapsed && hasChildren}\n    class:has-children={hasChildren}\n    on:click={handleToggleCollapse}\n  >\n    {#if valueComponent}\n      <svelte:component\n        this={valueComponent}\n        value={node.value}\n        {node}\n        defaultFormatter={valueComponentDefaultFormatter}\n      />\n    {:else}\n      {propsStore.formatValue(node.value, node)}\n    {/if}\n  </div>\n  <div class=\"buttons\">\n    {#if $props.showLogButton}\n      <button class=\"log-copy-button\" on:click={handleLogNode}>log</button>\n    {/if}\n    {#if $props.showCopyButton}\n      <button class=\"log-copy-button\" on:click={handleCopyNodeToClipboard}>copy</button>\n    {/if}\n  </div>\n</li>\n{#if !node.collapsed && hasChildren}\n  <li class=\"row\">\n    <ul>\n      {#each node.children as child}\n        <svelte:self id={child.id} />\n      {/each}\n    </ul>\n  </li>\n{/if}\n\n<style >ul {\n  display: flex;\n  flex-direction: column;\n  height: max-content;\n  list-style: none;\n  padding: 0;\n  padding-left: var(--tree-view-left-indent);\n  margin: 0;\n  width: 100%;\n}\n\nli {\n  align-items: baseline;\n  display: flex;\n  height: max-content;\n  line-height: var(--tree-view-line-height);\n  list-style: none;\n  width: 100%;\n}\n\nli + li {\n  margin-top: 0.25em;\n}\n\n.empty-block {\n  visibility: hidden;\n}\n\n.node-key {\n  color: var(--tree-view-base0D);\n  margin-right: var(--tree-view-key-margin-right);\n}\n.node-key.has-children {\n  cursor: pointer;\n}\n.node-key.p-left {\n  padding-left: 1.1em;\n}\n\n.node-value {\n  color: var(--tree-view-base0B);\n  margin-right: 0.5em;\n  word-break: break-all;\n}\n.node-value[data-type=number], .node-value[data-type=boolean] {\n  color: var(--tree-view-base09);\n}\n.node-value[data-type=null], .node-value[data-type=undefined] {\n  color: var(--tree-view-base08);\n}\n.node-value.expanded {\n  color: var(--tree-view-base03);\n}\n.node-value.has-children {\n  cursor: pointer;\n}\n\n.arrow-btn {\n  background: transparent;\n  border: 0;\n  color: var(--tree-view-base0D);\n  cursor: pointer;\n  margin-right: 0.7em;\n  padding: 0;\n  transition: all 150ms ease 0s;\n  transform: rotateZ(90deg);\n  transform-origin: 47% 43%;\n  position: relative;\n  line-height: 1.1em;\n  font-size: 0.75em;\n}\n.arrow-btn.collapsed {\n  transform: rotateZ(0deg);\n}\n\n.buttons {\n  display: flex;\n  flex-wrap: wrap;\n}\n\n.log-copy-button {\n  background: transparent;\n  border: 0;\n  color: var(--tree-view-base0D);\n  cursor: pointer;\n  margin: 0;\n  padding: 0 0.5em;\n}\n.log-copy-button:hover {\n  background: rgba(255, 162, 177, 0.4);\n  border-radius: 2px;\n  color: var(--tree-view-base07);\n}</style>\n","<script >var _a;\nimport { setContext, onMount } from 'svelte';\nimport { get } from 'svelte/store';\nimport { recomputeTree } from './tree-utils';\nimport { createPropsStore, createRootElementStore, createTreeStore, } from './stores';\nimport TreeViewNode from './TreeViewNode.svelte';\nexport let data, theme = undefined, showLogButton = false, showCopyButton = false, valueComponent = undefined, recursionOpts = {}, valueFormatter = undefined;\nlet rootElement = null;\nconst defaultRecursionOpts = {\n    maxDepth: 16,\n    omitKeys: [],\n    stopCircularRecursion: false,\n    shouldExpandNode: () => false\n};\nlet props = {\n    showLogButton,\n    showCopyButton,\n    valueComponent,\n    recursionOpts: Object.assign(Object.assign({}, defaultRecursionOpts), recursionOpts),\n    valueFormatter\n};\n$: rootNode = treeStore.tree;\n$: {\n    // To keep things less messy all props are joined to one object _except_ the recursionOpts\n    // which is picked from the old props. This is to allow checking between the old and new recursionOpts\n    // in the recomputeTree.\n    props = {\n        showLogButton,\n        showCopyButton,\n        valueComponent,\n        valueFormatter,\n        recursionOpts: props.recursionOpts\n    };\n}\n$: {\n    // Combine the defaultProps with the possible new recursion opts\n    const newRecursionOpts = Object.assign(Object.assign({}, defaultRecursionOpts), recursionOpts);\n    // Compare the old shouldExpandNode option with the possible new shouldExpandNode\n    // to know whether to whole tree should be recomputed.\n    const recomputeExpandNode = ((_a = props === null || props === void 0 ? void 0 : props.recursionOpts) === null || _a === void 0 ? void 0 : _a.shouldExpandNode) !== newRecursionOpts.shouldExpandNode;\n    const oldTreeMap = get(treeStore.treeMap);\n    const { treeMap, tree, iteratedValues } = recomputeTree(data, oldTreeMap, newRecursionOpts, recomputeExpandNode);\n    treeStore.init(tree, treeMap, iteratedValues);\n    props.recursionOpts = newRecursionOpts;\n    propsStore.setProps(props);\n}\n$: {\n    if (theme && rootElement) {\n        let key;\n        for (key in theme) {\n            // This ridiculous thing is for TypeScript type inference. Yey..?\n            const value = theme[key];\n            if (rootElement && key.includes('--tree-view-base') && value) {\n                rootElement.style.setProperty(`--tree-view-${key}`, value);\n            }\n        }\n    }\n}\nconst propsStore = createPropsStore(props);\nconst rootElementStore = createRootElementStore();\nconst treeStore = createTreeStore(propsStore);\nsetContext('svelte-tree-view', {\n    propsStore,\n    rootElementStore,\n    treeStore,\n});\nonMount(() => {\n    rootElementStore.set(rootElement);\n});\n</script>\n\n<ul class={`${$$props.class || ''} svelte-tree-view`} bind:this={rootElement}>\n  {#each $rootNode.children as child}\n    <TreeViewNode id={child.id} />\n  {/each}\n</ul>\n\n<style>\n  * {\n    box-sizing: border-box;\n  }\n  :root {\n    --tree-view-base00: #363755;\n    --tree-view-base01: #604d49;\n    --tree-view-base02: #6d5a55;\n    --tree-view-base03: #d1929b;\n    --tree-view-base04: #b79f8d;\n    --tree-view-base05: #f9f8f2;\n    --tree-view-base06: #f7f4f1;\n    --tree-view-base07: #faf8f5;\n    --tree-view-base08: #fa3e7e;\n    --tree-view-base09: #fd993c;\n    --tree-view-base0A: #f6bf81;\n    --tree-view-base0B: #b8e248;\n    --tree-view-base0C: #b4efe4;\n    --tree-view-base0D: #85d9ef;\n    --tree-view-base0E: #be87ff;\n    --tree-view-base0F: #d6724c;\n\n    --tree-view-font-family: 'Helvetica Neue', 'Calibri Light', Roboto, sans-serif;\n    --tree-view-font-size: 13px;\n    --tree-view-left-indent: 0.875em;\n    --tree-view-line-height: 1.1;\n    --tree-view-key-margin-right: 0.5em;\n  }\n  ul {\n    background: var(--tree-view-base00);\n    font-family: var(--tree-view-font-family);\n    font-size: var(--tree-view-font-size);\n    height: max-content;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: max-content;\n  }\n</style>\n","import { derived, get, writable } from 'svelte/store';\nexport const createPropsStore = (initialProps) => {\n    const props = writable(initialProps);\n    const recursionOpts = derived(props, p => p.recursionOpts);\n    return {\n        props,\n        recursionOpts,\n        setProps(newProps) {\n            props.set(newProps);\n        },\n        formatValue(val, node) {\n            const { valueFormatter } = get(props);\n            const customFormat = valueFormatter ? valueFormatter(val, node) : undefined;\n            if (customFormat) {\n                return customFormat;\n            }\n            switch (node.type) {\n                case 'array':\n                    return `${node.circularOfId ? 'circular' : ''} [] ${val.length} items`;\n                case 'object':\n                    return `${node.circularOfId ? 'circular' : ''} {} ${Object.keys(val).length} keys`;\n                case 'map':\n                case 'set':\n                    return `${node.circularOfId ? 'circular' : ''} () ${val.size} entries`;\n                case 'date':\n                    return `${val.toISOString()}`;\n                case 'string':\n                    return `\"${val}\"`;\n                case 'boolean':\n                    return val ? 'true' : 'false';\n                default:\n                    return val;\n            }\n        }\n    };\n};\n","import { writable } from 'svelte/store';\nexport const createRootElementStore = () => {\n    const rootElementStore = writable(null);\n    return {\n        set: rootElementStore.set,\n        subscribe: rootElementStore.subscribe\n    };\n};\n","import { get, writable } from 'svelte/store';\nimport { createNode, recurseObjectProperties } from '../tree-utils';\nexport const createTreeStore = (propsStore) => {\n    const defaultRootNode = createNode(0, 'root', [], 0, null);\n    const tree = writable(defaultRootNode);\n    const treeMap = writable(new Map());\n    const iteratedValues = writable(new Map());\n    return {\n        tree,\n        treeMap,\n        defaultRootNode,\n        init(newTree, newTreeMap, iterated) {\n            if (newTree) {\n                tree.set(newTree);\n            }\n            else {\n                tree.set(defaultRootNode);\n            }\n            treeMap.set(newTreeMap);\n            iteratedValues.set(iterated);\n        },\n        getNode(id) {\n            return get(treeMap).get(id);\n        },\n        toggleCollapse(id) {\n            const node = get(treeMap).get(id);\n            if (!node) {\n                console.warn(`Attempted to collapse non-existent node: ${id}`);\n                return;\n            }\n            const updatedNode = { ...node, collapsed: !node.collapsed };\n            treeMap.update(m => new Map(m.set(node.id, updatedNode)));\n            const recursionOpts = get(propsStore.recursionOpts);\n            if (recursionOpts) {\n                this.expandNodeChildren(updatedNode, recursionOpts);\n            }\n        },\n        expandNodeChildren(node, recursionOpts) {\n            const parent = this.getNode((node === null || node === void 0 ? void 0 : node.parentId) || '') || null;\n            if (!parent) {\n                // Only root node has no parent and it should not be expandable\n                throw Error('No parent in expandNodeChildren for node: ' + node);\n            }\n            const newTreeMap = new Map(get(treeMap));\n            const oldTreeMap = get(treeMap);\n            const previouslyIterated = get(iteratedValues);\n            const nodeWithUpdatedChildren = recurseObjectProperties(node.index, node.key, node.value, node.depth, !node.collapsed, // Ensure that when uncollapsed the node's children are always recursed\n            parent, newTreeMap, oldTreeMap, previouslyIterated, false, // Never recompute shouldExpandNode since it may override the collapsing of this node\n            recursionOpts);\n            if (!nodeWithUpdatedChildren)\n                return;\n            parent.children = parent.children.map(c => c.id === nodeWithUpdatedChildren.id ? nodeWithUpdatedChildren : c);\n            newTreeMap.set(nodeWithUpdatedChildren.id, nodeWithUpdatedChildren);\n            newTreeMap.set(parent.id, parent);\n            treeMap.set(newTreeMap);\n            iteratedValues.set(previouslyIterated);\n        },\n        expandAllNodesToNode(id) {\n            function recurseNodeUpwards(updated, node) {\n                if (!node)\n                    return;\n                updated.set(node.id, { ...node, collapsed: false });\n                if (node.parentId) {\n                    recurseNodeUpwards(updated, updated.get(node.parentId));\n                }\n            }\n            const updated = new Map(get(treeMap));\n            recurseNodeUpwards(updated, updated.get(id));\n            treeMap.set(updated);\n        }\n    };\n};\n","<section class=\"split-view\">\n  <slot class=\"left-panel\" name=\"left\" />\n  <slot class=\"right-panel\" name=\"right\" />\n</section>\n\n<style lang=\"scss\">\n  section {\n    border-top: 1px solid rgba($color-red-light, 0.2);\n    color: var(--color-white);\n    display: flex;\n    height: calc(100% - var(--height-tabs-menu));\n    width: 100%;\n  }\n  :global(.split-view h2) {\n    color: var(--color-red-gray);\n    font-family: var(--font-sans);\n    font-size: var(--font-medium);\n    font-weight: 400;\n    letter-spacing: 1px;\n    margin: 0;\n    text-transform: uppercase;\n  }\n  :global(.split-view > .left-panel) {\n    display: flex;\n    flex-direction: column;\n    flex-grow: 1;\n    overflow: scroll;\n    padding: 1em;\n  }\n  :global(.split-view > .right-panel) {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    display: flex;\n    flex-direction: column;\n    flex-grow: 1;\n    overflow: scroll;\n    padding: 1em;\n  }\n  :global(.split-view .hidden) {\n    visibility: hidden;\n  }\n</style>\n","<script lang=\"ts\">\n  export let selected = false\n  let buttonProps = {\n    class: [$$restProps.class]\n  }\n</script>\n\n<button on:click on:mouseover on:mouseenter on:mouseleave on:focus {...buttonProps} class:selected\n  ><slot /></button\n>\n\n<style lang=\"scss\">\n  button {\n    background: transparent;\n    border: 0;\n    border-radius: 2px;\n    color: var(--color-gray-light);\n    cursor: pointer;\n    font-size: var(--font-small);\n    padding: 6px 10px;\n    text-transform: uppercase;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: var(--color-white);\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n    }\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n  import { latestEntry } from '$stores/stateHistory'\n  import { getActiveMarks } from './getActiveMarks'\n  import { createSelection, createFullSelection } from './selection'\n\n  import TreeView from 'svelte-tree-view'\n  import type { TreeNode } from 'svelte-tree-view'\n  import SplitView from '../SplitView.svelte'\n  import Button from '$components/Button.svelte'\n\n  const { view } = getContext('editor-view')\n  let doc = view.state.doc.toJSON()\n  let selection = createSelection(view.state.selection)\n  let currentState = view.state\n  let activeMarks: string[] = []\n  let nodeSize = view.state.doc.nodeSize\n  let childCount = view.state.doc.childCount\n  let expandedSelection = false\n\n  latestEntry.subscribe(e => {\n    if (!e) return\n    const { state } = e\n    currentState = state\n    doc = state.doc.toJSON()\n    selection = expandedSelection\n      ? createFullSelection(state.selection)\n      : createSelection(state.selection)\n    activeMarks = getActiveMarks(state)\n    nodeSize = state.doc.nodeSize\n    childCount = state.doc.childCount\n  })\n\n  function handleClickLogDoc() {\n    console.log(doc)\n    window._doc = doc\n  }\n  function handleExpandSelection() {\n    expandedSelection = !expandedSelection\n    if (expandedSelection) {\n      selection = createFullSelection(currentState.selection)\n    } else {\n      selection = createSelection(currentState.selection)\n    }\n  }\n  function formatDocNodeValue(val: any, n: TreeNode) {\n    if (n.type === 'object' && val.type) {\n      return `{} ${val.type}`\n    }\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <div class=\"top-row\">\n      <h2>Current doc</h2>\n      <Button on:click={handleClickLogDoc}>log</Button>\n    </div>\n    <TreeView\n      class=\"tree-view\"\n      data={doc}\n      showLogButton\n      showCopyButton\n      valueFormatter={formatDocNodeValue}\n    />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    <div class=\"top-row\">\n      <h2>Selection</h2>\n      <Button class=\"selection-btn\" on:click={handleExpandSelection}\n        ><span class=\"caret-icon\" class:expanded={expandedSelection} /></Button\n      >\n    </div>\n    <TreeView class=\"tree-view\" data={selection} />\n    <div>\n      <h2>Active marks</h2>\n      {#if activeMarks.length === 0}\n        <div class=\"no-marks\">No active marks</div>\n      {:else}\n        <TreeView class=\"tree-view\" data={activeMarks} />\n      {/if}\n    </div>\n    <div>\n      <h2>Document stats</h2>\n      <TreeView\n        class=\"tree-view\"\n        data={{\n          nodeSize,\n          childCount\n        }}\n      />\n    </div>\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .left-panel {\n    overflow: scroll;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    flex-grow: 0;\n    min-width: 200px;\n    width: 200px;\n  }\n  :global(.split-view .selection-btn) {\n    height: 24px;\n    width: 35px;\n  }\n  .caret-icon::before {\n    content: '';\n  }\n  .caret-icon.expanded::before {\n    content: '';\n  }\n  .no-marks {\n    color: var(--color-blue-light);\n    margin: 0.5em 0 1em 1em;\n  }\n  :global(.split-view .tree-view) {\n    margin: 0.5em 0 1em 0;\n  }\n</style>\n","import { EditorState } from 'prosemirror-state'\n\n// From https://github.com/PierBover/prosemirror-cookbook\nexport function getActiveMarks(state: EditorState): string[] {\n  if (state.selection.empty) {\n    const $from = state.selection.$from\n    const storedMarks = state.storedMarks\n\n    // Return either the stored marks, or the marks at the cursor position.\n    // Stored marks are the marks that are going to be applied to the next input\n    // if you dispatched a mark toggle with an empty cursor.\n    if (storedMarks) {\n      return storedMarks.map(mark => mark.type.name)\n    } else {\n      return $from.marks().map(mark => mark.type.name)\n    }\n  } else {\n    const $head = state.selection.$head\n    const $anchor = state.selection.$anchor\n\n    // We're using a Set to not get duplicate values\n    const activeMarks = new Set<string>()\n\n    // Here we're getting the marks at the head and anchor of the selection\n    $head.marks().forEach(mark => activeMarks.add(mark.type.name))\n    $anchor.marks().forEach(mark => activeMarks.add(mark.type.name))\n\n    return Array.from(activeMarks)\n  }\n}\n","import type { Delta } from 'jsondiffpatch'\nimport type { TreeNode, ValueType } from 'svelte-tree-view'\n\n// function postprocessValue(value: any) {\n//   if (value && value._t === 'a') {\n//     const res: { [key: string]: string | string[] } = {}\n//     for (const key in value) {\n//       if (key !== '_t') {\n//         if (key[0] === '_' && !value[key.substr(1)]) {\n//           res[key.substr(1)] = value[key]\n//         } else if (value['_' + key]) {\n//           res[key] = [value['_' + key][0], value[key][0]]\n//         } else if (!value['_' + key] && key[0] !== '_') {\n//           res[key] = value[key]\n//         }\n//       }\n//     }\n//     return res\n//   }\n//   return value\n// }\n\nexport function mapSelectionDeltaChildren(\n  _val: any,\n  type: ValueType,\n  _parent: TreeNode\n): [string, any][] | undefined {\n  if (type !== 'array') return\n  return []\n}\n\n/**\n * Magic function to transform jsondiffpatch array deltas\n * https://github.com/benjamine/jsondiffpatch/blob/master/docs/deltas.md\n * https://benjamine.github.io/jsondiffpatch/demo/index.html\n */\nexport function mapDocDeltaChildren(delta: Delta, type: ValueType) {\n  // So due to the way the tree-view works, it will automatically map the children of an array\n  // to their own nodes. For diff deltas, however, we want to omit those children and just show\n  // a value wrapped with <span> to show either deleted or inserted content\n  if (type === 'array' && delta[1] === 0 && delta[2] === 0) {\n    // Remove operation is defined by two 0s in its delta [{ <deleted> }, 0, 0]\n    return []\n    // } else if (type === 'array' && typeof delta[0] === 'string' && typeof delta[1] === 'number' && delta[2] === 3) {\n    // Move operation is almost the same as remove, except its value is empty and the second number\n    // points to the moved index eg [\"\", 6, 3] AND the third value is always '3'\n    // But since these seem to never occur (and they weren't handled in the previous version) we are not doing anything\n    // with them for now.\n  } else if (type === 'array' && typeof delta[0] === 'string' && delta[1] === 0 && delta[2] === 2) {\n    // If a diff between two strings gets too long, a text diff algorithm is used which produces an array\n    // with unidiff as the first value, 0 as the second and 2 as third.\n    // Eg [\"@@ -1,4 +1,9 @@\\n-text\\n+paragraph\\n\", 0, 2]\n    return []\n  } else if (type === 'array' && delta.length === 1 && typeof delta[0] === 'object') {\n    // Insert operations do not have indexes (it's already indexed in the array) and carry\n    // only an object payload eg [{ <inserted> }]\n    return []\n  }\n\n  // The main delta objects are objects denoted by key '_t' with 'a' value which we shall omit.\n  // DiffValue component handles the text diffs otherwise.\n  if (type !== 'object' || delta._t !== 'a') return\n\n  // We shall remap the values to omit '_t' and remove underscores from the keys\n  const transformed: [string, any][] = []\n  for (const key in delta) {\n    if (key === '_t') continue\n    // Remove or move operation is indicated by an underscore before the index eg '_2'\n    if (key.charAt(0) === '_') {\n      transformed.push([key.substr(1), delta[key]])\n    } else {\n      transformed.push([key, delta[key]])\n    }\n  }\n  return transformed\n}\n","<script lang=\"ts\">\n  import type { HistoryEntry } from '$typings/history'\n\n  export let listItems: {\n      isGroup: boolean\n      topEntry: HistoryEntry | undefined\n      entries: (HistoryEntry | undefined)[]\n      expanded: boolean\n    }[] = [],\n    selectedId: string,\n    onSelect: (id: string, groupIdx: number, wasTopNode: boolean) => void\n</script>\n\n<ul>\n  {#each listItems as group, groupIdx}\n    <li class:selected={!group.expanded && selectedId === group?.topEntry?.id}>\n      <button\n        class:is-group={group.isGroup}\n        on:click={() => group.topEntry && onSelect(group.topEntry.id, groupIdx, true)}\n      >\n        <span>\n          {group?.topEntry?.timeStr}\n          {#if group.isGroup}\n            [{group.entries.length}]\n          {/if}\n        </span>\n        {#if group.isGroup && group.entries.length > 1}\n          <span class=\"caret-icon\" class:expanded={group.expanded} />\n        {/if}\n      </button>\n    </li>\n    {#if group.isGroup && group.expanded}\n      {#each group.entries as subEntry}\n        <li class:selected={selectedId === subEntry?.id}>\n          <button\n            class=\"p-left\"\n            on:click={() => subEntry && onSelect(subEntry.id, groupIdx, false)}\n          >\n            {subEntry?.timeStr}\n          </button>\n        </li>\n      {/each}\n    {/if}\n  {/each}\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    color: var(--color-white);\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n    width: 100%;\n  }\n  li {\n    transition: background 0.1s;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: var(--color-white);\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n    }\n  }\n  li + li {\n    border-top: 1px solid var(--color-purple);\n  }\n  button {\n    background: transparent;\n    border: 0;\n    color: var(--color-gray-light);\n    cursor: pointer;\n    display: flex;\n    font-family: monospace;\n    font-size: var(--font-small);\n    height: 100%;\n    justify-content: space-between;\n    padding: 6px 18px;\n    text-transform: uppercase;\n    width: 100%;\n\n    &.p-left {\n      margin-left: 1em;\n    }\n  }\n  .caret-icon::before {\n    content: '';\n  }\n  .caret-icon.expanded::before {\n    content: '';\n  }\n</style>\n","<script lang=\"ts\">\n  import type { TreeNode } from 'svelte-tree-view'\n\n  export let value: any, node: TreeNode, defaultFormatter: (val: any) => string\n\n  $: nodeVal = node.value\n\n  function replaceSpacesWithNonBreakingSpace(value: string) {\n    return value.replace(/\\s/gm, '')\n  }\n  function parseTextDiff(textDiff: string) {\n    const diffByLines = textDiff.split(/\\n/gm).slice(1)\n    return diffByLines.map(line => {\n      const type = line.startsWith('-') ? 'delete' : line.startsWith('+') ? 'add' : 'raw'\n\n      return { [type]: replaceSpacesWithNonBreakingSpace(line.substr(1)) }\n    })\n  }\n  function stringifyAndShrink(v: any) {\n    if (v === null) {\n      return 'null'\n    }\n    const str = JSON.stringify(v)\n    if (typeof str === 'undefined') {\n      return 'undefined'\n    }\n    return str.length > 22 ? `${str.substr(0, 15)}${str.substr(-5)}` : str\n  }\n\n  function getValueString(raw: any) {\n    if (typeof raw === 'string') {\n      return raw\n    }\n    return stringifyAndShrink(raw)\n  }\n</script>\n\n{#if Array.isArray(nodeVal)}\n  <!-- The why https://github.com/benjamine/jsondiffpatch/blob/master/docs/deltas.md -->\n  {#if nodeVal.length === 1}\n    <span class=\"added\">{getValueString(nodeVal[0])}</span>\n  {:else if nodeVal.length === 2}\n    <span class=\"updated\">\n      <span class=\"deleted\">{getValueString(nodeVal[0])}</span>\n      <span class=\"arrow\"> =&gt;</span>\n      <span class=\"added\">{getValueString(nodeVal[1])}</span>\n    </span>\n  {:else if nodeVal.length === 3 && nodeVal[1] === 0 && nodeVal[2] === 0}\n    <span class=\"deleted\">{getValueString(nodeVal[0])}</span>\n  {:else if nodeVal.length === 3 && nodeVal[2] === 2}\n    <span class=\"updated\">\n      {#each parseTextDiff(nodeVal[0]) as item}\n        {#if item.delete}\n          <span class=\"deleted\">{item.delete}</span>\n        {:else if item.add}\n          <span class=\"added\">{item.add}</span>\n        {:else}\n          <span>{item.raw}</span>\n        {/if}\n      {/each}\n    </span>\n  {/if}\n{:else}\n  {defaultFormatter(nodeVal)}\n{/if}\n\n<style>\n  .added {\n    display: inline-block;\n    background: var(--color-green-light);\n    border-radius: 1px;\n    color: var(--color-green);\n    padding: 1px 2px;\n    text-indent: 0;\n    min-height: 1ex;\n  }\n  .deleted {\n    display: inline-block;\n    background: var(--color-red);\n    border-radius: 1px;\n    color: var(--color-gray-light);\n    padding: 1px 2px;\n    text-decoration: line-through;\n    text-indent: 0;\n    min-height: 1ex;\n  }\n  .updated {\n    word-break: break-all;\n  }\n  .updated .added {\n    background: var(--color-yellow);\n  }\n  .arrow {\n    color: var(--color-green-light);\n  }\n</style>\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","<script lang=\"ts\">\n  import { stateHistory, shownHistoryGroups, latestEntry } from '$stores/stateHistory'\n  import type { HistoryEntry, HistoryGroup } from '$typings/history'\n  import { mapDocDeltaChildren, mapSelectionDeltaChildren } from './mapDeltas'\n\n  import SplitView from '../SplitView.svelte'\n  import TreeView from 'svelte-tree-view'\n  import HistoryList from './HistoryList.svelte'\n  import DiffValue from './DiffValue.svelte'\n  import Button from '$components/Button.svelte'\n\n  let selectedEntry: HistoryEntry | undefined = undefined,\n    showTr = false\n\n  let expandTrTreeView = false\n  let transactionRecursionOpts = {\n    maxDepth: 12,\n    stopCircularRecursion: true,\n    omitKeys: ['schema'],\n    shouldExpandNode: () => expandTrTreeView\n  }\n  $: listItems = $shownHistoryGroups.map((g: HistoryGroup) => ({\n    isGroup: g.isGroup,\n    topEntry: $stateHistory.get(g.topEntryId),\n    entries: g.entryIds.map(id => $stateHistory.get(id)),\n    expanded: g.expanded\n  }))\n  latestEntry.subscribe(v => {\n    if (v) selectedEntry = v\n  })\n\n  function toggleShowTr() {\n    showTr = !showTr\n  }\n  function handleLogTr() {\n    console.info('%c [prosemirror-dev-toolkit]: Property added to window._tr', 'color: #b8e248')\n    console.log(selectedEntry?.tr)\n    window._tr = selectedEntry?.tr\n  }\n  /**\n   * Handles the clicks of the history entries.\n   *\n   * Sets the clicked entry as the selectedEntry but in the case of topNode, meaning\n   * in a selection group (shown with [x] number) the entry has a sublist of entries\n   * where the previous is duplicated as the first entry. Therefore on expanding the group\n   * selecting the first sub-entry, otherwise collapsing but still keeping the topNode selected.\n   * Kinda confusing but eh.\n   */\n  function handleEntrySelect(id: string, groupIdx: number, wasTopNode: boolean) {\n    selectedEntry = $stateHistory.get(id)\n    const group = listItems[groupIdx]\n    if (group.isGroup && group.entries.length > 1 && wasTopNode) {\n      shownHistoryGroups.update(val =>\n        val.map((g, idx) => (idx !== groupIdx ? g : { ...g, expanded: !g.expanded }))\n      )\n    }\n  }\n  function handleToggleExpandTrTreeView() {\n    expandTrTreeView = !expandTrTreeView\n    transactionRecursionOpts = {\n      ...transactionRecursionOpts,\n      shouldExpandNode: () => expandTrTreeView\n    }\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <!-- Cant use optional chaining here as it wont get transpiled correctly to ES5 :( -->\n    <HistoryList {listItems} selectedId={selectedEntry?.id || ''} onSelect={handleEntrySelect} />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    {#if selectedEntry}\n      <div>\n        {#if selectedEntry.contentDiff}\n          <div class=\"entry-row\">\n            <div class=\"title-container\">\n              <h2>Doc diff</h2>\n              <Button class=\"hidden\">log</Button>\n            </div>\n            <TreeView\n              class=\"tree-view\"\n              data={selectedEntry.contentDiff}\n              showLogButton\n              showCopyButton\n              valueComponent={DiffValue}\n              recursionOpts={{\n                maxDepth: 12,\n                mapChildren: mapDocDeltaChildren,\n                shouldExpandNode: () => true\n              }}\n            />\n          </div>\n        {/if}\n        {#if selectedEntry.selectionDiff}\n          <div class=\"entry-row\">\n            <div class=\"title-container\">\n              <h2>Selection diff</h2>\n              <Button class=\"hidden\">log</Button>\n            </div>\n            <TreeView\n              class=\"tree-view\"\n              data={selectedEntry.selectionDiff}\n              valueComponent={DiffValue}\n              recursionOpts={{\n                mapChildren: mapSelectionDeltaChildren,\n                shouldExpandNode: () => true\n              }}\n            />\n          </div>\n        {/if}\n        {#if selectedEntry.selectionHtml.length > 0}\n          <div class=\"entry-row\">\n            <div class=\"title-container\">\n              <h2>Selection content</h2>\n              <Button class=\"hidden\">log</Button>\n            </div>\n            <pre class=\"selection-html\"><code>{@html selectedEntry.selectionHtml}</code></pre>\n          </div>\n        {/if}\n        <div class=\"entry-row\">\n          <div class=\"title-container\">\n            <h2>Transaction</h2>\n            <div>\n              {#if showTr}\n                <Button on:click={handleToggleExpandTrTreeView}>\n                  {expandTrTreeView ? 'collapse' : 'expand'}\n                </Button>\n                <Button on:click={handleLogTr}>log</Button>\n              {/if}\n              <Button on:click={toggleShowTr}>\n                {showTr ? 'hide' : 'show'}\n              </Button>\n            </div>\n          </div>\n          {#if showTr}\n            <TreeView\n              class=\"tree-view\"\n              data={selectedEntry.tr}\n              showLogButton\n              showCopyButton\n              recursionOpts={transactionRecursionOpts}\n            />\n          {/if}\n        </div>\n      </div>\n    {:else}\n      <div class=\"equal-diff\">Docs are equal.</div>\n    {/if}\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  :global(.hidden) {\n    display: none;\n    visibility: hidden;\n  }\n  .left-panel {\n    flex-grow: 0;\n    padding: 0;\n    min-width: 190px;\n    width: 190px;\n  }\n  .title-container {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .entry-row + .entry-row {\n    margin-top: 1em;\n  }\n  .selection-html {\n    font-weight: 100;\n    margin: 0.5em 0 0 0;\n    padding: 0;\n  }\n  .equal-diff {\n    align-items: center;\n    color: var(--color-red-light);\n    display: flex;\n    font-size: 14px;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n  }\n</style>\n","<script lang=\"ts\">\n  export let listItems: { key: string; value: string }[] = [],\n    selectedKey: string | undefined,\n    onSelect: (item: { key: string; value: string }) => void\n</script>\n\n<ul>\n  {#each listItems as item}\n    <li>\n      <button class:selected={selectedKey === item.key} on:click={() => onSelect(item)}\n        >{item.value}</button\n      >\n    </li>\n  {/each}\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    color: var(--color-white);\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n    width: 100%;\n  }\n  li + li {\n    border-top: 1px solid var(--color-purple);\n  }\n  button {\n    background: transparent;\n    border: 0;\n    color: var(--color-gray-light);\n    cursor: pointer;\n    display: flex;\n    font-family: monospace;\n    font-size: var(--font-small);\n    font-weight: 100;\n    height: 100%;\n    padding: 6px 18px;\n    text-transform: uppercase;\n    width: 100%;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: var(--color-white);\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n    }\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n  import type { EditorState } from 'prosemirror-state'\n  import { latestEntry } from '$stores/stateHistory'\n\n  import SplitView from './SplitView.svelte'\n  import TreeView from 'svelte-tree-view'\n  import List from './List.svelte'\n  import Button from '$components/Button.svelte'\n\n  import type { Plugin } from '$typings/pm'\n\n  const { view } = getContext('editor-view')\n  let expandPluginState = false\n  let recursionOpts = {\n    maxDepth: 10,\n    stopCircularRecursion: true,\n    shouldExpandNode: () => expandPluginState\n  }\n  let editorState: EditorState = view.state\n  let plugins = editorState.plugins as Plugin[]\n  let selectedPlugin = plugins[0] as Plugin | undefined\n  $: pluginState = selectedPlugin?.getState(editorState) as any\n  $: listItems = plugins.map((p: Plugin) => ({\n    key: p.key, // TODO this can be undefined??\n    value: p.key.toUpperCase(),\n    empty: !p.getState(editorState)\n  }))\n\n  latestEntry.subscribe(e => {\n    if (!e) return\n    editorState = e.state\n    plugins = editorState.plugins as Plugin[]\n    selectedPlugin = plugins.find(p => p.key === selectedPlugin?.key) as Plugin\n  })\n\n  function handlePluginSelect(item: { key: string; value: string }) {\n    selectedPlugin = plugins.find(p => p.key === item.key) as Plugin\n  }\n  function handleToggleExpand() {\n    expandPluginState = !expandPluginState\n    recursionOpts = { ...recursionOpts, shouldExpandNode: () => expandPluginState }\n  }\n  function handleLogState() {\n    window._plugin = [selectedPlugin, pluginState]\n    console.info('%c [prosemirror-dev-toolkit]: Property added to window._plugin', 'color: #b8e248')\n    console.log(selectedPlugin)\n    console.log(pluginState)\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <List {listItems} selectedKey={selectedPlugin?.key} onSelect={handlePluginSelect} />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    {#if pluginState}\n      <div class=\"top-row\">\n        <h2>Plugin state</h2>\n        <div>\n          <Button on:click={handleToggleExpand}>\n            {expandPluginState ? 'collapse' : 'expand'}\n          </Button>\n          <Button on:click={handleLogState}>log</Button>\n        </div>\n      </div>\n    {/if}\n    {#if pluginState}\n      <TreeView data={pluginState} showLogButton showCopyButton {recursionOpts} />\n    {:else}\n      <div class=\"empty-state\">Plugin has no state</div>\n    {/if}\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n    margin-bottom: 0.5em;\n  }\n  .left-panel {\n    flex-grow: 0;\n    overflow: scroll;\n    padding: 0;\n    min-width: 190px;\n    width: 190px;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n  }\n  .empty-state {\n    align-items: center;\n    color: var(--color-red-light);\n    display: flex;\n    font-size: 14px;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n\n  import TreeView from 'svelte-tree-view'\n  import SplitView from './SplitView.svelte'\n  import Button from '$components/Button.svelte'\n\n  const { view } = getContext('editor-view')\n\n  let nodes = view.state.schema.nodes\n  let marks = view.state.schema.marks\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <div class=\"top-row\">\n      <h2>Nodes</h2>\n      <Button class=\"hidden\">log</Button>\n    </div>\n    <TreeView\n      class=\"tree-view\"\n      data={nodes}\n      showLogButton\n      showCopyButton\n      recursionOpts={{\n        stopCircularRecursion: true\n      }}\n    />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    <div class=\"top-row\">\n      <h2>Marks</h2>\n      <Button class=\"hidden\">log</Button>\n    </div>\n    <TreeView\n      class=\"tree-view\"\n      data={marks}\n      showLogButton\n      showCopyButton\n      recursionOpts={{\n        stopCircularRecursion: true\n      }}\n    />\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  :global(.hidden) {\n    display: none;\n    visibility: hidden;\n  }\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .left-panel {\n    overflow: scroll;\n    padding: 1em;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    overflow: scroll;\n    padding: 1em;\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n  import type { Node as PMNode } from 'prosemirror-model'\n  import type { Fragment } from '$typings/pm'\n\n  const { colors, handleNodeClick } = getContext('doc-view')\n\n  export let node: PMNode,\n    startPos: number,\n    isRoot = false\n\n  $: fragment = node.content as Fragment\n  $: color = colors[node.type.name]\n  $: name =\n    node.isText && node.marks.length > 0\n      ? `${node.type.name} - [${node.marks.map(m => m.type.name).join(', ')}]`\n      : node.type.name\n\n  $: startPositions = Array(node.childCount)\n    .fill(undefined)\n    .reduce((acc, _, idx) => {\n      if (idx === 0) {\n        return [isRoot ? 0 : startPos + 1]\n      }\n      let prev = acc[idx - 1]\n      let cur = node.child(idx - 1)\n      return [...acc, prev + cur.nodeSize]\n    }, [])\n\n  $: endPos = startPos + node.nodeSize\n  $: inlineChildren = fragment.content.every(n => n.isInline)\n\n  function handleNameClick() {\n    handleNodeClick(node)\n  }\n</script>\n\n<li class={`${$$props.class || ''} doc-node`} class:root={isRoot}>\n  <div class=\"doc-node-body\" style={`background: ${color}`}>\n    <div class=\"number-box\">{startPos}</div>\n    <button class:selected={false} aria-label=\"Show node info button\" on:click={handleNameClick}\n      >{name}</button\n    >\n    <div class=\"number-box\">{endPos}</div>\n  </div>\n  <ul class:inline-children={inlineChildren}>\n    {#each fragment.content as child, i}\n      <svelte:self node={child} startPos={startPositions[i]} />\n    {/each}\n  </ul>\n</li>\n\n<style lang=\"scss\">\n  .doc-node {\n    border-left: 1px solid var(--color-blue-bg);\n    border-right: 1px solid var(--color-blue-bg);\n    display: flex;\n    flex-direction: column;\n    padding: 0 12px;\n    &.root {\n      border: 0;\n      padding: 0;\n    }\n  }\n  .doc-node-body {\n    background: var(--color-blue-bg);\n    color: var(--color-black);\n    display: flex;\n    font-size: 13px;\n    margin-top: 3px;\n  }\n  .number-box {\n    padding: 3px 6px;\n    background: rgba($color-white, 0.3);\n  }\n  button {\n    background: transparent;\n    border: 0;\n    color: var(--color-black);\n    cursor: pointer;\n    display: flex;\n    height: 100%;\n    padding: 3px 9px;\n    white-space: pre;\n    width: 100%;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: var(--color-white);\n    }\n    &.selected {\n      background: rgba($color-red-light, 0.4);\n    }\n  }\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n  .inline-children {\n    border-left: 1px solid var(--color-purple);\n    border-right: 1px solid var(--color-purple);\n    display: flex;\n    flex-wrap: wrap;\n    padding: 0 12px;\n    /* TODO this hurts my soul */\n    & > :global(.doc-node) {\n      flex-grow: 1;\n      padding: 0;\n    }\n  }\n</style>\n","import { Schema } from 'prosemirror-model'\n\nconst nodeColors = <const>[\n  '#EA7C7F', // red\n  '#67B0C6', // cyan 400\n  '#94BB7F', // green\n  '#CA9EDB', // deep purple\n  '#DCDC5D', // lime\n  '#B9CC7C', // light green\n  '#DD97D8', // purple\n  '#FFB761', // orange\n  '#4D8FD1', // light blue\n  '#F36E98', // pink\n  '#E45F44', // deep orange\n  '#A6A4AE', // blue grey\n  '#FCC047', // yellow\n  '#FFC129', // amber\n  '#D3929C', // can can\n  '#4CBCD4', // cyan\n  '#8D7BC0' // indigo\n]\n\nexport function calculateSafeIndex(index: number, total: number) {\n  const quotient = index / total\n  return Math.round(total * (quotient - Math.floor(quotient)))\n}\n\nexport function buildColors(schema: Schema) {\n  return Object.keys(schema.nodes).reduce((acc, node, index) => {\n    const safeIndex =\n      index >= nodeColors.length ? calculateSafeIndex(index, nodeColors.length) : index\n\n    acc[node] = nodeColors[safeIndex]\n    return acc\n  }, {} as { [key: string]: typeof nodeColors[number] })\n}\n","<script lang=\"ts\">\n  import { setContext } from '$context'\n  import type { Node as PMNode, Schema } from 'prosemirror-model'\n\n  import DocNode from './DocNode.svelte'\n  import { buildColors } from './colors'\n\n  export let doc: PMNode,\n    schema: Schema,\n    selected = { type: '', start: 0, end: 0 },\n    handleNodeSelect: (n: PMNode) => void\n\n  setContext('doc-view', {\n    selected,\n    colors: buildColors(schema),\n    handleNodeClick: handleNodeSelect\n  })\n</script>\n\n<ul>\n  <DocNode class={$$props.class} node={doc} startPos={0} depth={0} isRoot />\n</ul>\n\n<style>\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n</style>\n","<script lang=\"ts\">\n  import type { Node as PMNode, Schema } from 'prosemirror-model'\n  import { getContext } from '$context'\n  import { latestEntry } from '$stores/stateHistory'\n\n  import TreeView from 'svelte-tree-view'\n  import SplitView from '../SplitView.svelte'\n  import DocView from './DocView.svelte'\n  import Button from '$components/Button.svelte'\n\n  const { view } = getContext('editor-view')\n  let doc: PMNode = view.state.doc\n  let selectedNode = view.state.doc\n  $: jsonNode = selectedNode.toJSON()\n  let schema: Schema = view.state.schema\n  let timer: ReturnType<typeof setTimeout>\n\n  latestEntry.subscribe(e => {\n    if (!e) return\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      doc = e.state.doc\n    }, 100)\n  })\n\n  function handleNodeSelect(n: PMNode) {\n    selectedNode = n\n  }\n  function handleClickLogNode() {\n    console.log(selectedNode)\n    window._node = selectedNode\n    console.info('%c [prosemirror-dev-toolkit]: Property added to window._node', 'color: #b8e248')\n  }\n</script>\n\n<SplitView>\n  <div slot=\"left\" class=\"left-panel\">\n    <div class=\"top-row\">\n      <h2>Current doc</h2>\n      <Button class=\"hidden\">log</Button>\n    </div>\n    <DocView class=\"m-top\" {doc} {schema} {handleNodeSelect} />\n  </div>\n  <div slot=\"right\" class=\"right-panel\">\n    <div class=\"top-row\">\n      <h2>Node info</h2>\n      <Button on:click={handleClickLogNode}>log</Button>\n    </div>\n    <TreeView class=\"m-top\" data={jsonNode} />\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  :global(.hidden) {\n    display: none;\n    visibility: hidden;\n  }\n  .top-row {\n    align-items: center;\n    display: flex;\n    justify-content: space-between;\n  }\n  .right-panel {\n    border-left: 1px solid rgba($color-red-light, 0.2);\n    flex-grow: 0;\n    min-width: 220px;\n    width: 220px;\n  }\n  :global(.split-view .m-top) {\n    margin-top: 0.5em;\n  }\n</style>\n","<script lang=\"ts\">\n  import type { Snapshot } from '$typings/snapshots'\n\n  export let snapshots: Snapshot[] = [],\n    selectedSnapshot: Snapshot | undefined = undefined,\n    onUpdate: (snap: Snapshot) => void,\n    onView: (snap?: Snapshot) => void,\n    onRestore: (snap: Snapshot) => void,\n    onExport: (snap: Snapshot) => void,\n    onDelete: (snap: Snapshot) => void\n\n  let editedSnap: Snapshot | undefined\n  let deleteSnap: Snapshot | undefined\n  let timer: number | undefined\n\n  const debounceUpdate = () => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      onUpdate(editedSnap as Snapshot)\n    }, 150)\n  }\n\n  function handleSnapDoubleclick(snap: Snapshot) {\n    editedSnap = snap\n    deleteSnap = undefined\n  }\n  function handleNameChange(evt: any) {\n    if (editedSnap) {\n      editedSnap.name = evt.target.value\n      debounceUpdate()\n    }\n  }\n  function handleNameKeyPress(evt: any) {\n    if (evt.key === 'Enter' && editedSnap) {\n      onUpdate(editedSnap)\n      clearTimeout(timer)\n      editedSnap = undefined\n      deleteSnap = undefined\n    }\n  }\n  function handleClickView(snap: Snapshot) {\n    if (selectedSnapshot?.timestamp === snap.timestamp) {\n      onView()\n    } else {\n      onView(snap)\n    }\n    deleteSnap = undefined\n  }\n  function handleRestoreClick(snap: Snapshot) {\n    onRestore(snap)\n    deleteSnap = undefined\n  }\n  function handleExportClick(snap: Snapshot) {\n    onExport(snap)\n    deleteSnap = undefined\n  }\n  function handleClickDelete(snap: Snapshot) {\n    if (!deleteSnap || deleteSnap.timestamp !== snap.timestamp) {\n      deleteSnap = snap\n    } else {\n      onDelete(snap)\n      deleteSnap = undefined\n    }\n  }\n</script>\n\n<ul>\n  {#each snapshots as snap}\n    <li>\n      {#if editedSnap && editedSnap.timestamp === snap.timestamp}\n        <input\n          value={editedSnap.name}\n          on:input={handleNameChange}\n          on:keypress={handleNameKeyPress}\n        />\n      {:else}\n        <button\n          class=\"unstyled-btn\"\n          aria-label=\"Edit snapshot name button\"\n          on:dblclick={() => handleSnapDoubleclick(snap)}>{snap.name}</button\n        >\n      {/if}\n      <button class=\"snapshot-btn ml-2\" on:click={() => handleClickView(snap)}>\n        {#if selectedSnapshot?.timestamp === snap.timestamp}\n          Hide\n        {:else}\n          Show\n        {/if}\n      </button>\n      <button class=\"snapshot-btn\" on:click={() => handleRestoreClick(snap)}>Restore</button>\n      <button class=\"snapshot-btn\" on:click={() => handleExportClick(snap)}>Export</button>\n      <button class=\"snapshot-btn\" on:click={() => handleClickDelete(snap)}>\n        {#if deleteSnap?.timestamp === snap.timestamp}\n          Confirm Delete\n        {:else}\n          Delete\n        {/if}\n      </button>\n    </li>\n  {/each}\n</ul>\n\n<style lang=\"scss\">\n  ul {\n    color: var(--color-white);\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    height: 100%;\n    width: 100%;\n  }\n  li + li {\n    border-top: 1px solid var(--color-purple);\n  }\n  li {\n    align-items: center;\n    display: flex;\n    font-family: monospace;\n    padding: 6px 18px;\n  }\n  input {\n    background: transparent;\n    border: 0;\n    color: var(--color-white);\n    height: 100%;\n    margin: 0;\n    padding: 2px;\n    width: 100%;\n  }\n  .unstyled-btn {\n    background: transparent;\n    border: 0;\n    color: var(--color-white);\n    cursor: pointer;\n    display: block;\n    font-family: monospace;\n    margin: 0;\n    padding: 0;\n    text-align: start;\n    width: 100%;\n  }\n  .snapshot-btn {\n    background: transparent;\n    border: 0;\n    border-radius: 3px;\n    color: var(--color-gray-light);\n    cursor: pointer;\n    display: flex;\n    font-size: 11px;\n    padding: 6px 18px;\n    text-transform: uppercase;\n    &:hover {\n      background: rgba($color-red-light, 0.4);\n      color: var(--color-white);\n    }\n  }\n  .ml-2 {\n    margin-left: 1rem;\n  }\n</style>\n","<script lang=\"ts\">\n  import { getContext } from '$context'\n\n  import SplitView from '$tabs/SplitView.svelte'\n  import SnapshotsList from './SnapshotsList.svelte'\n  import {\n    snapshots,\n    selectedSnapshot,\n    updateSnapshot,\n    toggleViewSnapshot,\n    restoreSnapshot,\n    exportSnapshot,\n    deleteSnapshot\n  } from '$stores/snapshots'\n  import { resetHistory } from '$stores/stateHistory'\n  import type { Snapshot } from '$typings/snapshots'\n\n  const { view } = getContext('editor-view')\n\n  function handleRestoreSnapshot(snapshot: Snapshot) {\n    restoreSnapshot(view, snapshot)\n    resetHistory()\n  }\n</script>\n\n<SplitView>\n  <div slot=\"right\" class=\"right-panel\">\n    {#if $snapshots.length === 0}\n      <div class=\"no-snapshots\">Save snapshots by clicking \"Save snapshot\" button.</div>\n    {:else}\n      <SnapshotsList\n        snapshots={$snapshots}\n        selectedSnapshot={$selectedSnapshot}\n        onUpdate={updateSnapshot}\n        onView={snap => toggleViewSnapshot(view, snap)}\n        onRestore={handleRestoreSnapshot}\n        onExport={exportSnapshot}\n        onDelete={deleteSnapshot}\n      />\n    {/if}\n  </div>\n</SplitView>\n\n<style lang=\"scss\">\n  .right-panel {\n    padding: 0;\n  }\n  .no-snapshots {\n    align-items: center;\n    color: var(--color-red-light);\n    display: flex;\n    font-size: 14px;\n    height: 100%;\n    justify-content: center;\n    width: 100%;\n  }\n</style>\n","<script lang=\"ts\">\n  import { onDestroy } from 'svelte'\n  import { getContext } from '$context'\n\n  import { saveSnapshot, importSnapshot } from '$stores/snapshots'\n\n  import TabsMenu from '$tabs/TabsMenu.svelte'\n  import StateTab from '$tabs/state/StateTab.svelte'\n  import HistoryTab from '$tabs/history/HistoryTab.svelte'\n  import PluginsTab from '$tabs/PluginsTab.svelte'\n  import SchemaTab from '$tabs/SchemaTab.svelte'\n  import StructureTab from '$tabs/structure/StructureTab.svelte'\n  import SnapshotsTab from '$tabs/snapshots/SnapshotsTab.svelte'\n\n  export let onClose: () => void\n\n  const { view } = getContext('editor-view')\n  let openTab = 'state',\n    dockTop = 50,\n    dockHeight = 50,\n    fileinput: HTMLInputElement\n\n  onDestroy(() => {\n    document.removeEventListener('mousemove', dragMove)\n    document.removeEventListener('mouseup', dragEnd)\n  })\n\n  function handleResizeMouseDown() {\n    document.addEventListener('mousemove', dragMove)\n    document.addEventListener('mouseup', dragEnd)\n  }\n  function dragMove(evt: MouseEvent) {\n    evt.preventDefault()\n    dockTop = (100 * evt.clientY) / window.innerHeight\n    dockHeight = 100 * (1 - evt.clientY / window.innerHeight)\n  }\n  function dragEnd(evt: MouseEvent) {\n    evt.preventDefault()\n    document.removeEventListener('mousemove', dragMove)\n    document.removeEventListener('mouseup', dragEnd)\n  }\n  function handleSaveSnapshot() {\n    const defaultName = new Date().toLocaleString('sv')\n    const snapshotName = prompt('Enter snapshot name', defaultName)\n    if (snapshotName) {\n      saveSnapshot(snapshotName, view.state.doc.toJSON())\n    }\n  }\n  function handleImportSnapshot() {\n    fileinput.click()\n  }\n  function handleFileSelected(\n    e: Event & {\n      currentTarget: EventTarget & HTMLInputElement\n    }\n  ) {\n    const target = <HTMLInputElement>e.target\n    Array.from(target.files || []).forEach(file => {\n      const reader = new FileReader()\n      reader.readAsText(file)\n      reader.onload = e => {\n        const data = typeof e.target?.result === 'string' ? e.target?.result : ''\n        try {\n          const json = JSON.parse(data)\n          if (!json || typeof json !== 'object') {\n            throw Error('Imported snapshot was not a JSON object' + json)\n          }\n          const name = file.name.slice(0, file.name.lastIndexOf('.'))\n          importSnapshot(name, json, view.state.schema)\n        } catch (err) {\n          console.error('Failed to import snapshot: ' + err)\n        }\n      }\n    })\n  }\n  function handleClickTab(tab: string) {\n    openTab = tab\n  }\n</script>\n\n<div class=\"floating-dock-wrapper\">\n  <div class=\"floating-dock\" style={`top: ${dockTop}%; height: ${dockHeight}%;`}>\n    <div class=\"resizing-div\" on:mousedown={handleResizeMouseDown} />\n    <div class=\"container\">\n      <div>\n        <button class=\"snap-save-btn\" on:click={handleSaveSnapshot}>Save snapshot</button>\n        <button class=\"snap-import-btn\" on:click={handleImportSnapshot}>Import snapshot</button>\n        <button class=\"close-btn\" aria-label=\"Close dev-toolkit button\" on:click={onClose}>X</button\n        >\n      </div>\n      <input\n        style=\"display:none\"\n        type=\"file\"\n        accept=\".json\"\n        multiple\n        on:change={handleFileSelected}\n        bind:this={fileinput}\n      />\n      <TabsMenu onClickTab={handleClickTab} active={openTab} />\n      {#if openTab === 'state'}\n        <StateTab />\n      {:else if openTab === 'history'}\n        <HistoryTab />\n      {:else if openTab === 'plugins'}\n        <PluginsTab />\n      {:else if openTab === 'schema'}\n        <SchemaTab />\n      {:else if openTab === 'structure'}\n        <StructureTab />\n      {:else if openTab === 'snapshots'}\n        <SnapshotsTab />\n      {:else}\n        <p>nuting here</p>\n      {/if}\n    </div>\n  </div>\n</div>\n\n<style lang=\"scss\">\n  .floating-dock-wrapper {\n    position: fixed;\n    width: 0px;\n    height: 0px;\n    top: 0px;\n    left: 0px;\n    z-index: 99999999;\n  }\n  .floating-dock {\n    background-color: var(--color-blue-bg);\n    position: fixed;\n    z-index: 1;\n    box-shadow: rgba($color-black, 0.3) 0px 0px 4px 0px;\n    left: 0px;\n    top: 50%;\n    width: 100%;\n    height: 50%;\n  }\n  .resizing-div {\n    position: absolute;\n    z-index: 2;\n    opacity: 0;\n    top: -5px;\n    height: 10px;\n    left: 0px;\n    width: 100%;\n    cursor: row-resize;\n  }\n  .container {\n    height: 100%;\n  }\n  .snap-save-btn {\n    background: rgba($color-red-light, 0.6);\n    border: 0;\n    border-radius: 3px;\n    color: var(--color-white);\n    cursor: pointer;\n    font-size: 12px;\n    height: 24px;\n    line-height: 25px;\n    padding: 0 6px;\n    position: absolute;\n    right: 134px;\n    top: -28px;\n    &:hover {\n      background: rgba($color-red-light, 0.8);\n    }\n  }\n  .snap-import-btn {\n    background: rgba($color-red-light, 0.6);\n    border: 0;\n    border-radius: 3px;\n    color: var(--color-white);\n    cursor: pointer;\n    font-size: 12px;\n    height: 24px;\n    line-height: 25px;\n    padding: 0 6px;\n    position: absolute;\n    right: 32px;\n    top: -28px;\n    &:hover {\n      background: rgba($color-red-light, 0.8);\n    }\n  }\n  .close-btn {\n    background: rgba($color-red-light, 0.6);\n    border: 0;\n    border-radius: 3px;\n    color: var(--color-white);\n    cursor: pointer;\n    height: 24px;\n    position: absolute;\n    right: 4px;\n    top: -28px;\n    width: 24px;\n    &:hover {\n      background: rgba($color-red-light, 0.8);\n    }\n  }\n</style>\n","<script lang=\"ts\">\n  import { onMount } from 'svelte'\n  import type { EditorView } from 'prosemirror-view'\n  import { setContext } from '$context'\n\n  import FloatingBtn from './FloatingBtn.svelte'\n  import FloatingDock from './FloatingDock.svelte'\n\n  import type { ButtonPosition } from '../types'\n\n  export let view: EditorView,\n    devToolsExpanded = false,\n    buttonPosition: ButtonPosition = 'bottom-right'\n\n  setContext('editor-view', {\n    view\n  })\n\n  onMount(() => {\n    const html = document && document.querySelector('html')\n    if (devToolsExpanded && html) {\n      html.style.marginBottom = '341px'\n    }\n  })\n\n  function handleFloatingBtnClick() {\n    devToolsExpanded = true\n    const html = document && document.querySelector('html')\n    if (html) {\n      html.style.marginBottom = '341px'\n    }\n  }\n  function handleFloatingDockClose() {\n    devToolsExpanded = false\n    const html = document && document.querySelector('html')\n    if (html) {\n      html.style.marginBottom = ''\n    }\n  }\n</script>\n\n<section>\n  {#if devToolsExpanded}\n    <FloatingDock onClose={handleFloatingDockClose} />\n  {:else}\n    <FloatingBtn on:click={handleFloatingBtnClick} {buttonPosition} />\n  {/if}\n</section>\n\n<style lang=\"scss\">\n  * {\n    --font-sans: Helvetica Neue, Calibri Light, Roboto, sans-serif;\n    --font-small: 11px;\n    --font-medium: 13px;\n    --font-large: 16px;\n    --height-tabs-menu: 48px;\n    --color-black: #222;\n    --color-blue-bg: #363755;\n    --color-blue-light: #85d9ef;\n    /* --color-green-text: #b8e248; */\n    --color-gray-light: #d3d3d9;\n    --color-green: green; // diff inserted\n    --color-green-light: #87cc86; // diff deleted color\n    --color-purple-dark: rgb(80, 68, 93); // list darker bg\n    --color-purple: rgb(96, 76, 104); // borders in eg lists\n    --color-purple-light: rgb(99, 99, 123); // list text color\n    --color-red: #d66363; // diff deleted\n    --color-red-gray: rgb(187, 145, 163); // h2 color\n    --color-red-light: rgb(255, 162, 177);\n    --color-yellow: #eaea37; // diff updated\n    --color-white: #fff;\n  }\n  :root {\n    --tree-view-base00: #363755;\n    --tree-view-base01: #604d49;\n    --tree-view-base02: #6d5a55;\n    --tree-view-base03: #d1929b;\n    --tree-view-base04: #b79f8d;\n    --tree-view-base05: #f9f8f2;\n    --tree-view-base06: #f7f4f1;\n    --tree-view-base07: #faf8f5;\n    --tree-view-base08: #fa3e7e;\n    --tree-view-base09: #fd993c;\n    --tree-view-base0A: #f6bf81;\n    --tree-view-base0B: #b8e248;\n    --tree-view-base0C: #b4efe4;\n    --tree-view-base0D: #85d9ef;\n    --tree-view-base0E: #be87ff;\n    --tree-view-base0F: #d6724c;\n  }\n  section {\n    font-family: var(--font-sans);\n    font-size: var(--font-medium);\n  }\n</style>\n","import type { EditorView } from 'prosemirror-view'\nimport type { Transaction } from 'prosemirror-state'\n\nimport { appendNewHistoryEntry } from '$stores/stateHistory'\n\nlet active = false,\n  resetDispatch: (() => void) | undefined = undefined\n\nexport function subscribeToDispatchTransaction(view: EditorView): Promise<void> {\n  active = true\n  // Use timeout to make sure other hooks don't interfere with our patching of dispatchTransaction\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resetDispatch && resetDispatch()\n      const oldDispatchFn = (view.someProp('dispatchTransaction') || view.dispatch).bind(view)\n      view.setProps({\n        dispatchTransaction: (tr: Transaction) => {\n          const stateBeforeDispatch = view.state\n          oldDispatchFn(tr)\n          if (active) {\n            appendNewHistoryEntry(tr, view.state, stateBeforeDispatch)\n          }\n        }\n      })\n      resetDispatch = () => view.setProps({ dispatchTransaction: oldDispatchFn })\n      resolve()\n    }, 1)\n  })\n}\n\nexport function unsubscribeDispatchTransaction() {\n  active = false\n  resetDispatch && resetDispatch()\n  resetDispatch = undefined\n}\n","import type { Transaction } from 'prosemirror-state'\nimport type { EditorView } from 'prosemirror-view'\nimport DevTools from './components/DevTools.svelte'\nimport {\n  subscribeToDispatchTransaction,\n  unsubscribeDispatchTransaction\n} from './history-and-diff/subscribeToTransactions'\nimport { resetHistory } from './stores/stateHistory'\n\nimport { DevToolsOpts } from './types'\nimport type { Plugin } from './typings/pm'\n\ndeclare global {\n  interface Window {\n    applyDevTools: typeof applyDevTools\n    editorView?: EditorView\n    _node?: any\n    _doc?: { [key: string]: any }\n    _tr?: Transaction\n    _plugin?: [Plugin | undefined, unknown]\n  }\n}\n\nconst DEVTOOLS_CLASS_NAME = '__prosemirror-dev-toolkit__'\n\ntry {\n  // Make the dev tools available globally for some scripting shenanigans\n  if (typeof window !== 'undefined') window.applyDevTools = applyDevTools\n} catch (err) {}\n\nfunction createOrFindPlace() {\n  let place: HTMLElement | null = document.querySelector(`.${DEVTOOLS_CLASS_NAME}`)\n\n  if (!place) {\n    place = document.createElement('div')\n    place.className = DEVTOOLS_CLASS_NAME\n    document.body.appendChild(place)\n  }\n\n  return place\n}\n\nlet removeCallback: (() => void) | undefined\n\nexport function applyDevTools(view: EditorView, opts: DevToolsOpts = {}) {\n  const place = createOrFindPlace()\n\n  removeDevTools()\n\n  const comp = new DevTools({\n    target: place,\n    props: {\n      view,\n      ...opts\n    }\n  })\n  try {\n    // Make the editor view available since it might be handy for quick debugging\n    if (typeof window !== 'undefined') window.editorView = view\n  } catch (err) {}\n\n  // Bind the component's life-cycle to the editorView to automatically unmount the devTools\n  const oldDestroyFn = view.destroy.bind(view)\n  view.destroy = () => {\n    // DevTools must always be removed before view as the resetDispatch requires view to be still present\n    removeDevTools()\n    oldDestroyFn()\n  }\n\n  removeCallback = () => {\n    resetHistory()\n    unsubscribeDispatchTransaction()\n    // TODO add test to check no \"Component already destroyed\" warnings appear\n    comp.$destroy()\n  }\n  return subscribeToDispatchTransaction(view)\n}\n\nexport function removeDevTools() {\n  removeCallback && removeCallback()\n  removeCallback = undefined\n}\n"],"sourceRoot":""}